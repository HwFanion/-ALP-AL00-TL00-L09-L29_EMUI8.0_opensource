From 41660b2202afe47907b78f9851c095c29e2bd2b2 Mon Sep 17 00:00:00 2001
From: zwx486476 <zwx486476@notesmail.huawei.com>
Date: Sat, 21 Oct 2017 17:25:24 +0800
Subject: [PATCH] DTS:DTS2017101909663 Description:1) fix modem link error 		2) Add a repo compile task: kirin970_kernel_release 		   To create 'dtc', cause 'make' command(check_kernel_release.sh 		   -->make ARCH=......mage.log) needs it. 		3) Revert Livepatch code for HKIP Team:HISI_EE Feature or Bugfix:Feature

Change-Id: Ie9e522543e5d35e92a853324555acf21e8e9d146
Signed-off-by: zwx486476 <zwx486476@notesmail.huawei.com>
Signed-off-by: l00372436 <l00372436@notesmail.huawei.com>
Signed-off-by: x00387401 <x00387401@notesmail.huawei.com>
Signed-off-by: l00390671 <l00390671@notesmail.huawei.com>
---

diff --git a/Android.mk b/Android.mk
index b5070a6..b6cb7aa 100644
--- a/Android.mk
+++ b/Android.mk
@@ -370,7 +370,7 @@
 endif
 
 
-kernel_release_prebuild:  $(GPIO_IOMUX_FILE)  $(GENERATE_DTB) | $(KERNEL_CONFIG)
+kernel_release_prebuild:  $(GPIO_IOMUX_FILE)  $(GENERATE_DTB) | $(KERNEL_CONFIG) dtc
 	@echo $@
 
 ifeq ($(KP_MODULE), false)
diff --git a/Documentation/ABI/testing/sysfs-kernel-livepatch b/Documentation/ABI/testing/sysfs-kernel-livepatch
old mode 100644
new mode 100755
index 5c12254..5bf42a8
--- a/Documentation/ABI/testing/sysfs-kernel-livepatch
+++ b/Documentation/ABI/testing/sysfs-kernel-livepatch
@@ -34,7 +34,6 @@
 		that is patched within the object.
 
 What:		/sys/kernel/livepatch/<patch>/<object>/<function>
-		or: /sys/kernel/livepatch/<patch>/<object>/<function-number>
 Date:		Nov 2014
 KernelVersion:	3.19.0
 Contact:	live-patching@vger.kernel.org
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
old mode 100644
new mode 100755
index a27ddd1..14a827f
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -104,7 +104,6 @@
 	select SYSCTL_EXCEPTION_TRACE
 	select HAVE_CONTEXT_TRACKING
 	select HAVE_ARM_SMCCC
-	select HAVE_LIVEPATCH
 	help
 	  ARM 64-bit (AArch64) Linux support.
 
@@ -226,8 +225,6 @@
 source "init/Kconfig"
 
 source "kernel/Kconfig.freezer"
-
-source "kernel/livepatch/Kconfig"
 
 source "arch/arm64/Kconfig.platforms"
 
diff --git a/arch/arm64/Kconfig.debug b/arch/arm64/Kconfig.debug
index 03a8993..e41a41c 100644
--- a/arch/arm64/Kconfig.debug
+++ b/arch/arm64/Kconfig.debug
@@ -85,6 +85,5 @@
 
 	  If in doubt, say N
 
-source "drivers/hwtracing/hisi_coresight/Kconfig"
 
 endmenu
diff --git a/arch/arm64/configs/hisi_3660_defconfig b/arch/arm64/configs/hisi_3660_defconfig
old mode 100644
new mode 100755
index 65fea73..f3d279e
--- a/arch/arm64/configs/hisi_3660_defconfig
+++ b/arch/arm64/configs/hisi_3660_defconfig
@@ -360,13 +360,6 @@
 CONFIG_HW_NETWORK_AWARE=y
 CONFIG_HW_IAWARE_THREAD_BOOST=y
 CONFIG_FREEZER=y
-CONFIG_HAVE_LIVEPATCH=y
-
-#
-# Enable Livepatch
-#
-CONFIG_LIVEPATCH=y
-CONFIG_LIVEPATCH_STACK=y
 
 #
 # Platform selection
@@ -4597,9 +4590,6 @@
 CONFIG_HW_NETWORK_MEASUREMENT=y
 # CONFIG_HUAWEI_DTV_MMTUNER is not set
 CONFIG_DP_AUX_SWITCH=y
-CONFIG_OASES=y
-CONFIG_OASES_SIGNATURE_SUPPORT=y
-CONFIG_OASES_STATIC_PLTS=y
 # CONFIG_HW_DP_SOURCE is not set
 CONFIG_HUAWEI_DSM=y
 # CONFIG_HUAWEI_SDCARD_VOLD is not set
diff --git a/arch/arm64/configs/hisi_kirin970_defconfig b/arch/arm64/configs/hisi_kirin970_defconfig
old mode 100644
new mode 100755
index 04df815..5fb01e0
--- a/arch/arm64/configs/hisi_kirin970_defconfig
+++ b/arch/arm64/configs/hisi_kirin970_defconfig
@@ -148,7 +148,6 @@
 # CONFIG_CHECKPOINT_RESTORE is not set
 # CONFIG_NAMESPACES is not set
 CONFIG_HISI_EAS_SCHED=y
-CONFIG_HISI_RT_OPT=y
 # CONFIG_SCHED_AUTOGROUP is not set
 CONFIG_SCHED_TUNE=y
 CONFIG_DEFAULT_USE_ENERGY_AWARE=y
@@ -287,18 +286,18 @@
 # CONFIG_BLK_CMDLINE_PARSER is not set
 CONFIG_BLOCK_COMPAT=y
 # CONFIG_BLK_MQ_REFCOUNT is not set
-CONFIG_HISI_BLOCK_FREQUENCE_CONTROL=y
+# CONFIG_HISI_BLOCK_FREQUENCE_CONTROL is not set
 CONFIG_MMC_BLOCK_IOMMU_64BIT=y
-CONFIG_HISI_BLK_CORE=y
-CONFIG_HISI_MANUAL_BKOPS=y
-CONFIG_HISI_BLK_MQ=y
+# CONFIG_HISI_BLK_CORE is not set
+# CONFIG_HISI_MANUAL_BKOPS is not set
+# CONFIG_HISI_BLK_MQ is not set
 # CONFIG_HISI_MQ_DEBUG is not set
-CONFIG_HISI_BLK_MQ_DUMP=y
-CONFIG_HISI_MQ_DISPATCH_DECISION=y
+# CONFIG_HISI_BLK_MQ_DUMP is not set
+# CONFIG_HISI_MQ_DISPATCH_DECISION is not set
 # CONFIG_HISI_MQ_USING_HOQ is not set
 # CONFIG_HISI_MQ_USING_CP is not set
-CONFIG_HISI_IO_LATENCY_TRACE=y
-CONFIG_HISI_BLK_FLUSH_REDUCE=y
+# CONFIG_HISI_IO_LATENCY_TRACE is not set
+# CONFIG_HISI_BLK_FLUSH_REDUCE is not set
 # CONFIG_HISI_BLK_FUNCTION_TEST is not set
 CONFIG_HISI_PARTITION=y
 # CONFIG_HISI_PARTITION_HI3650 is not set
@@ -346,8 +345,7 @@
 #
 # Enable Livepatch
 #
-CONFIG_LIVEPATCH=y
-CONFIG_LIVEPATCH_STACK=y
+# CONFIG_LIVEPATCH is not set
 
 #
 # Platform selection
@@ -501,7 +499,7 @@
 CONFIG_PROCESS_RECLAIM=y
 CONFIG_HISI_SWAP_ZDATA=y
 CONFIG_HISI_DIRECT_SWAPPINESS=y
-CONFIG_HISI_PAGECACHE_HELPER=y
+# CONFIG_HISI_PAGECACHE_HELPER is not set
 # CONFIG_DEBUG_VMALLOC is not set
 # CONFIG_HISI_FALLBACK_MOVEABLE is not set
 # CONFIG_HISI_STRONG_BALANCE is not set
@@ -1472,8 +1470,8 @@
 CONFIG_HUAWEI_UFS_DSM=y
 CONFIG_SCSI_UFS_HI1861_VCMD=y
 CONFIG_SCSI_UFS_KIRIN_V21=y
-CONFIG_HISI_UFS_MANUAL_BKOPS=y
-CONFIG_HUAWEI_UFS_VENDOR_MODE=y
+# CONFIG_HISI_UFS_MANUAL_BKOPS is not set
+# CONFIG_HUAWEI_UFS_VENDOR_MODE is not set
 # CONFIG_SCSI_HPTIOP is not set
 # CONFIG_SCSI_SNIC is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -4292,8 +4290,8 @@
 #
 # Bluetooth device drivers
 #
-CONFIG_BT_POWER=m
-CONFIG_BT_SLEEP=m
+CONFIG_BT_POWER=y
+CONFIG_BT_SLEEP=y
 CONFIG_BCMGPS=y
 CONFIG_BCMGPS4752=y
 CONFIG_BCMGPS47531=y
@@ -4329,7 +4327,7 @@
 CONFIG_HW_VOWIFI=y
 CONFIG_HW_WLANFTY_STATUS=y
 CONFIG_HW_ABS=y
-CONFIG_DHD_STATIC_KO=y
+# CONFIG_DHD_STATIC_KO is not set
 CONFIG_HW_GET_EXT_SIG=y
 CONFIG_HWCONNECTIVITY=y
 CONFIG_HWGPS=y
@@ -4368,7 +4366,7 @@
 # NFC (Near Field Communication)
 #
 CONFIG_NFC_DEVICES=y
-CONFIG_PN547_NFC_64=m
+CONFIG_PN547_NFC_64=y
 # CONFIG_BCM20793_NFC is not set
 # CONFIG_DUAL_LOADSWITCH_FAN54151 is not set
 # CONFIG_DUAL_LOADSWITCH_RT9748 is not set
@@ -4478,7 +4476,7 @@
 # CONFIG_HW_VOLTAGE_DETECTION is not set
 # CONFIG_ANTENNA_BOARDID_GPIO_DETECT is not set
 CONFIG_HUAWEI_VIBRATOR=y
-CONFIG_DRV2605=m
+CONFIG_DRV2605=y
 # CONFIG_HUAWEI_OCP is not set
 CONFIG_MADAPT=y
 # CONFIG_DOME_KEY is not set
@@ -4511,7 +4509,7 @@
 CONFIG_HI110X_SDIO_STD_CARD_SUPPORT=y
 CONFIG_HI110X_SDIO_FPGA=y
 CONFIG_HI110X_SDIO_DETECT_FUNCTION=y
-CONFIG_HI1102_PLATFORM=m
+CONFIG_HI1102_PLATFORM=y
 CONFIG_HI1102_PLAT_HW_CHR=y
 CONFIG_HI1102_PLAT_OAL=y
 CONFIG_HI1102_PLAT_FRW=y
@@ -4520,7 +4518,7 @@
 CONFIG_HI1102_PLAT_PS=y
 CONFIG_HI1102_PLAT_PM=y
 CONFIG_HI1102_PLAT_MAIN=y
-CONFIG_HI1102_WIFI=m
+CONFIG_HI1102_WIFI=y
 CONFIG_HI1102_WIFI_HMAC=y
 CONFIG_HI1102_WIFI_WAL=y
 CONFIG_HI1102_WIFI_MAIN=y
@@ -4547,7 +4545,7 @@
 CONFIG_AUDIOKIT=y
 CONFIG_HUAWEI_DSM_AUDIO=y
 CONFIG_HUAWEI_DEVICEBOX_AUDIO=y
-CONFIG_HUAWEI_SMARTPAKIT_AUDIO=m
+CONFIG_HUAWEI_SMARTPAKIT_AUDIO=y
 CONFIG_HISI_SPMI=y
 CONFIG_LCDKIT_DRIVER=y
 CONFIG_HUAWEI_HOST_TS_KIT=y
diff --git a/arch/arm64/configs/hw_kirin970_defconfig b/arch/arm64/configs/hw_kirin970_defconfig
new file mode 100644
index 0000000..e805410
--- /dev/null
+++ b/arch/arm64/configs/hw_kirin970_defconfig
@@ -0,0 +1,5360 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm64 4.4.23 Kernel Configuration
+#
+CONFIG_ARM64=y
+CONFIG_64BIT=y
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=16
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_HAVE_GENERIC_RCU_GUP=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_SMP=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=3
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_FHANDLE is not set
+# CONFIG_USELIB is not set
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_SCHED_WALT is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_EXPERT=y
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_FANOUT=64
+CONFIG_RCU_FANOUT_LEAF=16
+CONFIG_RCU_FAST_NO_HZ=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+CONFIG_RCU_KTHREAD_PRIO=0
+# CONFIG_RCU_NOCB_CPU is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+CONFIG_BUILD_BIN2C=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=20
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_BOOST_KILL=y
+CONFIG_HW_BOOST_SIGKILL_FREE=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_HW_CGROUP_PIDS=y
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_HW_CGROUP_IONICE is not set
+CONFIG_CGROUP_IOLIMIT=y
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_SCHEDTUNE=y
+# CONFIG_MEMCG is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_HISI_EAS_SCHED=y
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_SCHED_TUNE=y
+CONFIG_DEFAULT_USE_ENERGY_AWARE=y
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_RD_LZ4=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PRINTK=y
+# CONFIG_HUAWEI_PRINTK_CTRL is not set
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_PCI_QUIRKS=y
+CONFIG_MEMBARRIER=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_HW_BREAKPOINT_ADDR_MASK=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_RCU_TABLE_FREE=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR_NONE is not set
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+CONFIG_CC_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS=y
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+# CONFIG_MODULE_ENABLE_WITH_ENG is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_BLK_DEV_HI_PRIO_FOR_FG=y
+# CONFIG_BLK_CMDLINE_PARSER is not set
+CONFIG_BLOCK_COMPAT=y
+# CONFIG_BLK_MQ_REFCOUNT is not set
+# CONFIG_HISI_BLOCK_FREQUENCE_CONTROL is not set
+CONFIG_MMC_BLOCK_IOMMU_64BIT=y
+# CONFIG_HISI_BLK_CORE is not set
+# CONFIG_HISI_MANUAL_BKOPS is not set
+# CONFIG_HISI_BLK_MQ is not set
+# CONFIG_HISI_MQ_DEBUG is not set
+# CONFIG_HISI_BLK_MQ_DUMP is not set
+# CONFIG_HISI_MQ_DISPATCH_DECISION is not set
+# CONFIG_HISI_MQ_USING_HOQ is not set
+# CONFIG_HISI_MQ_USING_CP is not set
+# CONFIG_HISI_IO_LATENCY_TRACE is not set
+# CONFIG_HISI_BLK_FLUSH_REDUCE is not set
+# CONFIG_HISI_BLK_FUNCTION_TEST is not set
+CONFIG_HISI_PARTITION=y
+# CONFIG_HISI_PARTITION_HI3650 is not set
+# CONFIG_HISI_PARTITION_HI6250 is not set
+# CONFIG_HISI_PARTITION_HI3660 is not set
+CONFIG_HISI_PARTITION_KIRIN970=y
+# CONFIG_HISI_PARTITION_KIRIN980 is not set
+CONFIG_HW_SYSTEM_WR_PROTECT=y
+CONFIG_HISI_AB_PARTITION=y
+CONFIG_HISI_BLK_INLINE_CRYPTO=y
+CONFIG_BLK_QUEUE_USR_CTRL=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_ROW is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CFQ_GROUP_IOSCHED is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_HISI_STORAGE_UFS_PARTITION=y
+CONFIG_ASN1=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_HW_VIP_THREAD=y
+CONFIG_HW_NETWORK_AWARE=y
+CONFIG_HW_IAWARE_THREAD_BOOST=y
+CONFIG_FREEZER=y
+CONFIG_HAVE_LIVEPATCH=y
+
+#
+# Enable Livepatch
+#
+CONFIG_LIVEPATCH=y
+CONFIG_LIVEPATCH_STACK=y
+
+#
+# Platform selection
+#
+# CONFIG_ARCH_BCM_IPROC is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_EXYNOS7 is not set
+# CONFIG_ARCH_LAYERSCAPE is not set
+CONFIG_ARCH_HISI=y
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_SEATTLE is not set
+# CONFIG_ARCH_STRATIX10 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_SPRD is not set
+# CONFIG_ARCH_THUNDER is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_XGENE is not set
+# CONFIG_ARCH_ZYNQMP is not set
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_PCI_BUS_ADDR_T_64BIT=y
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_PCI_DEBUG=y
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+CONFIG_PCI_STUB=y
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+
+#
+# PCI host controller drivers
+#
+CONFIG_PCIE_DW=y
+# CONFIG_PCI_HOST_GENERIC is not set
+# CONFIG_PCIE_IPROC is not set
+# CONFIG_PCI_HISI is not set
+# CONFIG_KIRIN_PCIE_TEST is not set
+CONFIG_PCIE_KIRIN=y
+# CONFIG_PCIE_KIRIN_SLT is not set
+CONFIG_PCIE_KIRIN_DMD=y
+# CONFIG_KIRIN_PCIE_EYEPARAM is not set
+# CONFIG_KIRIN_PCIE_HI3660 is not set
+CONFIG_KIRIN_PCIE_KIRIN970=y
+# CONFIG_KIRIN_PCIE_KIRIN980 is not set
+CONFIG_PCIEPORTBUS=y
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+CONFIG_PCIEAER=y
+CONFIG_PCIE_ECRC=y
+CONFIG_PCIEAER_INJECT=y
+# CONFIG_PCIEASPM is not set
+CONFIG_PCIE_PME=y
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# Kernel Features
+#
+
+#
+# ARM errata workarounds via the alternatives framework
+#
+CONFIG_ARM64_ERRATUM_826319=y
+CONFIG_ARM64_ERRATUM_827319=y
+CONFIG_ARM64_ERRATUM_824069=y
+CONFIG_ARM64_ERRATUM_819472=y
+CONFIG_ARM64_ERRATUM_832075=y
+CONFIG_ARM64_ERRATUM_845719=y
+CONFIG_ARM64_ERRATUM_843419=y
+CONFIG_CAVIUM_ERRATUM_22375=y
+CONFIG_CAVIUM_ERRATUM_23154=y
+CONFIG_CAVIUM_ERRATUM_27456=y
+CONFIG_ARM64_ERRATUM_858921=y
+CONFIG_ARM64_4K_PAGES=y
+# CONFIG_ARM64_16K_PAGES is not set
+# CONFIG_ARM64_64K_PAGES is not set
+CONFIG_ARM64_VA_BITS_39=y
+# CONFIG_ARM64_VA_BITS_48 is not set
+CONFIG_ARM64_VA_BITS=39
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_SCHED_MC=y
+# CONFIG_SCHED_SMT is not set
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HW_PERF_EVENTS=y
+# CONFIG_HISI_HW_PERF_EVENTS is not set
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_SHRINK_MEMORY=y
+# CONFIG_SHRINK_MEMORY_CANCEL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+# CONFIG_CMA_DEBUGFS is not set
+# CONFIG_HISI_CMA_DEBUG is not set
+CONFIG_CMA_AREAS=7
+CONFIG_ZPOOL=y
+CONFIG_ZBUD=y
+CONFIG_ZSMALLOC=y
+CONFIG_PGTABLE_MAPPING=y
+CONFIG_ZSMALLOC_STAT=y
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_PROCESS_RECLAIM=y
+CONFIG_HISI_SWAP_ZDATA=y
+CONFIG_HISI_DIRECT_SWAPPINESS=y
+# CONFIG_HISI_PAGECACHE_HELPER is not set
+# CONFIG_DEBUG_VMALLOC is not set
+# CONFIG_HISI_FALLBACK_MOVEABLE is not set
+# CONFIG_HISI_STRONG_BALANCE is not set
+# CONFIG_HISI_THREADINFO_NORMAL_ZONE is not set
+CONFIG_HISI_RESORT_ZONE_FREELIST=y
+CONFIG_HUAWEI_UNMOVABLE_ISOLATE=y
+CONFIG_HUAWEI_UNMOVABLE_ISOLATE1_SIZE_MBYTES=256
+CONFIG_HUAWEI_UNMOVABLE_ISOLATE2_SIZE_MBYTES=64
+CONFIG_HISI_MM=y
+# CONFIG_HISI_SLOW_PATH_COUNT is not set
+CONFIG_SECCOMP=y
+# CONFIG_XEN is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ARMV8_DEPRECATED=y
+CONFIG_SWP_EMULATION=y
+CONFIG_CP15_BARRIER_EMULATION=y
+CONFIG_SETEND_EMULATION=y
+# CONFIG_ARM64_SW_TTBR0_PAN is not set
+
+#
+# ARMv8.1 architectural features
+#
+# CONFIG_ARM64_HW_AFDBM is not set
+# CONFIG_ARM64_PAN is not set
+# CONFIG_ARM64_LSE_ATOMICS is not set
+# CONFIG_ARM64_UAO is not set
+CONFIG_ARM64_MODULE_CMODEL_LARGE=y
+CONFIG_ARM64_MODULE_PLTS=y
+CONFIG_RELOCATABLE=y
+CONFIG_RANDOMIZE_BASE=y
+# CONFIG_RANDOMIZE_MODULE_REGION_FULL is not set
+
+#
+# Boot options
+#
+CONFIG_CMDLINE="console=ttyAMA0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_EFI is not set
+# CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+CONFIG_COMPAT=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_WAKELOCK=y
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=100
+CONFIG_PM_WAKELOCKS_GC=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_PM_SLEEP_DEBUG=y
+CONFIG_DPM_WATCHDOG=y
+CONFIG_DPM_WATCHDOG_TIMEOUT=60
+CONFIG_PM_OPP=y
+CONFIG_PM_CLK=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_PM=y
+CONFIG_HUAWEI_SLEEPLOG=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+# CONFIG_CONFIG_IDLE_TRIPPLE_DRIVERS is not set
+CONFIG_HISI_IDLE_SLEEP=y
+# CONFIG_CPU_IDLE_GOV_LADDER is not set
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_DT_IDLE_STATES=y
+
+#
+# ARM CPU Idle Drivers
+#
+# CONFIG_ARM_CPUIDLE is not set
+
+#
+# ARM64 CPU Idle Drivers
+#
+# CONFIG_ARM64_CPUIDLE is not set
+CONFIG_HISI_MULTIDRV_CPUIDLE=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SCHED is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_SCHED is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_CPUFREQ_DT=y
+# CONFIG_ARM_BIG_LITTLE_CPUFREQ is not set
+# CONFIG_ARM_HISI_ACPU_CPUFREQ is not set
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+CONFIG_HISI_CPUFREQ=y
+# CONFIG_ARCH_HISI_MAXFREQ is not set
+# CONFIG_HISI_ENABLE_GET_VAL is not set
+CONFIG_HISI_CPUFREQ_DT=y
+CONFIG_HISI_HW_VOTE_CPU_FREQ=y
+CONFIG_HISI_CPUDDR_FREQ_LINK=y
+CONFIG_CPU_FREQ_POWER_STAT=y
+CONFIG_NET=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+CONFIG_XFRM_STATISTICS=y
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_IP_MROUTE is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+CONFIG_INET_DIAG_DESTROY=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_BBR is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_TCP_AUTOTUNING=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+# CONFIG_IPV6_ILA is not set
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETLABEL is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NET_PTP_CLASSIFY is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_ACCT=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_LOG_COMMON=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+# CONFIG_NF_CONNTRACK_ZONES is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+# CONFIG_NETFILTER_NETLINK_GLUE_CT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_REDIRECT=y
+CONFIG_NETFILTER_SYNPROXY=y
+CONFIG_NF_TABLES=y
+# CONFIG_NF_TABLES_INET is not set
+# CONFIG_NF_TABLES_NETDEV is not set
+# CONFIG_NFT_EXTHDR is not set
+# CONFIG_NFT_META is not set
+# CONFIG_NFT_CT is not set
+# CONFIG_NFT_RBTREE is not set
+# CONFIG_NFT_HASH is not set
+# CONFIG_NFT_COUNTER is not set
+# CONFIG_NFT_LOG is not set
+# CONFIG_NFT_LIMIT is not set
+# CONFIG_NFT_MASQ is not set
+# CONFIG_NFT_REDIR is not set
+CONFIG_NFT_NAT=y
+# CONFIG_NFT_QUEUE is not set
+# CONFIG_NFT_REJECT is not set
+# CONFIG_NFT_COMPAT is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_NAT=y
+CONFIG_NETFILTER_XT_TARGET_NETMAP=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+CONFIG_NETFILTER_XT_TARGET_REDIRECT=y
+CONFIG_NETFILTER_XT_TARGET_TEE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+# CONFIG_NETFILTER_XT_MATCH_L2TP is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+# CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_NF_TABLES_IPV4 is not set
+# CONFIG_NF_TABLES_ARP is not set
+CONFIG_NF_DUP_IPV4=y
+# CONFIG_NF_LOG_ARP is not set
+CONFIG_NF_LOG_IPV4=y
+CONFIG_NF_REJECT_IPV4=y
+CONFIG_NF_NAT_IPV4=y
+CONFIG_NF_NAT_MASQUERADE_IPV4=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_SYNPROXY=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_NF_TABLES_IPV6=y
+CONFIG_NFT_CHAIN_ROUTE_IPV6=y
+# CONFIG_NFT_REJECT_IPV6 is not set
+# CONFIG_NFT_DUP_IPV6 is not set
+CONFIG_NF_DUP_IPV6=y
+CONFIG_NF_REJECT_IPV6=y
+CONFIG_NF_LOG_IPV6=y
+CONFIG_NF_NAT_IPV6=y
+CONFIG_NFT_CHAIN_NAT_IPV6=y
+CONFIG_NF_NAT_MASQUERADE_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_SYNPROXY=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP6_NF_SECURITY is not set
+CONFIG_IP6_NF_NAT=y
+CONFIG_IP6_NF_TARGET_MASQUERADE=y
+# CONFIG_IP6_NF_TARGET_NPT is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_CLS_BPF is not set
+# CONFIG_NET_CLS_FLOWER is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_VLAN is not set
+# CONFIG_NET_ACT_BPF is not set
+# CONFIG_NET_ACT_CONNMARK is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+# CONFIG_BT_BREDR is not set
+# CONFIG_BT_LE is not set
+# CONFIG_BT_SELFTEST is not set
+# CONFIG_BT_DEBUGFS is not set
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+# CONFIG_BT_HCIUART_H4 is not set
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIUART_3WIRE is not set
+# CONFIG_BT_HCIUART_INTEL is not set
+# CONFIG_BT_HCIUART_BCM is not set
+# CONFIG_BT_HCIUART_QCA is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_CRDA_SUPPORT=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+# CONFIG_MAC80211 is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+CONFIG_RFKILL_LEDS=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_LWTUNNEL=y
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_TEGRA_AHB is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+# CONFIG_DEVTMPFS_MOUNT is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_FENCE_TRACE is not set
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=32
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+
+#
+# Hisilicon Bootdevice
+#
+CONFIG_HISI_BOOTDEVICE=y
+
+#
+# Bus devices
+#
+CONFIG_ARM_CCI=y
+# CONFIG_ARM_CCI400_PMU is not set
+# CONFIG_ARM_CCI500_PMU is not set
+# CONFIG_ARM_CCN is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_BALONG_MTD is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_HISI_NVE=y
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_NAND_IDS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_SPI_NOR is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_ADDRESS_PCI=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_OF_MTD=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+CONFIG_ZRAM=y
+CONFIG_ZRAM_LZ4_COMPRESS=y
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_VIRTIO_BLK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+# CONFIG_BLK_DEV_NVME is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+CONFIG_UID_SYS_STATS=y
+# CONFIG_MEMORY_STATE_TIME is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+CONFIG_SCSI_HISI_MQ=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+CONFIG_SCSI_UFSHCD=y
+# CONFIG_SCSI_UFSHCD_PCI is not set
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+CONFIG_SCSI_UFS_KIRIN=y
+# CONFIG_SCSI_UFS_KIRIN_LINERESET_CHECK is not set
+# CONFIG_SCSI_UFS_TEST is not set
+CONFIG_SCSI_UFS_INLINE_CRYPTO=y
+CONFIG_SCSI_UFS_ENHANCED_INLINE_CRYPTO=y
+# CONFIG_SCSI_UFS_HS_ERROR_RECOVER is not set
+CONFIG_HUAWEI_UFS_DSM=y
+CONFIG_SCSI_UFS_HI1861_VCMD=y
+CONFIG_SCSI_UFS_KIRIN_V21=y
+# CONFIG_HISI_UFS_MANUAL_BKOPS is not set
+# CONFIG_HUAWEI_UFS_VENDOR_MODE is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_HAVE_PATA_PLATFORM=y
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_MQ_DEFAULT=y
+CONFIG_DM_DEBUG=y
+CONFIG_DM_BUFIO=y
+CONFIG_DM_BIO_PRISON=y
+CONFIG_DM_PERSISTENT_DATA=y
+# CONFIG_DM_DEBUG_BLOCK_STACK_TRACING is not set
+# CONFIG_DM_CRYPT is not set
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+CONFIG_DM_CACHE=y
+CONFIG_DM_CACHE_MQ=y
+CONFIG_DM_CACHE_SMQ=y
+CONFIG_DM_CACHE_CLEANER=y
+# CONFIG_DM_ERA is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+CONFIG_DM_VERITY=y
+CONFIG_DM_VERITY_FEC=y
+CONFIG_DM_VERITY_HW_RETRY=y
+# CONFIG_DM_SWITCH is not set
+# CONFIG_DM_LOG_WRITES is not set
+CONFIG_DM_HISI_SHA_USE_SOFT=y
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_VIRTIO_NET is not set
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_VHOST_NET is not set
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD_XGBE is not set
+CONFIG_NET_VENDOR_ARC=y
+# CONFIG_ARC_EMAC is not set
+# CONFIG_EMAC_ROCKCHIP is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+CONFIG_NET_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BCMGENET is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2X is not set
+# CONFIG_SYSTEMPORT is not set
+# CONFIG_BNXT is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+CONFIG_NET_VENDOR_CAVIUM=y
+# CONFIG_THUNDER_NIC_PF is not set
+# CONFIG_THUNDER_NIC_VF is not set
+# CONFIG_THUNDER_NIC_BGX is not set
+# CONFIG_LIQUIDIO is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+CONFIG_NET_VENDOR_EZCHIP=y
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+CONFIG_NET_VENDOR_HISILICON=y
+# CONFIG_HIX5HD2_GMAC is not set
+# CONFIG_HIP04_ETH is not set
+# CONFIG_HNS is not set
+# CONFIG_HNS_DSAF is not set
+# CONFIG_HNS_ENET is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+# CONFIG_FM10K is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_MLX5_CORE is not set
+# CONFIG_MLXSW_CORE is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_ENCX24J600 is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+# CONFIG_NATSEMI is not set
+# CONFIG_NS83820 is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+CONFIG_NET_VENDOR_QUALCOMM=y
+# CONFIG_QCA7000 is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+CONFIG_NET_VENDOR_RENESAS=y
+# CONFIG_NET_VENDOR_RDC is not set
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+# CONFIG_SXGBE_ETH is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_SMSC9420 is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_NET_VENDOR_SUN is not set
+CONFIG_NET_VENDOR_SYNOPSYS=y
+# CONFIG_SYNOPSYS_DWC_ETH_QOS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_OCTEON is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=m
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+CONFIG_USB_RTL8150=y
+CONFIG_USB_RTL8152=y
+# CONFIG_USB_LAN78XX is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=y
+CONFIG_USB_NET_AX88179_178A=y
+CONFIG_USB_NET_CDCETHER=y
+CONFIG_USB_NET_CDC_EEM=y
+CONFIG_USB_NET_CDC_NCM=y
+# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
+CONFIG_USB_NET_CDC_MBIM=y
+CONFIG_USB_NET_DM9601=y
+CONFIG_USB_NET_SR9700=y
+CONFIG_USB_NET_SR9800=y
+CONFIG_USB_NET_SMSC75XX=y
+CONFIG_USB_NET_SMSC95XX=y
+CONFIG_USB_NET_GL620A=y
+CONFIG_USB_NET_NET1080=y
+CONFIG_USB_NET_PLUSB=y
+CONFIG_USB_NET_MCS7830=y
+CONFIG_USB_NET_RNDIS_HOST=y
+CONFIG_USB_NET_CDC_SUBSET=y
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+# CONFIG_USB_BELKIN is not set
+# CONFIG_USB_ARMLINUX is not set
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=y
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_QMI_WWAN is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_NET_INT51X1 is not set
+CONFIG_USB_IPHETH=y
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+# CONFIG_USB_NET_CH9200 is not set
+CONFIG_WLAN=y
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_ATH_CARDS is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_HERMES is not set
+# CONFIG_WL_MEDIATEK is not set
+# CONFIG_WL_TI is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+# CONFIG_INPUT_KEYCOMBO is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_KEYBOARD_HISI_GPIO_KEY=y
+# CONFIG_HISI_GPIO_KEY_SUPPORT_SMART_KEY is not set
+CONFIG_VOLUME_KEY_MASK=y
+CONFIG_HISI_VOLUMEKEY_COMBINATION=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_FOCALTECH=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_HISI_POWERKEY is not set
+CONFIG_HISI_POWERKEY_SPMI=y
+# CONFIG_HISI_POWERKEY_DEBUG is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYCHORD is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_REGULATOR_HAPTIC is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+CONFIG_HISI_VIBRATOR=y
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_HISI_TTY=y
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+CONFIG_HISI_AMBA_PL011=y
+CONFIG_HISI_UART_OVERSAMPLING=y
+CONFIG_HISI_NEED_SG_DMA_LENGTH=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_VIRTIO_CONSOLE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DEVPORT is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CADENCE is not set
+# CONFIG_I2C_CBUS_GPIO is not set
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+CONFIG_HISI_I2C_DESIGNWARE=y
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+CONFIG_HISI_SPI=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+CONFIG_GENERIC_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+CONFIG_PINCTRL_SINGLE=y
+# CONFIG_PINCTRL_HI6402 is not set
+CONFIG_PINCTRL_SEC=y
+CONFIG_HISI_PINCRTL_INFO=y
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+CONFIG_GPIO_PL061=y
+# CONFIG_GPIO_HI6402 is not set
+# CONFIG_HISI_TUI_PL061 is not set
+# CONFIG_GPIO_PM_SUPPORT is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_VX855 is not set
+# CONFIG_GPIO_XGENE is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZX is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+
+#
+# MFD GPIO expanders
+#
+
+#
+# PCI GPIO expanders
+#
+# CONFIG_GPIO_AMD8111 is not set
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# SPI or I2C GPIO expanders
+#
+# CONFIG_GPIO_MCP23S08 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+# CONFIG_POWER_RESET_HISI is not set
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_XGENE is not set
+# CONFIG_POWER_RESET_SYSCON is not set
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
+CONFIG_POWER_HISI=y
+CONFIG_HISI_BATTERY_DATA=y
+CONFIG_HISI_BCI_BATTERY=y
+CONFIG_HISI_CHARGER=y
+# CONFIG_HISI_CHARGER_ARCH is not set
+CONFIG_BQ25892_CHARGER=y
+# CONFIG_SCHARGER_V200 is not set
+CONFIG_SCHARGER_V300=y
+CONFIG_HISI_CHARGER_SYS_WDG=y
+CONFIG_HISI_COUL=y
+# CONFIG_HISI_COUL_HI6421V500 is not set
+# CONFIG_HISI_COUL_HI6421V600 is not set
+CONFIG_HISI_COUL_HI6421V600_SPMI=y
+# CONFIG_HISI_COUL_HI6555V100 is not set
+CONFIG_HISI_COUL_TEST=y
+# CONFIG_POWER_AVS is not set
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+# CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE=y
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_GOV_STEP_WISE is not set
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+# CONFIG_CLOCK_THERMAL is not set
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+# CONFIG_HISI_THERMAL is not set
+# CONFIG_IMX_THERMAL is not set
+
+#
+# Hisilicon thermal drivers
+#
+CONFIG_HISI_IPA_THERMAL=y
+CONFIG_HISI_THERMAL_TSENSOR=y
+CONFIG_HISI_THERMAL_PERIPHERAL=y
+# CONFIG_HISI_THERMAL_CONTEXTHUB is not set
+CONFIG_HISI_THERMAL_SPM=y
+CONFIG_HISI_THERMAL_HOTPLUG=y
+# CONFIG_HISI_HOTPLUG_EMULATION is not set
+CONFIG_HISI_THERMAL_TRIP=y
+CONFIG_HISI_THERMAL_SHELL=y
+CONFIG_HISI_THERMAL_AMBIENT=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+CONFIG_HISI_SP805_WATCHDOG=y
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_MEN_A21_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_AXP20X is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_INTEL_SOC_PMIC is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_MFD_HISI_IP_CORE=y
+# CONFIG_HISI_IP_CORE is not set
+# CONFIG_HISI_IP_PMIC is not set
+CONFIG_HISI_FREQ_AUTODOWN=y
+# CONFIG_HISI_CHARGER_POWER is not set
+# CONFIG_HISI_PMIC is not set
+CONFIG_HISI_PMIC_PMU_SPMI=y
+# CONFIG_HISI_HI6555V200_PMU is not set
+CONFIG_HISI_HI6421V600_PMU=y
+# CONFIG_HISI_HI6421V500_PMU is not set
+# CONFIG_HISI_PMIC_MNTN is not set
+CONFIG_HISI_PMIC_MNTN_SPMI=y
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ANATOP is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_DRV_HISI_IP_REGULATOR=y
+# CONFIG_KIRIN980_IP_PLATFORM is not set
+CONFIG_KIRIN970_IP_PLATFORM=y
+# CONFIG_KIRIN660_IP_PLATFORM is not set
+# CONFIG_REGULATOR_HI6250 is not set
+# CONFIG_REGULATOR_IP_DEBUG is not set
+CONFIG_HISI_REGULATOR_DEBUG=y
+CONFIG_HISI_REGULATOR_SPMI=y
+# CONFIG_HISI_PMIC_DEBUG is not set
+CONFIG_HISI_REGULATOR_TRACE=y
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+# CONFIG_VIDEO_V4L2_SUBDEV_API is not set
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF2_CORE=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+# CONFIG_MEDIA_USB_SUPPORT is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+
+#
+# Huawei Multimedia
+#
+CONFIG_HUAWEI_CAMERA=y
+# CONFIG_ION_FOR_EMULATOR is not set
+CONFIG_USE_CAMERA3_ARCH=y
+
+#
+# Huawei Camera
+#
+
+#
+# HISI ISP
+#
+
+#
+# HISI ISP
+#
+CONFIG_HUAWEI_CAMERA_USE_HISP160=y
+
+#
+# Huawei Sensor
+#
+
+#
+# Hisilicon camera flash driver support
+#
+# CONFIG_HISI_CAMERA_TPS61310 is not set
+CONFIG_HISI_CAMERA_LM3642=y
+# CONFIG_HISI_CAMERA_LM3642_FRONT is not set
+CONFIG_HISI_CAMERA_MP3331=y
+# CONFIG_HISI_CAMERA_MP3331_FRONT is not set
+# CONFIG_HISI_CAMERA_LM3646_FRONT is not set
+CONFIG_HISI_CAMERA_LM3646=y
+CONFIG_HISI_CAMERA_MP3336=y
+# CONFIG_HISI_CAMERA_LM3646_MIX is not set
+# CONFIG_HISI_CAMERA_MP3336_MIX is not set
+# CONFIG_HISI_CAMERA_PMU_LED is not set
+# CONFIG_HISI_CAMERA_SCHARGER is not set
+
+#
+# st camera laser driver support
+#
+# CONFIG_HISI_CAMERA_VL53L0 is not set
+# CONFIG_HISI_CAMERA_VL53L0_ML is not set
+# CONFIG_HISI_CAMERA_VL53L0_KNT is not set
+# CONFIG_HISI_CAMERA_VL53L0_GAL is not set
+# CONFIG_HISI_CAMERA_VL53L0_CMB is not set
+# CONFIG_HISI_CAMERA_VL53L0_DUKE is not set
+# CONFIG_HISI_CAMERA_VL53L0_STF is not set
+CONFIG_HISI_CAMERA_VL53L0_970=y
+
+#
+# sharp camera laser driver support
+#
+# CONFIG_HISI_CAMERA_GP2AP0XVT_STF is not set
+
+#
+# FNFaceDetection
+#
+CONFIG_USE_FNFD=y
+CONFIG_HUAWEI_CAMERA_USE_OV8865=y
+CONFIG_HUAWEI_CAMERA_USE_IMX286HYBIRD=y
+CONFIG_HUAWEI_CAMERA_USE_IMX230=y
+CONFIG_HUAWEI_CAMERA_USE_IMX298=y
+CONFIG_HUAWEI_CAMERA_USE_IMX298HYBIRD=y
+CONFIG_HUAWEI_CAMERA_USE_IMX179=y
+CONFIG_HUAWEI_CAMERA_USE_IMX286DUAL=y
+CONFIG_HUAWEI_CAMERA_USE_IMX386HYBIRD=y
+# CONFIG_HUAWEI_CAMERA_USE_IMX219 is not set
+# CONFIG_HUAWEI_CAMERA_USE_HI843 is not set
+# CONFIG_HUAWEI_CAMERA_USE_OV2281 is not set
+CONFIG_HUAWEI_CAMERA_USE_IMX486HYBIRD=y
+CONFIG_HUAWEI_CAMERA_USE_IMX319=y
+# CONFIG_HUAWEI_CAMERA_USE_IMX318 is not set
+
+#
+# Huawei Sensor kirin970
+#
+
+#
+# Hisilicon camera flash driver support
+#
+CONFIG_HUAWEI_CAMERA_USE_OV13855=y
+CONFIG_HUAWEI_CAMERA_USE_HI1333=y
+CONFIG_HUAWEI_CAMERA_USE_IMX258=y
+CONFIG_HUAWEI_CAMERA_USE_OV16B10HYBIRD=y
+CONFIG_HUAWEI_CAMERA_USE_IMX498HYBIRD=y
+CONFIG_HISI_CAMERA_LASER=y
+CONFIG_HISI_CAMERA_FLASH=y
+# CONFIG_HISI_CAMERA_HISTAR_ISPV110 is not set
+# CONFIG_HISI_CAMERA_HISTAR_ISPV150 is not set
+CONFIG_HISI_CAMERA_HISTAR_ISPV160=y
+# CONFIG_HISI_CAMERA_HISTAR_ISPV120 is not set
+# CONFIG_HISI_CAMERA_HISTAR_ISPV200 is not set
+# CONFIG_HISI_CAMERA_ISP_SECURE is not set
+# CONFIG_CYPRESS_FIRMWARE is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Audio/Video compression chips
+#
+
+#
+# Miscellaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Hisilicon video venc support
+#
+CONFIG_HI_VCODEC_VENC=y
+
+#
+# Hisilicon video vdec support
+#
+CONFIG_HI_VCODEC_VDEC=y
+# CONFIG_IMAGINATION_D5500_VCODEC is not set
+# CONFIG_IMAGINATION_D5500_DRM_VCODEC is not set
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+# CONFIG_DRM is not set
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_FB_SM712 is not set
+# CONFIG_HISI_FB_FAKE is not set
+# CONFIG_HISI_FB_3650 is not set
+# CONFIG_HISI_FB_6250 is not set
+# CONFIG_HISI_FB_3660 is not set
+CONFIG_HISI_FB_970=y
+# CONFIG_HISI_FB_980 is not set
+# CONFIG_HISI_FB_660 is not set
+# CONFIG_HISI_FB_ENG_DBG is not set
+# CONFIG_FASTBOOT_DISP_ENABLE is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_ADF is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SE6X is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+
+#
+# HD-Audio
+#
+# CONFIG_SND_HDA_INTEL is not set
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+
+#
+# SoC Audio for Freescale CPUs
+#
+
+#
+# Common SoC Audio options for Freescale CPUs:
+#
+# CONFIG_SND_SOC_FSL_ASRC is not set
+# CONFIG_SND_SOC_FSL_SAI is not set
+# CONFIG_SND_SOC_FSL_SSI is not set
+# CONFIG_SND_SOC_FSL_SPDIF is not set
+# CONFIG_SND_SOC_FSL_ESAI is not set
+# CONFIG_SND_SOC_IMX_AUDMUX is not set
+
+#
+# SoC Audio support for HI3630
+#
+# CONFIG_SND_SOC_PCM_HI3630 is not set
+# CONFIG_SND_SOC_PCM_HI3650 is not set
+CONFIG_SND_SOC_PCM_HI3660=y
+# CONFIG_SND_HI3630_HI6401 is not set
+# CONFIG_SND_HI3630_HI6402 is not set
+# CONFIG_SND_HI6250_HI6402 is not set
+# CONFIG_SND_HI6250_HI6555C is not set
+# CONFIG_SND_HI3650_HI6402 is not set
+# CONFIG_SND_HI3650_HI6403 is not set
+CONFIG_SND_HI3660_HI6402=y
+CONFIG_SND_HI3660_HI6403=y
+# CONFIG_SND_SOC_PCM_HI6210 is not set
+# CONFIG_SND_HI6210_HISSC is not set
+CONFIG_SND_SOC_DP_AUDIO=y
+# CONFIG_SND_AUTO_TEST is not set
+
+#
+# Allwinner SoC Audio support
+#
+# CONFIG_SND_SUN4I_CODEC is not set
+# CONFIG_SND_SOC_XTFPGA_I2S is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+
+#
+# CODEC drivers
+#
+# CONFIG_SND_SOC_AC97_CODEC is not set
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4613 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_ALC5623 is not set
+# CONFIG_SND_SOC_CS35L32 is not set
+# CONFIG_SND_SOC_CS42L51_I2C is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L56 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS4265 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271_I2C is not set
+# CONFIG_SND_SOC_CS4271_SPI is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_CS4349 is not set
+# CONFIG_SND_SOC_ES8328 is not set
+# CONFIG_SND_SOC_GTM601 is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM1792A is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_RT5631 is not set
+# CONFIG_SND_SOC_RT5677_SPI is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_SSM2602_SPI is not set
+# CONFIG_SND_SOC_SSM2602_I2C is not set
+# CONFIG_SND_SOC_SSM4567 is not set
+# CONFIG_SND_SOC_STA32X is not set
+# CONFIG_SND_SOC_STA350 is not set
+# CONFIG_SND_SOC_STI_SAS is not set
+# CONFIG_SND_SOC_TAS2552 is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TAS571X is not set
+# CONFIG_SND_SOC_TFA9879 is not set
+# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC31XX is not set
+# CONFIG_SND_SOC_TLV320AIC3X is not set
+# CONFIG_SND_SOC_TS3A227E is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731 is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8804_I2C is not set
+# CONFIG_SND_SOC_WM8804_SPI is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_WM8978 is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+CONFIG_SND_SOC_HI6402=y
+CONFIG_SND_SOC_HI6403=y
+# CONFIG_SND_SOC_CODEC_HISSC is not set
+# CONFIG_SND_SOC_CODEC_HI6555C is not set
+# CONFIG_SND_SOC_CODEC_STUB is not set
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_APPLEIR=y
+CONFIG_HID_AUREAL=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BETOP_FF=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_CORSAIR is not set
+CONFIG_HID_PRODIKEYS=y
+CONFIG_HID_CP2112=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_ELO=y
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+CONFIG_HID_HOLTEK=y
+CONFIG_HOLTEK_FF=y
+CONFIG_HID_GT683R=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_ICADE=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LENOVO=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_HID_LOGITECH_HIDPP=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWHEELS_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PENMOUNT=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_PICOLCD_FB=y
+CONFIG_HID_PICOLCD_LEDS=y
+CONFIG_HID_PLANTRONICS=y
+CONFIG_HID_PRIMAX=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_SAITEK=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_SONY_FF=y
+CONFIG_HID_SPEEDLINK=y
+CONFIG_HID_STEELSERIES=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_RMI=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THINGM=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_WIIMOTE=y
+CONFIG_HID_XINMO=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_HID_SENSOR_HUB=y
+CONFIG_HID_SENSOR_CUSTOM_SENSOR=y
+CONFIG_HID_VR=y
+CONFIG_HID_HUAWEI=y
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+CONFIG_HISI_USB_SKIP_RESUME=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_OTG_FSM=y
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_XHCI_PLATFORM=y
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_WDM=y
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_HOST is not set
+# CONFIG_USB_DWC3_GADGET is not set
+CONFIG_USB_DWC3_DUAL_ROLE=y
+
+#
+# Platform Glue Driver Support
+#
+CONFIG_USB_DWC3_PCI=y
+CONFIG_USB_DWC3_HISI=y
+# CONFIG_USB_DWC3_KIRIN660 is not set
+# CONFIG_USB_DWC3_KIRIN980 is not set
+CONFIG_USB_DWC3_KIRIN970=y
+# CONFIG_USB_DWC3_KIRIN960 is not set
+# CONFIG_USB_DWC3_KIRIN950 is not set
+CONFIG_USB_DWC3_VBUS_SPMI=y
+CONFIG_USB_DWC3_NYET_ABNORMAL=y
+# CONFIG_HISI_USB_DWC3_MASK_IRQ_WORKAROUND is not set
+
+#
+# Debugging features
+#
+CONFIG_USB_DWC3_OTG=y
+# CONFIG_USB_DWC2 is not set
+CONFIG_USB_PROXY_HCD=y
+# CONFIG_USB_PROXY_HCD_DEBUG is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+# CONFIG_USB_SUSB_HDRC is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_SIMPLE is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MXUPORT is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+CONFIG_USB_DFU=y
+
+#
+# USB Physical Layer drivers
+#
+CONFIG_USB_PHY=y
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ULPI is not set
+CONFIG_DUAL_ROLE_USB_INTF=y
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_HISI_USB_FUNC_ADD_SS_DESC=y
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_F_ACM=y
+CONFIG_USB_U_SERIAL=y
+CONFIG_USB_U_ETHER=y
+CONFIG_USB_F_NCM=y
+CONFIG_USB_F_RNDIS=y
+CONFIG_USB_F_MASS_STORAGE=y
+CONFIG_USB_F_FS=y
+CONFIG_USB_F_MIDI=y
+CONFIG_USB_F_MTP=y
+CONFIG_USB_F_PTP=y
+CONFIG_USB_F_AUDIO_SRC=y
+CONFIG_USB_F_ACC=y
+CONFIG_USB_HW_F_ACM=y
+CONFIG_USB_MASS_STORAGE_SUPPORT_MAC=y
+CONFIG_USB_CONFIGFS=y
+# CONFIG_USB_CONFIGFS_SERIAL is not set
+CONFIG_USB_CONFIGFS_ACM=y
+# CONFIG_USB_CONFIGFS_OBEX is not set
+CONFIG_USB_CONFIGFS_NCM=y
+# CONFIG_USB_CONFIGFS_ECM is not set
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+CONFIG_USB_CONFIGFS_RNDIS=y
+# CONFIG_USB_CONFIGFS_EEM is not set
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_MTP=y
+CONFIG_USB_CONFIGFS_F_PTP=y
+CONFIG_USB_CONFIGFS_F_ACC=y
+CONFIG_USB_CONFIGFS_F_AUDIO_SRC=y
+CONFIG_USB_CONFIGFS_UEVENT=y
+# CONFIG_USB_CONFIGFS_F_UAC1 is not set
+# CONFIG_USB_CONFIGFS_F_UAC2 is not set
+CONFIG_USB_CONFIGFS_F_MIDI=y
+# CONFIG_USB_CONFIGFS_F_HID is not set
+# CONFIG_USB_CONFIGFS_F_UVC is not set
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+# CONFIG_USB_CONFIGFS_BALONG_ACM is not set
+CONFIG_USB_CONFIGFS_HW_ACM=y
+CONFIG_HISI_USB_CONFIGFS=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_USB_LED_TRIG is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+CONFIG_HISI_MMC=y
+CONFIG_SD_SDIO_CRC_RETUNING=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_HISI_MMC_SECURE_RPMB=y
+CONFIG_HISI_RPMB_TIME_DEBUG=y
+CONFIG_HISI_MMC_FLUSH_REDUCE=y
+# CONFIG_HISI_MMC_FLUSH_REDUCE_WHITE_LIST is not set
+# CONFIG_HISI_MMC_MANUAL_BKOPS is not set
+CONFIG_HUAWEI_SDCARD_DSM=y
+# CONFIG_HUAWEI_EMMC_DSM is not set
+# CONFIG_HUAWEI_EMMC_DSM_ONLY_VDET is not set
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+CONFIG_MMC_PASSWORDS=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=96
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_SIMULATE_MAX_SPEED is not set
+CONFIG_MMC_FFU=y
+# CONFIG_MMC_FFU_SAMSUNG45 is not set
+CONFIG_HW_SD_HEALTH_DETECT=y
+# CONFIG_HW_MMC_TEST is not set
+CONFIG_HW_SYSTEM_HW_WR_PROTECT=y
+# CONFIG_SD_SCHEDULER_CFQ_ONLY is not set
+# CONFIG_HW_MMC_MAINTENANCE_CMD is not set
+# CONFIG_HW_MMC_MAINTENANCE_DATA is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+# CONFIG_MMC_SDHCI_OF_AT91 is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_TIFM_SD is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_IDMAC=y
+CONFIG_MMC_DW_PLTFM=y
+# CONFIG_MMC_DW_EXYNOS is not set
+CONFIG_MMC_DW_HISILICON=y
+CONFIG_MMC_DW_HI3XXX=y
+# CONFIG_MMC_DW_EMMC_USED_AS_MODEM is not set
+# CONFIG_MMC_DW_SD_CLK_SLOWDOWN is not set
+# CONFIG_MMC_DW_PCI is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_CQ_HCI is not set
+# CONFIG_MMC_HISI_TRACE is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_SDHCI_DWC_MSHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+CONFIG_LEDS_SYSCON=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+CONFIG_HISI_LEDS_HWTIMER=y
+CONFIG_HISI_LEDS_NODE_PERSIST=y
+# CONFIG_LEDS_HISI is not set
+CONFIG_LEDS_HISI_SPMI=y
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12057 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_RTC_DRV_HISI_PMIC_SPMI=y
+CONFIG_HISI_RTC_LOG=y
+CONFIG_HISI_RTC_SECURE_FEATURE=y
+# CONFIG_HISI_RTC_TEST is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DMA_OF=y
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_PL330_DMA is not set
+CONFIG_HISI_DMA=y
+CONFIG_HISI_DMA_NO_CCI=y
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO=y
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_INPUT is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_PRISM2_USB is not set
+# CONFIG_COMEDI is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+# CONFIG_R8188EU is not set
+# CONFIG_R8723AU is not set
+# CONFIG_RTS5208 is not set
+# CONFIG_FB_SM750 is not set
+# CONFIG_FB_XGI is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_TIMED_OUTPUT=y
+# CONFIG_ANDROID_TIMED_GPIO is not set
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
+CONFIG_ANDROID_INTF_ALARM_DEV=y
+CONFIG_SYNC=y
+CONFIG_SW_SYNC=y
+CONFIG_SW_SYNC_USER=y
+CONFIG_HISI_SMART_RECLAIM=y
+CONFIG_HUAWEI_RCC=y
+CONFIG_ION=y
+# CONFIG_ION_TEST is not set
+# CONFIG_ION_DUMMY is not set
+CONFIG_ION_HISI=y
+# CONFIG_ION_HISI_CPUDRAW is not set
+# CONFIG_ION_HISI_SECCM is not set
+CONFIG_ION_HISI_SECSG=y
+# CONFIG_HISI_ION_SECSG_DEBUG is not set
+CONFIG_ION_HISI_DMA_POOL=y
+# CONFIG_ION_HISI_FAMA_MISC is not set
+CONFIG_ION_HISI_SUPPORT_4GPLUS=y
+CONFIG_HISI_SMARTPOOL_OPT=y
+CONFIG_HISI_SPECIAL_SCENE_POOL=y
+# CONFIG_FIQ_DEBUGGER is not set
+# CONFIG_FIQ_WATCHDOG is not set
+CONFIG_HW_LOGGER=y
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_LTE_GDM724X is not set
+# CONFIG_LUSTRE_FS is not set
+# CONFIG_DGNC is not set
+# CONFIG_DGAP is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_FB_TFT is not set
+# CONFIG_FSL_MC_BUS is not set
+# CONFIG_WILC1000_DRIVER is not set
+# CONFIG_MOST is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+# CONFIG_HISI_CLK_DEBUG is not set
+# CONFIG_HISI_CLK_TRACE is not set
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_VERSATILE is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_CLK_QORIQ is not set
+CONFIG_COMMON_CLK_XGENE=y
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_HI6220 is not set
+# CONFIG_HI3xxx_CLK_CORE is not set
+# CONFIG_HI3620_CLK_MIPI_DSI is not set
+CONFIG_HISI_CLK=y
+# CONFIG_HISI_CLK_ALWAYS_ON is not set
+# CONFIG_HISI_CLK_PM_MONITOR is not set
+# CONFIG_HISI_CLK_HI3660 is not set
+CONFIG_HISI_CLK_KIRIN=y
+# CONFIG_HISI_HI6250_CLK is not set
+CONFIG_HISI_CLK_MAILBOX_SUPPORT=y
+CONFIG_HISI_PERIDVFS=y
+CONFIG_HISI_PERI_FAST_AVS=y
+CONFIG_HWSPINLOCK=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_HISI_HWSPINLOCK=y
+CONFIG_HISI_HWSPINLOCK_DEBUG=y
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_TIMER_SP804=y
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+# CONFIG_IOMMU_IO_PGTABLE_LPAE is not set
+CONFIG_IOMMU_IOVA=y
+CONFIG_OF_IOMMU=y
+CONFIG_IOMMU_DMA=y
+CONFIG_HISI_IODOMAIN_API=y
+CONFIG_HISI_IOMMU=y
+CONFIG_HISI_IOMMU_LPAE=y
+# CONFIG_HISI_IOMMU_COMPACT is not set
+# CONFIG_HISI_IOMMU_TEST is not set
+# CONFIG_ARM_SMMU is not set
+# CONFIG_ARM_SMMU_V3 is not set
+
+#
+# Remoteproc drivers
+#
+CONFIG_REMOTEPROC=y
+CONFIG_HISI_REMOTEPROC=y
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+CONFIG_RPMSG=y
+CONFIG_HISI_HISTAR_ISP=y
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+# CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND is not set
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+CONFIG_HISI_DEVFREQ=y
+CONFIG_HISI_DDR_DEVFREQ=y
+CONFIG_DEVFREQ_GOV_PM_QOS=y
+# CONFIG_DEVFREQ_GOV_MALI_ONDEMAND is not set
+CONFIG_DEVFREQ_GOV_GPU_SCENE_AWARE=y
+# CONFIG_HISI_DDR_CHINTLV is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_V2M=y
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+CONFIG_GPU_GMC_GENERIC=y
+# CONFIG_MALI_PLATFORM_HI3650 is not set
+# CONFIG_MALI_PLATFORM_HI6250 is not set
+# CONFIG_MALI_PLATFORM_HI3660 is not set
+CONFIG_MALI_PLATFORM_KIRIN970=y
+# CONFIG_MALI_PLATFORM_KIRIN660 is not set
+# CONFIG_MALI_PLATFORM_KIRIN980 is not set
+
+#
+# ARM GPU Configuration
+#
+CONFIG_MALI_MIDGARD=y
+# CONFIG_MALI_GATOR_SUPPORT is not set
+CONFIG_MALI_MIDGARD_DVFS=y
+CONFIG_MALI_MIDGARD_RT_PM=y
+# CONFIG_MALI_MIDGARD_ENABLE_TRACE is not set
+# CONFIG_MALI_DEVFREQ is not set
+# CONFIG_MALI_DMA_FENCE is not set
+CONFIG_MALI_EXPERT=y
+# CONFIG_MALI_PRFCNT_SET_SECONDARY is not set
+CONFIG_MALI_PLATFORM_FAKE=y
+CONFIG_MALI_PLATFORM_HISILICON=y
+# CONFIG_MALI_DEBUG is not set
+# CONFIG_MALI_NO_MALI is not set
+# CONFIG_MALI_TRACE_TIMELINE is not set
+# CONFIG_MALI_SYSTEM_TRACE is not set
+CONFIG_MALI_PM_DEMAND=y
+CONFIG_REPORT_VSYNC=y
+CONFIG_MALI_IDLE_AUTO_CLK_DIV=y
+# CONFIG_MALI_MIDGARD_DEBUG_SYS is not set
+# CONFIG_MALI_CORESTACK is not set
+# CONFIG_MALI_FENCE_DEBUG is not set
+# CONFIG_MALI_2MB_ALLOC is not set
+# CONFIG_MALI_PWRSOFT_765 is not set
+# CONFIG_MALI_GPU_DRM_HI3660 is not set
+CONFIG_HISI_HW_VOTE_GPU_FREQ=y
+# CONFIG_MALI_BOUND_REPORT is not set
+# CONFIG_HISI_GPU_CORESWITCH is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+CONFIG_PHY_XGENE=y
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+CONFIG_RAS=y
+# CONFIG_THUNDERBOLT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_BINDER_DEVICES="binder,hwbinder,vndbinder"
+CONFIG_HW_BINDER_FG_REQ_FIRST=y
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Hisilicon platform
+#
+CONFIG_HISILICON_PLATFORM=y
+CONFIG_HISI_HKADC=y
+# CONFIG_HISI_HKADC_DEBUG is not set
+CONFIG_HISI_CCI_EXTRA=y
+# CONFIG_HISI_CCI_EXTRA_PMU is not set
+CONFIG_HISI_CMDLINE_PARSE=y
+# CONFIG_HISI_IRQ_AFFINITY is not set
+CONFIG_HISILICON_PLATFORM_MAILBOX=y
+
+#
+# hisi ipc MailBox driver
+#
+CONFIG_HISI_MAILBOX=y
+
+#
+# hisi ipc mailboxes debugfs user
+#
+# CONFIG_HISI_MAILBOX_DEBUGFS is not set
+
+#
+# hisi ipc MailBox driver performance debug
+#
+# CONFIG_HISI_MAILBOX_PERFORMANCE_DEBUG is not set
+
+#
+# hisi kernel API about remote processor communication
+#
+CONFIG_HISI_RPROC=y
+
+#
+# hisi rproc kernel API debugfs
+#
+# CONFIG_HISI_RPROC_TESTFILE is not set
+
+#
+# bsp_reset_core_notify to support modem compile
+#
+# CONFIG_BSP_RESET_CORE_NOTIFY is not set
+CONFIG_HISILICON_PLATFORM_MAINTAIN=y
+# CONFIG_HISILICON_PLATFORM_HISI_EASYSHELL is not set
+
+#
+# RDR - Running data recorder menu
+#
+CONFIG_HISI_BB=y
+CONFIG_HISI_BB_DEBUG=y
+CONFIG_HISI_LPMCU_BB=y
+CONFIG_HISI_HIFI_BB=y
+CONFIG_HISI_ISP_RDR=y
+# CONFIG_HISI_MEM_TRACE is not set
+CONFIG_HISI_DFX_CORE=y
+# CONFIG_HISI_IRQ_REGISTER is not set
+CONFIG_HISI_REENTRANT_EXCEPTION=y
+# CONFIG_HISI_TIME_HOOK is not set
+
+#
+# MDDRC - For kernel code protection
+#
+# CONFIG_HISI_DDRC_KERNEL_CODE_PROTECTION is not set
+CONFIG_HISI_HISEE_MNTN=y
+# CONFIG_HISI_HISEE_MNTN_TEST is not set
+# CONFIG_HISI_HISEE_NVMFORMAT_TEST is not set
+CONFIG_HISI_MNTN_CHECKMISC=y
+CONFIG_HISI_BL31_MNTN=y
+# CONFIG_HISI_PIMON_MNTN is not set
+# CONFIG_HISI_VIRT_TO_PHYS is not set
+CONFIG_HISI_BOOT_TIME=y
+# CONFIG_HISI_BB_SYSCALL is not set
+CONFIG_HISI_POWER_OFF=y
+CONFIG_HISI_FIQ=y
+CONFIG_HISI_MNTNDUMP=y
+# CONFIG_HISI_DEBUG_FS is not set
+CONFIG_HISI_NOC=y
+CONFIG_HISI_SYSCOUNTER=y
+CONFIG_SOUND_TRIGGER=y
+# CONFIG_HISILICON_PLATFORM_TELE_MNTN is not set
+CONFIG_HISILICON_PLATFORM_KERNELDUMP=y
+CONFIG_HISI_KERNELDUMP=y
+# CONFIG_KERNELDUMP_KO_DBG is not set
+# CONFIG_HISI_WATCHPOINT_CB is not set
+# CONFIG_HISI_PERF_STAT is not set
+# CONFIG_HISI_PERF_STAT64 is not set
+
+#
+# set hmp thresholds policy
+#
+CONFIG_DRMDRIVER=y
+CONFIG_HI3XXX_EFUSE=y
+CONFIG_HI6402_CODEC=y
+CONFIG_HI6403_CODEC=y
+CONFIG_HI6402_MBHC_ANC=y
+# CONFIG_HAC_SUPPORT is not set
+CONFIG_HI6402_HIFI_MISC=y
+
+#
+# hisilicon slimbus driver
+#
+CONFIG_HISILICON_PLATFORM_SLIMBUS=y
+
+#
+# Hifimisc driver serve HIFI dsp
+#
+CONFIG_HIFI_DSP_ONE_TRACK=y
+
+#
+# voice proxy driver
+#
+CONFIG_VOICE_PROXY=y
+CONFIG_VOICE_PROXY_VOLTE=y
+CONFIG_VOICE_PROXY_VOWIFI=y
+
+#
+# Hifi mailbox driver
+#
+CONFIG_HIFI_MAILBOX=y
+
+#
+# Hifi mailbox driver
+#
+CONFIG_HIFI_IPC=y
+# CONFIG_HIFI_IPC_3650 is not set
+CONFIG_HIFI_IPC_3660=y
+# CONFIG_HIFI_IPC_6250 is not set
+CONFIG_HISILICON_PLATFORM_DDRC=y
+# CONFIG_HI3650_DDRC_FLUX is not set
+# CONFIG_HI6250_DDRC_FLUX is not set
+# CONFIG_HISI_DDRC_FLUX is not set
+CONFIG_HISI_DDRC_SEC=y
+# CONFIG_HI3660_DDR_AUTO_FSGT is not set
+# CONFIG_KIRIN970_DDR_AUTO_FSGT is not set
+# CONFIG_KIRIN660_DDR_AUTO_FSGT is not set
+CONFIG_HISI_CMA=y
+
+#
+# TEE OS
+#
+CONFIG_SECURE_EXTENSION=y
+CONFIG_TZDRIVER=y
+CONFIG_TEELOG=y
+CONFIG_TEE_TUI=y
+# CONFIG_TEE_TUI_HI3650 is not set
+CONFIG_TEE_TUI_KIRIN970=y
+# CONFIG_HISI_SPI_SMC is not set
+# CONFIG_HISI_SPI1_SMC is not set
+CONFIG_SECS_POWER_CTRL=y
+CONFIG_TEE_CFC=y
+CONFIG_TEE_CFC_ABI=y
+CONFIG_TZDRIVER_CODE_ALIGN_SHIFT=19
+CONFIG_TEE_ANTIROOT_CLIENT=y
+# CONFIG_HUAWEI_ROOT_SCAN_DUMMY_API is not set
+CONFIG_TEE_LIBHWSECUREC=y
+CONFIG_HISI_HISEE=y
+CONFIG_LOAD_IMAGE=y
+# CONFIG_MODEMID_HI3650 is not set
+CONFIG_HISI_PERFHUB=y
+CONFIG_HISI_JPU_970=y
+
+#
+# Freqdump FEATURE
+#
+CONFIG_HISI_FREQDUMP_PLATFORM=y
+CONFIG_HISI_DPM_PLATFORM_KIRIN970=y
+# CONFIG_HISI_DPM_PLATFORM_HI3660 is not set
+# CONFIG_HISI_DPM_PLATFORM_HI6250 is not set
+
+#
+# Hisi S/R options
+#
+CONFIG_HISI_SR=y
+CONFIG_HISI_SR_DEBUG=y
+CONFIG_HISI_SR_DEBUG_SLEEP=y
+CONFIG_HISI_SR_SYNC=y
+CONFIG_PM_SEC_GPIO=y
+CONFIG_HISI_SR_TICK=y
+# CONFIG_PM_FCM is not set
+
+#
+# Hisi OCBC options
+#
+# CONFIG_HISI_OCBC is not set
+
+#
+# Hisi Modem
+#
+# CONFIG_HISI_BALONG_MODEM is not set
+# CONFIG_HISI_BALONG_MODEM_HI3650 is not set
+# CONFIG_BALONG_OAM_PS is not set
+# CONFIG_VOWIFI_NEW_FRW is not set
+
+#
+# Modem Drivers
+#
+
+#
+# ipc driver
+#
+# CONFIG_IPC_DRIVER is not set
+# CONFIG_IPC_TEST is not set
+
+#
+# multicore communication driver
+#
+# CONFIG_CA_ICC is not set
+
+#
+# linux kernel call secure func
+#
+# CONFIG_SEC_CALL is not set
+
+#
+# timer driver
+#
+# CONFIG_PRINTK_USE_HARDTIMER is not set
+# CONFIG_HARD_TIMER is not set
+# CONFIG_HARD_TIMER_TEST is not set
+# CONFIG_TIMER_ADP is not set
+# CONFIG_SOFT_TIMER is not set
+# CONFIG_SOFT_TIMER_TEST is not set
+# CONFIG_BBP_TIMER is not set
+
+#
+# balong modem reset
+#
+# CONFIG_BALONG_MODEM_RESET is not set
+# CONFIG_BALONG_MODEM_RESET_TEST is not set
+# CONFIG_BALONG_MODEM_POWER_MANAGE is not set
+
+#
+# acore image load driver
+#
+# CONFIG_RFILE_SUPPORT is not set
+# CONFIG_RFILE_TEST is not set
+# CONFIG_RFILE_MEM_OPTIMISE is not set
+
+#
+# nv driver
+#
+# CONFIG_NVIM is not set
+# CONFIG_NVIM_TEST is not set
+
+#
+# shared memory
+#
+# CONFIG_S_MEMORY_TEST is not set
+
+#
+# get ip base addr
+#
+# CONFIG_HW_IP_BASE_ADDR is not set
+
+#
+# balong onoff management
+#
+# CONFIG_BALONG_ONOFF is not set
+# CONFIG_BALONG_MODEM_ONOFF is not set
+# CONFIG_EFUSE_BALONG is not set
+# CONFIG_EFUSE_BALONG_AGENT is not set
+
+#
+# ccore image load driver
+#
+# CONFIG_IMAGE_LOAD is not set
+
+#
+# udi adaption layer
+#
+# CONFIG_UDI_SUPPORT is not set
+
+#
+# sysctrl
+#
+# CONFIG_SYSCTRL_TEST is not set
+
+#
+# mem driver
+#
+# CONFIG_MEM_BALONG is not set
+
+#
+# sync
+#
+# CONFIG_SYNC_BALONG is not set
+
+#
+# misc driver
+#
+# CONFIG_IPF_SUPPORT is not set
+# CONFIG_PSAM_SUPPORT is not set
+# CONFIG_HISI_DUMP is not set
+# CONFIG_BALONG_EASY_SHELL is not set
+# CONFIG_PM_OM_BALONG is not set
+# CONFIG_PMIC_OCP is not set
+# CONFIG_HISI_SIM_HOTPLUG is not set
+CONFIG_HISI_SIM_HOTPLUG_SPMI=y
+
+#
+# ccore image load driver
+#
+# CONFIG_BBP_ACORE is not set
+# CONFIG_HISI_AXI is not set
+
+#
+# Hisilicon IVP
+#
+CONFIG_HISI_IVP=y
+CONFIG_IVP_SMMU=y
+# CONFIG_IVP_SMMU_TEST is not set
+CONFIG_IVP_KIRIN970=y
+# CONFIG_IVP_HI3660 is not set
+# CONFIG_IVP_HI3650 is not set
+# CONFIG_IVP_KIRIN660 is not set
+# CONFIG_HISI_PAGE_TRACKER is not set
+# CONFIG_HISI_PAGE_EXT is not set
+
+#
+# Hisi lpm3_debug options
+#
+# CONFIG_HISI_LPM3_DEBUG is not set
+CONFIG_HISI_HILOG=y
+CONFIG_HISI_ARMV8_DEPRECATED=y
+CONFIG_HISI_TIMEKEEPER=y
+CONFIG_TLB_CONFLICT_WORKAROUND=y
+
+#
+# Hisi lowmem killer
+#
+CONFIG_HISI_LOWMEM=y
+CONFIG_HISI_LOWMEM_DBG=y
+# CONFIG_HISI_MULTI_KILL is not set
+# CONFIG_HISI_GETSPINLOCK_TEST is not set
+CONFIG_HISI_HHEE=y
+CONFIG_HISI_ICS_IPU_PLATFORM=y
+CONFIG_HISI_ICS_IPU=y
+# CONFIG_HISI_HHEE_DEBUG is not set
+# CONFIG_GATOR is not set
+# CONFIG_HISI_PMU_DUMP is not set
+CONFIG_HISI_DIEID=y
+
+#
+# Huawei Platform Drivers
+#
+CONFIG_HUAWEI_PLATFORM=y
+CONFIG_HW_ANTENNA_BOARD_MATCH=y
+CONFIG_HW_ANTENNA_BOARD_ADC_MATCH=y
+
+#
+# Audio configuration
+#
+CONFIG_HUAWEI_AUDIO=y
+CONFIG_MAX98925=y
+CONFIG_MAXIM=y
+CONFIG_TFA9895=y
+CONFIG_SND_SOC_TAS2560=y
+CONFIG_TAS2560_I2C=y
+CONFIG_TAS2560_MISC=y
+CONFIG_TFA9872=y
+CONFIG_TFA98XX=y
+CONFIG_INVERT_HS=y
+CONFIG_ANC_HS_MODULE=y
+CONFIG_ANC_HS_INTERFACE=y
+CONFIG_ANC_HS=y
+CONFIG_ANC_MAX14744=y
+CONFIG_ANC_DEFAULT=y
+CONFIG_ANC_NCX8293=y
+# CONFIG_AK4376 is not set
+CONFIG_AK4376_KERNEL_4_1=y
+CONFIG_HIFI_VIR_DAI=y
+CONFIG_USB_ANALOG_HS_MODULE=y
+CONFIG_USB_ANALOG_HS_INTERFACE=y
+CONFIG_USB_ANALOG_HS_ISL54405=y
+CONFIG_USB_ANALOG_HS_FSA4476=y
+CONFIG_USB_AUDIO_POWER=y
+CONFIG_CHR_NETLINK_MODULE=y
+CONFIG_RIL_NETLINK_MODULE=y
+CONFIG_BCMCONNECTIVITY=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_POWER=m
+CONFIG_BT_SLEEP=m
+CONFIG_BCMGPS=y
+CONFIG_BCMGPS4752=y
+CONFIG_BCMGPS47531=y
+CONFIG_BCMGPS4774=y
+CONFIG_BCMGPS4774LHD=y
+
+#
+# huawei wifi linux driver
+#
+
+#
+# huawei wifi linux driver
+#
+CONFIG_BCMDHD=y
+# CONFIG_BCM4330 is not set
+# CONFIG_BCM4334 is not set
+# CONFIG_BCM4335 is not set
+# CONFIG_BCM4339 is not set
+# CONFIG_BCM4354 is not set
+# CONFIG_BCM4343 is not set
+# CONFIG_BCM4356 is not set
+# CONFIG_BCM4358 is not set
+# CONFIG_DHD_USE_STATIC_BUF is not set
+CONFIG_DHD_USE_SCHED_SCAN=y
+CONFIG_DHD_SET_RANDOM_MAC_VAL=0x001A11
+# CONFIG_DHD_OF_SUPPORT is not set
+# CONFIG_BCM_VIO is not set
+# CONFIG_HW_WIFI_FREQ_CTRL_FLAG is not set
+CONFIG_HW_VOWIFI=y
+CONFIG_HW_WLANFTY_STATUS=y
+CONFIG_HW_ABS=y
+CONFIG_DHD_STATIC_KO=y
+CONFIG_HW_GET_EXT_SIG=y
+CONFIG_HWCONNECTIVITY=y
+CONFIG_HWGPS=y
+CONFIG_HUAWEI_HW_DEV_DCT=y
+CONFIG_HUAWEI_DEV_SELFCHECK=y
+CONFIG_HUAWEI_IO_TRACING=y
+# CONFIG_VIACBP82D_3RD_MODEM is not set
+# CONFIG_INPUTHUB is not set
+CONFIG_INPUTHUB_20=y
+# CONFIG_CYPRESS_PSOC4000 is not set
+# CONFIG_CONTEXTHUB_IDLE_32K is not set
+CONFIG_MAXQ616_POWER_SWITCH=y
+# CONFIG_HUAWEI_LCD_PANEL is not set
+# CONFIG_HUAWEI_GOLDENEYE is not set
+# CONFIG_HUAWEI_BOOT_LOG is not set
+
+#
+# Logger extend configuration
+#
+CONFIG_LOGGER_EXTEND=y
+CONFIG_LOG_SWITCH=y
+CONFIG_LOG_EXCEPTION=y
+CONFIG_LOG_JANK=y
+CONFIG_HWLOG_KERNEL=y
+# CONFIG_HW_STAT_MM is not set
+CONFIG_HW_CROSSLAYER_OPT=y
+# CONFIG_HW_CROSSLAYER_OPT_DBG is not set
+CONFIG_HW_WIFI=y
+CONFIG_HUAWEI_MSS_AUTO_CHANGE=y
+CONFIG_HW_NETFILTER_MODULE=y
+# CONFIG_HW_COMMSTAT is not set
+CONFIG_HW_QTAGUID_PID=y
+CONFIG_HW_DPIMARK_MODULE=y
+
+#
+# NFC (Near Field Communication)
+#
+CONFIG_NFC_DEVICES=y
+CONFIG_PN547_NFC_64=m
+# CONFIG_BCM20793_NFC is not set
+# CONFIG_DUAL_LOADSWITCH_FAN54151 is not set
+# CONFIG_DUAL_LOADSWITCH_RT9748 is not set
+# CONFIG_DUAL_LOADSWITCH is not set
+# CONFIG_FAN54151 is not set
+CONFIG_RT9748=y
+CONFIG_LOADSWITCH=y
+# CONFIG_INA231_FOR_CHARGE is not set
+CONFIG_HUAWEI_CHARGER_AP=y
+# CONFIG_BQ2419X_CHARGER is not set
+# CONFIG_BQ2429X_CHARGER is not set
+# CONFIG_DUAL_CHARGER is not set
+CONFIG_DIRECT_CHARGER=y
+CONFIG_HUAWEI_CHARGER=y
+# CONFIG_HUAWEI_COUL is not set
+# CONFIG_BQ28Z610_COUL is not set
+CONFIG_HUAWEI_KSTATE=y
+# CONFIG_HW_PTM is not set
+# CONFIG_HW_PTM_K3V5 is not set
+# CONFIG_HW_PTM_K3V6 is not set
+# CONFIG_HW_PTM_K3V7 is not set
+# CONFIG_INPUT_HW_ATE is not set
+
+#
+# Huawei Bastet Support
+#
+CONFIG_HUAWEI_BASTET=y
+CONFIG_HUAWEI_WIFI_WEIXIN_HONGBAO_ENABLE_PRIORITY=y
+CONFIG_HUAWEI_SMPL=y
+CONFIG_HUAWEI_USB_SHORT_CIRCUIT_PROTECT=y
+# CONFIG_HUAWEI_CPU_BUCK is not set
+# CONFIG_HUAWEI_LP8758 is not set
+# CONFIG_HI6422V100 is not set
+# CONFIG_HI6422V200 is not set
+# CONFIG_HUAWEI_WATER_CHECK is not set
+# CONFIG_BUCKBOOST is not set
+# CONFIG_HUAWEI_FEATURE_PRINT_PID_NAME is not set
+CONFIG_DOZE_FILTER=y
+
+#
+# Huawei Device Usage Big-data Analytics Initiative Support
+#
+CONFIG_HUAWEI_DUBAI=y
+CONFIG_HUAWEI_SENSORS_INPUT_INFO=y
+CONFIG_HUAWEI_HALL_INPUTHUB=y
+# CONFIG_HW_TOUCH_KEY is not set
+CONFIG_DDR_INFO=y
+CONFIG_PROC_APP_INFO=y
+# CONFIG_PROC_POSTFSDATA is not set
+# CONFIG_PROC_IO_INFO is not set
+CONFIG_HUAWEI_TS=y
+# CONFIG_HUAWEI_TS_TEST is not set
+CONFIG_SYNAPTICS_TS=y
+# CONFIG_SYNAPTICS_LCD_TYPE is not set
+# CONFIG_CYPRESS_TS is not set
+# CONFIG_ATMEL_TS is not set
+# CONFIG_HIDEEP_TS is not set
+# CONFIG_HW_NOVATEK_TS is not set
+# CONFIG_ST_TS is not set
+# CONFIG_GOODIX_TS is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5 is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_DEVICETREE_SUPPORT is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_I2C is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_MT_A is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_BUTTON is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_DEVICE_ACCESS is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_LOADER is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP5_BINARY_FW_UPGRADE is not set
+CONFIG_HUAWEI_TP_COLOR_INFO=y
+# CONFIG_VIE_TOUCH_FW is not set
+# CONFIG_EVA_TOUCH_FW is not set
+# CONFIG_NEXT_TOUCH_FW is not set
+# CONFIG_KNIGHT_TOUCH_FW is not set
+# CONFIG_NEMO_TOUCH_FW is not set
+# CONFIG_VENUS_TOUCH_FW is not set
+# CONFIG_FRD_TOUCH_FW is not set
+# CONFIG_EDISON_TOUCH_FW is not set
+# CONFIG_BTV_TOUCH_FW is not set
+# CONFIG_NATASHA_TOUCH_FW is not set
+# CONFIG_HW_RL_TOUCH_KEY is not set
+# CONFIG_HUAWEI_UID_IO_STATS is not set
+CONFIG_SWITCH_FSA9685=y
+# CONFIG_SWITCH_USB is not set
+CONFIG_SWITCH_USB_CLS=y
+CONFIG_FSA9685_DEBUG_FS=y
+# CONFIG_SWITCH_OTGID_GPIO is not set
+# CONFIG_HUAWEI_TYPEC is not set
+# CONFIG_HUAWEI_TYPEC_PERICOM30216 is not set
+# CONFIG_HUAWEI_TYPEC_TUSB320 is not set
+# CONFIG_HUAWEI_TYPEC_FUSB301 is not set
+# CONFIG_HUAWEI_TYPEC_PTN5150H is not set
+CONFIG_TUSB422=y
+CONFIG_TUSB422_PAL=y
+CONFIG_TCPC_CLASS=y
+CONFIG_USB_POWER_DELIVERY=y
+CONFIG_TCPC_RT1711=y
+CONFIG_TCPC_RT1711H=y
+CONFIG_USB_PD_VBUS_STABLE_TOUT=125
+CONFIG_USB_PD_VBUS_PRESENT_TOUT=20
+# CONFIG_OTG_GPIO_ID is not set
+CONFIG_SUPERSWITCH_FSC=y
+# CONFIG_OTG_DUAL_ROLE is not set
+CONFIG_CC_ANTI_CORROSION=y
+CONFIG_SUPERSWITCH=y
+# CONFIG_HW_VOLTAGE_DETECTION is not set
+# CONFIG_ANTENNA_BOARDID_GPIO_DETECT is not set
+CONFIG_HUAWEI_VIBRATOR=y
+CONFIG_DRV2605=m
+# CONFIG_HUAWEI_OCP is not set
+CONFIG_MADAPT=y
+# CONFIG_DOME_KEY is not set
+# CONFIG_HW_HANDPRESS_SWITCH is not set
+CONFIG_HW_LED_ALWAYSON=y
+# CONFIG_HUAWEI_BOOT_TIME is not set
+# CONFIG_HW_LED_CONFIG is not set
+CONFIG_HUAWEI_EMCOM=y
+CONFIG_TCP_ARGO=y
+CONFIG_HUAWEI_XENGINE=y
+CONFIG_HUAWEI_EMCOM_CHANNEL=y
+CONFIG_HW_NETWORK_MEASUREMENT=y
+# CONFIG_HUAWEI_DTV_MMTUNER is not set
+CONFIG_DP_AUX_SWITCH=y
+CONFIG_OASES=y
+CONFIG_OASES_SIGNATURE_SUPPORT=y
+CONFIG_OASES_STATIC_PLTS=y
+CONFIG_HW_DP_SOURCE=y
+CONFIG_HUAWEI_DSM=y
+# CONFIG_HUAWEI_SDCARD_VOLD is not set
+# CONFIG_HUAWEI_DATA_ACQUISITION is not set
+CONFIG_CONNECTIVITY_HI110X=y
+CONFIG_HI110X_DRIVER_PATH="drivers/connectivity/hisi"
+# CONFIG_CONNECTIVITY_HI110X_HI6250 is not set
+# CONFIG_CONNECTIVITY_HI110X_HI3650 is not set
+# CONFIG_CONNECTIVITY_HI110X_HI3660 is not set
+# CONFIG_CONNECTIVITY_HI110X_KIRIN660 is not set
+CONFIG_CONNECTIVITY_HI110X_KIRIN970=y
+# CONFIG_CONNECTIVITY_HI110X_KIRIN980 is not set
+CONFIG_HI110X_SDIO_STD_CARD_SUPPORT=y
+CONFIG_HI110X_SDIO_FPGA=y
+CONFIG_HI110X_SDIO_DETECT_FUNCTION=y
+CONFIG_HI1102_PLATFORM=m
+CONFIG_HI1102_PLAT_HW_CHR=y
+CONFIG_HI1102_PLAT_OAL=y
+CONFIG_HI1102_PLAT_FRW=y
+CONFIG_HI1102_PLAT_OAM=y
+CONFIG_HI1102_PLAT_SDT=y
+CONFIG_HI1102_PLAT_PS=y
+CONFIG_HI1102_PLAT_PM=y
+CONFIG_HI1102_PLAT_MAIN=y
+CONFIG_HI1102_WIFI=m
+CONFIG_HI1102_WIFI_HMAC=y
+CONFIG_HI1102_WIFI_WAL=y
+CONFIG_HI1102_WIFI_MAIN=y
+# CONFIG_HI1102_WIFI_DMAC is not set
+CONFIG_CONTEXTHUB=y
+CONFIG_CONTEXTHUB_SHMEM=y
+# CONFIG_CONTEXTHUB_SHELL is not set
+CONFIG_CONTEXTHUB_PD=y
+# CONFIG_CONTEXTHUB_PLAYBACK is not set
+CONFIG_CONTEXTHUB_LOADMONITOR=y
+
+#
+# HISI FLP configuration
+#
+CONFIG_HISI_FLP=y
+CONFIG_HW_GADGET=y
+CONFIG_HUAWEI_BFM=y
+CONFIG_HW_BFMR_HISI=y
+# CONFIG_HW_BFMR_QCOM is not set
+CONFIG_USE_BOOTFAIL_RECOVERY_SOLUTION=y
+# CONFIG_HW_ZEROHUNG is not set
+CONFIG_HW_WIFIPRO=y
+CONFIG_HW_WIFIPRO_PROC=y
+CONFIG_AUDIOKIT=y
+CONFIG_HUAWEI_DSM_AUDIO=y
+CONFIG_HUAWEI_DEVICEBOX_AUDIO=y
+CONFIG_HUAWEI_SMARTPAKIT_AUDIO=m
+CONFIG_HISI_SPMI=y
+CONFIG_LCDKIT_DRIVER=y
+CONFIG_HUAWEI_HOST_TS_KIT=y
+CONFIG_HUAWEI_TS_KIT=y
+# CONFIG_HUAWEI_TS_KIT_TEST is not set
+CONFIG_HUAWEI_TS_KIT_COMMON=y
+CONFIG_HUAWEI_DEVKIT_HISI=y
+# CONFIG_HUAWEI_DEVKIT_QCOM is not set
+CONFIG_JDI_HOST_TS_KIT=y
+CONFIG_HUAWEI_THP=y
+CONFIG_HUAWEI_THP_NOVATECH=y
+# CONFIG_FOCAL_TS_KIT is not set
+CONFIG_SYNAPTICS_TS_KIT=y
+CONFIG_PARADE_TS_KIT=y
+CONFIG_NOVATEK_TS_KIT=y
+# CONFIG_NOVATEK_HYBRID_TS_KIT is not set
+# CONFIG_HIMAX_TS_KIT is not set
+# CONFIG_GOODIX_TS_KIT is not set
+# CONFIG_ATMEL_TS_KIT is not set
+# CONFIG_WACOM_TS_KIT is not set
+# CONFIG_GOODIX_GT1X_TS_KIT is not set
+CONFIG_SAMSUNG_TS_KIT=y
+CONFIG_HUAWEI_TP_KIT_COLOR_INFO=y
+CONFIG_HW_CPULOAD_NOTI=y
+# CONFIG_HW_MEMORY_MONITOR is not set
+# CONFIG_HUAWEI_ABNS is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_ARM_PSCI_FW=y
+# CONFIG_FIRMWARE_MEMMAP is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_ACPI is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_F2FS_FS=y
+CONFIG_F2FS_STAT_FS=y
+CONFIG_F2FS_FS_XATTR=y
+CONFIG_F2FS_FS_POSIX_ACL=y
+CONFIG_F2FS_FS_SECURITY=y
+# CONFIG_F2FS_CHECK_FS is not set
+CONFIG_F2FS_FS_ENCRYPTION=y
+CONFIG_HUAWEI_F2FS_DSM=y
+# CONFIG_F2FS_FAULT_INJECTION is not set
+CONFIG_HISI_F2FS_MTIME=y
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FS_ENCRYPTION=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_OVERLAY_FS=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DISCARD=y
+CONFIG_EXFAT_DELAYED_SYNC=y
+CONFIG_EXFAT_KERNEL_DEBUG=y
+# CONFIG_EXFAT_DEBUG_MSG is not set
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_TASK_PROTECT_LRU=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_HISI_PROC=y
+CONFIG_HISI_PROC_HARDWARE=y
+CONFIG_HISI_PROC_MEMORYINFO_FAST=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_ECRYPT_FS=y
+# CONFIG_ECRYPT_FS_MESSAGING is not set
+CONFIG_ECRYPT_FS_FILTER=y
+CONFIG_SDCARD_FS=y
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_CIFS_SMB2 is not set
+CONFIG_CIFS_DEFAULT="utf8"
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+CONFIG_VIRTUALIZATION=y
+# CONFIG_KVM is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+CONFIG_HISI_TIME=y
+CONFIG_HISI_PRINTK_EXTENSION=y
+# CONFIG_HISI_APANIC is not set
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x0
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_ARCH_HAS_KCOV=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+CONFIG_HW_DIE_CATCH=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DETECT_HUAWEI_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+# CONFIG_PANIC_ON_RT_THROTTLING is not set
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_HAVE_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_GPU_TRACEPOINTS=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+# CONFIG_FTRACE_SYSCALLS is not set
+CONFIG_TRACER_SNAPSHOT=y
+CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_PROBE_EVENTS is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+CONFIG_TRACING_EVENTS_GPIO=y
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y
+# CONFIG_UBSAN is not set
+# CONFIG_ARM64_PTDUMP is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_PID_IN_CONTEXTIDR=y
+# CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET is not set
+CONFIG_DEBUG_SET_MODULE_RONX=y
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+CONFIG_ENCRYPTED_KEYS=y
+CONFIG_SECURITY_DMESG_RESTRICT=y
+CONFIG_SECURITY_PERF_EVENTS_RESTRICT=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+CONFIG_LSM_MMAP_MIN_ADDR=32768
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+CONFIG_HAVE_ARCH_HARDENED_USERCOPY=y
+CONFIG_HARDENED_USERCOPY=y
+# CONFIG_HARDENED_USERCOPY_PAGESPAN is not set
+CONFIG_SECURITY_SELINUX=y
+# CONFIG_SECURITY_SELINUX_BOOTPARAM is not set
+# CONFIG_SECURITY_SELINUX_DISABLE is not set
+# CONFIG_SECURITY_SELINUX_DEVELOP is not set
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_INTEGRITY is not set
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+# CONFIG_DEFAULT_SECURITY_DAC is not set
+CONFIG_DEFAULT_SECURITY="selinux"
+CONFIG_HUAWEI_SELINUX_DSM=y
+CONFIG_HUAWEI_PROC_CHECK_ROOT=y
+
+#
+# Huawei root scanner
+#
+CONFIG_HW_ROOT_SCAN=y
+
+#
+# Huawei Kernel Harden
+#
+CONFIG_HUAWEI_KERNEL_STACK_RANDOMIZE=y
+CONFIG_HUAWEI_KERNEL_STACK_RANDOMIZE_STRONG=y
+# CONFIG_HUAWEI_KERNEL_STACK_NX is not set
+# CONFIG_HUAWEI_KERNEL_MODULE_RANDOMIZE is not set
+# CONFIG_HUAWEI_KASLR_DEBUGFS is not set
+CONFIG_HUAWEI_HIDESYMS=y
+# CONFIG_HUAWEI_HIDESYMS_DEBUGFS is not set
+# CONFIG_HUAWEI_PTRACE_POKE_ON is not set
+CONFIG_HKIP_ATKINFO=y
+# CONFIG_HKIP_ATKINFO_DEBUGFS is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+# CONFIG_CRYPTO_RSA is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=y
+# CONFIG_CRYPTO_MCRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+CONFIG_CRYPTO_ABLK_HELPER=y
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+CONFIG_CRYPTO_SEQIV=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_HEH is not set
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=y
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32=y
+# CONFIG_CRYPTO_CRCT10DIF is not set
+CONFIG_CRYPTO_GHASH=y
+# CONFIG_CRYPTO_POLY1305 is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_842 is not set
+CONFIG_CRYPTO_LZ4=y
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+CONFIG_CRYPTO_USER_API=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_CCP is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_PUBLIC_KEY_ALGO_RSA=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+CONFIG_PKCS7_MESSAGE_PARSER=y
+# CONFIG_PKCS7_TEST_KEY is not set
+# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+# CONFIG_CRYPTO_POLY_HASH_ARM64_CE is not set
+CONFIG_CRYPTO_AES_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
+CONFIG_CRYPTO_CRC32_ARM64=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+CONFIG_AUDIT_COMPAT_GENERIC=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_COMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_CLZ_TAB=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_WBT=y
+
+#fingerprint
+#CONFIG_BCM43455=y
+#CONFIG_BCMDHD_SDIO=y
+CONFIG_FINGERPRINT=y
+
+# huawei wifi linux driver
+CONFIG_BCM4359=y
+CONFIG_BCMDHD_PCIE=y
+# balong modem
+CONFIG_HISI_BALONG_MODEM=y
+CONFIG_HISI_BALONG_MODEM_HI3650=y
+
+#IPC
+CONFIG_IPC_DRIVER=y
+
+#ICC
+CONFIG_ICC_BALONG=y
+CONFIG_ICC_BALONG_TEST=n
+
+#SEC_CALL
+CONFIG_SEC_CALL=y
+
+#pmom
+CONFIG_PM_OM_BALONG=y
+CONFIG_PM_OM_BALONG_TEST=n
+
+#easy_shell
+CONFIG_BALONG_EASY_SHELL=y
+
+#IPF
+CONFIG_IPF_SUPPORT=y
+CONFIG_IPF_TEST=n
+#PSAM
+CONFIG_PSAM_SUPPORT=y
+
+#DSP
+CONFIG_DSP_BALONG=n
+
+#HKADC
+CONFIG_HKADC_BALONG=n
+
+#nvim
+CONFIG_NVIM=y
+CONFIG_NVIM_TEST=n
+
+#Loadm
+CONFIG_IMAGE_LOAD=y
+
+#OnOff
+CONFIG_BALONG_ONOFF=n
+CONFIG_BALONG_MODEM_ONOFF=y
+
+# sync
+CONFIG_SYNC_BALONG=y
+
+#hwadp
+CONFIG_HW_IP_BASE_ADDR=y
+
+#rfile
+CONFIG_RFILE_SUPPORT=y
+
+#MEM
+CONFIG_MEM_BALONG=y
+
+#timer
+CONFIG_HARD_TIMER=n
+CONFIG_SOFT_TIMER=n
+CONFIG_BBP_TIMER=n
+
+#UDI
+CONFIG_UDI_SUPPORT=y
+
+#RESET
+CONFIG_BALONG_MODEM_RESET=y
+CONFIG_BALONG_MODEM_RESET_TEST=n
+CONFIG_BALONG_MODEM_POWER_MANAGE=n
+CONFIG_HIFI_RESET=n
+
+#S_MEMORY
+CONFIG_S_MEMORY=y
+CONFIG_S_MEMORY_TEST=n
+
+#SYSCTRL
+CONFIG_SYSCTRL=y
+CONFIG_SYSCTRL_TEST=n
+
+# efuse
+CONFIG_EFUSE_BALONG=n
+CONFIG_EFUSE_BALONG_AGENT=y
+
+#---------------------------
+#dual modem
+CONFIG_DUAL_MODEM=n
+CONFIG_BALONG_OAM_PS=y
+CONFIG_FRAME_WARN=2048
+
+
+#OM
+CONFIG_HISI_DUMP=n
+
+#PMIC OCP
+CONFIG_PMIC_OCP=y
+
+#BBP
+CONFIG_BBP_ACORE=y
+CONFIG_HW_ZEROHUNG=y
diff --git a/arch/arm64/include/asm/livepatch-hhee.h b/arch/arm64/include/asm/livepatch-hhee.h
deleted file mode 120000
index e6fb7d8..0000000
--- a/arch/arm64/include/asm/livepatch-hhee.h
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/ap/kernel/arch/arm64/include/asm/livepatch-hhee.h
\ No newline at end of file
diff --git a/arch/arm64/include/asm/livepatch.h b/arch/arm64/include/asm/livepatch.h
deleted file mode 120000
index 5eef02c..0000000
--- a/arch/arm64/include/asm/livepatch.h
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/ap/kernel/arch/arm64/include/asm/livepatch.h
\ No newline at end of file
diff --git a/arch/arm64/include/asm/module.h b/arch/arm64/include/asm/module.h
old mode 100644
new mode 100755
index 12673ff..01b9634
--- a/arch/arm64/include/asm/module.h
+++ b/arch/arm64/include/asm/module.h
@@ -21,9 +21,6 @@
 
 #define MODULE_ARCH_VERMAGIC	"aarch64"
 
-extern int static_relocate(struct module *mod, unsigned long type,
-			void * loc, unsigned long value);
-
 #ifdef CONFIG_ARM64_MODULE_PLTS
 struct mod_plt_sec {
 	struct elf64_shdr	*plt;
@@ -39,9 +36,7 @@
 
 u64 module_emit_plt_entry(struct module *mod, void *loc, const Elf64_Rela *rela,
 			  Elf64_Sym *sym);
-#ifdef CONFIG_LIVEPATCH
-u64 livepatch_emit_plt_entry(struct module *mod, unsigned long val);
-#endif
+
 #ifdef CONFIG_RANDOMIZE_BASE
 #ifdef CONFIG_MODVERSIONS
 #define ARCH_RELOCATES_KCRCTAB
diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
old mode 100644
new mode 100755
index 52c38e26..bd9656a
--- a/arch/arm64/kernel/Makefile
+++ b/arch/arm64/kernel/Makefile
@@ -29,7 +29,6 @@
 					   sys_compat.o entry32.o		\
 					   ../../arm/kernel/opcodes.o
 arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
-arm64-obj-$(CONFIG_LIVEPATCH)		+= livepatch.o
 arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
 arm64-obj-$(CONFIG_ARM64_MODULE_PLTS)	+= module-plts.o
 arm64-obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o perf_callchain.o
diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S
old mode 100644
new mode 100755
index e2adf39..5c6b35c
--- a/arch/arm64/kernel/entry.S
+++ b/arch/arm64/kernel/entry.S
@@ -332,7 +332,6 @@
  */
 	.pushsection ".entry.text", "ax"
 
-	.pushsection ".entry.text", "ax"
 	.align	11
 ENTRY(vectors)
 	ventry	el1_sync_invalid		// Synchronous EL1t
@@ -1007,4 +1006,3 @@
 	ret
 ENDPROC(get_pt_regs)
 #endif
-.popsection
diff --git a/arch/arm64/kernel/livepatch.c b/arch/arm64/kernel/livepatch.c
deleted file mode 120000
index 54d0e00..0000000
--- a/arch/arm64/kernel/livepatch.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/arch/arm64/kernel/livepatch.c
\ No newline at end of file
diff --git a/arch/arm64/kernel/module-plts.c b/arch/arm64/kernel/module-plts.c
index cce38f5..07f8b80 100755
--- a/arch/arm64/kernel/module-plts.c
+++ b/arch/arm64/kernel/module-plts.c
@@ -10,7 +10,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/sort.h>
-#include <asm/livepatch-hhee.h>
 
 struct plt_entry {
 	/*
@@ -27,8 +26,6 @@
 	__le32	br;	/* br	x16				*/
 };
 
-static struct plt_entry *plts_addr;
-
 static bool in_init(const struct module *mod, void *loc)
 {
 	return (u64)loc - (u64)mod->module_init < mod->init_size;
@@ -42,9 +39,6 @@
 	struct plt_entry *plt = (struct plt_entry *)pltsec->plt->sh_addr;
 	int i = pltsec->plt_num_entries;
 	u64 val = sym->st_value + rela->r_addend;
-
-	if (!in_init(mod, loc))
-		plts_addr = plt;
 
 	/*
 	 * MOVK/MOVN/MOVZ opcode:
@@ -207,18 +201,6 @@
 						sechdrs[i].sh_info);
 	}
 
-#ifdef CONFIG_LIVEPATCH
-	for (i = 0; i < ehdr->e_shnum; i++) {
-		if (!strcmp(".livepatch.pltcount", secstrings + sechdrs[i].sh_name)) {
-			core_plts += sechdrs[i].sh_size;
-			sechdrs[i].sh_size = 0;
-			sechdrs[i].sh_type = SHT_NOBITS;
-			sechdrs[i].sh_flags = 0;
-			break;
-		}
-	}
-#endif
-
 	mod->arch.core.plt->sh_type = SHT_NOBITS;
 	mod->arch.core.plt->sh_flags = SHF_EXECINSTR | SHF_ALLOC;
 	mod->arch.core.plt->sh_addralign = L1_CACHE_BYTES;
@@ -233,30 +215,4 @@
 	mod->arch.init.plt_num_entries = 0;
 	mod->arch.init.plt_max_entries = init_plts;
 	return 0;
-}
-
-u64 livepatch_emit_plt_entry(struct module *mod, unsigned long val)
-{
-	struct plt_entry *plt = plts_addr;
-	int num = mod->arch.core.plt_num_entries;
-	u32 *addr = &plt[num];
-	u32 insns[4];
-	int i;
-
-	mod->arch.core.plt_num_entries++;
-	BUG_ON(mod->arch.core.plt_num_entries > mod->arch.core.plt_max_entries);
-
-	insns[0] = cpu_to_le32(0x92800010 | (((~val      ) & 0xffff)) << 5);
-	insns[1] = cpu_to_le32(0xf2a00010 | ((( val >> 16) & 0xffff)) << 5);
-	insns[2] = cpu_to_le32(0xf2c00010 | ((( val >> 32) & 0xffff)) << 5);
-	insns[3] = cpu_to_le32(0xd61f0200);
-
-	for (i = 0; i < 4; i ++) {
-		if (is_hkip_enabled()) {
-			aarch64_insn_patch_text_hkip(addr + i, insns[i], hkip_token);
-		} else
-			aarch64_insn_patch_text_nosync(addr + i, insns[i]);
-	}
-
-	return (u64)addr;
 }
diff --git a/arch/arm64/kernel/module.c b/arch/arm64/kernel/module.c
old mode 100644
new mode 100755
index 692bd3f..4293a88
--- a/arch/arm64/kernel/module.c
+++ b/arch/arm64/kernel/module.c
@@ -29,7 +29,6 @@
 #include <asm/alternative.h>
 #include <asm/insn.h>
 #include <asm/sections.h>
-#include <asm/livepatch-hhee.h>
 
 void *module_alloc(unsigned long size)
 {
@@ -87,33 +86,23 @@
 	return 0;
 }
 
-static int reloc_data(enum aarch64_reloc_op op, void *place, u64 val, int len,
-				enum aarch64_reloc_stage reloc_stage)
+static int reloc_data(enum aarch64_reloc_op op, void *place, u64 val, int len)
 {
 	s64 sval = do_reloc(op, place, val);
 
 	switch (len) {
 	case 16:
-		if (reloc_stage == RELOC_MODULE_LOADED && is_hkip_enabled())
-			apply_reloc_hkip(place, 2, sval, hkip_token);
-		else
-			*(s16 *)place = sval;
+		*(s16 *)place = sval;
 		if (sval < S16_MIN || sval > U16_MAX)
 			return -ERANGE;
 		break;
 	case 32:
-		if (reloc_stage == RELOC_MODULE_LOADED && is_hkip_enabled())
-			apply_reloc_hkip(place, 4, sval, hkip_token);
-		else
-			*(s32 *)place = sval;
+		*(s32 *)place = sval;
 		if (sval < S32_MIN || sval > U32_MAX)
 			return -ERANGE;
 		break;
 	case 64:
-		if (reloc_stage == RELOC_MODULE_LOADED && is_hkip_enabled())
-			apply_reloc_hkip(place, 8, sval, hkip_token);
-		else
-			*(s64 *)place = sval;
+		*(s64 *)place = sval;
 		break;
 	default:
 		pr_err("Invalid length (%d) for data relocation\n", len);
@@ -122,45 +111,13 @@
 	return 0;
 }
 
-static int reloc_data_loaded(struct module *me, enum aarch64_reloc_op op,
-				void *place, u64 val, int len)
-{
-	int ret, numpages, size = 4;
-	bool readonly;
-	unsigned long core = (unsigned long)me->module_core;
-	unsigned long core_size = me->core_size;
-	unsigned long loc = (unsigned long)place;
-
-	if (loc < core || loc >= core + core_size)
-		return -EINVAL;
-
-	readonly = false;
-#ifdef CONFIG_DEBUG_SET_MODULE_RONX
-	if(!is_hkip_enabled())
-		if (loc < core + me->core_ro_size)
-			readonly = true;
-#endif
-
-	numpages = ((loc & PAGE_MASK) == ((loc + size) & PAGE_MASK)) ? 1 : 2;
-
-	if (readonly)
-		set_memory_rw(loc & PAGE_MASK, numpages);
-
-	ret = reloc_data(op, place, val, len, RELOC_MODULE_LOADED);
-
-	if (readonly)
-		set_memory_ro(loc & PAGE_MASK, numpages);
-
-	return ret;
-}
-
 enum aarch64_insn_movw_imm_type {
 	AARCH64_INSN_IMM_MOVNZ,
 	AARCH64_INSN_IMM_MOVKZ,
 };
 
 static int reloc_insn_movw(enum aarch64_reloc_op op, void *place, u64 val,
-			   int lsb, enum aarch64_insn_movw_imm_type imm_type, enum aarch64_reloc_stage reloc_stage)
+			   int lsb, enum aarch64_insn_movw_imm_type imm_type)
 {
 	u64 imm;
 	s64 sval;
@@ -192,14 +149,7 @@
 
 	/* Update the instruction with the new encoding. */
 	insn = aarch64_insn_encode_immediate(AARCH64_INSN_IMM_16, insn, imm);
-	if (reloc_stage == RELOC_MODULE_LOADED && is_hkip_enabled())
-		apply_reloc_hkip(place, 4, cpu_to_le32(insn), hkip_token);
-	else
-		*(u32 *)place = cpu_to_le32(insn);
-
-	if (reloc_stage == RELOC_MODULE_LOADED)
-		flush_icache_range((uintptr_t)place,
-				(uintptr_t)place + AARCH64_INSN_SIZE);
+	*(u32 *)place = cpu_to_le32(insn);
 
 	if (imm > U16_MAX)
 		return -ERANGE;
@@ -207,38 +157,8 @@
 	return 0;
 }
 
-static int reloc_insn_movw_loaded(struct module *me, enum aarch64_reloc_op op,
-	void *place, u64 val, int lsb, enum aarch64_insn_movw_imm_type imm_type)
-{
-        int ret;
-        bool readonly;
-        unsigned long core = (unsigned long)me->module_core;
-        unsigned long core_size = me->core_size;
-        unsigned long loc = (unsigned long)place;
-
-        if (loc < core || loc >= core + core_size)
-                return -EINVAL;
-
-        readonly = false;
-#ifdef CONFIG_DEBUG_SET_MODULE_RONX
-	if(!is_hkip_enabled())
-		if (loc < core + me->core_ro_size)
-			readonly = true;
-#endif
-
-        if (readonly)
-                set_memory_rw(loc & PAGE_MASK, 1);
-
-        ret = reloc_insn_movw(op, place, val, lsb, imm_type, RELOC_MODULE_LOADED);
-
-        if (readonly)
-                set_memory_ro(loc & PAGE_MASK, 1);
-
-        return ret;
-}
-
 static int reloc_insn_imm(enum aarch64_reloc_op op, void *place, u64 val,
-			  int lsb, int len, enum aarch64_insn_imm_type imm_type, enum aarch64_reloc_stage reloc_stage)
+			  int lsb, int len, enum aarch64_insn_imm_type imm_type)
 {
 	u64 imm, imm_mask;
 	s64 sval;
@@ -254,14 +174,7 @@
 
 	/* Update the instruction's immediate field. */
 	insn = aarch64_insn_encode_immediate(imm_type, insn, imm);
-	if (reloc_stage == RELOC_MODULE_LOADED && is_hkip_enabled())
-		apply_reloc_hkip(place, 4, cpu_to_le32(insn),hkip_token);
-	else
-		*(u32 *)place = cpu_to_le32(insn);
-
-	if (reloc_stage == RELOC_MODULE_LOADED)
-		flush_icache_range((uintptr_t)place,
-				(uintptr_t)place + AARCH64_INSN_SIZE);
+	*(u32 *)place = cpu_to_le32(insn);
 
 	/*
 	 * Extract the upper value bits (including the sign bit) and
@@ -277,36 +190,6 @@
 		return -ERANGE;
 
 	return 0;
-}
-
-static int reloc_insn_imm_loaded(struct module *me, enum aarch64_reloc_op op,
-		void *place, u64 val, int lsb, int len, enum aarch64_insn_imm_type imm_type)
-{
-	int ret;
-	bool readonly;
-	unsigned long core = (unsigned long)me->module_core;
-	unsigned long core_size = me->core_size;
-	unsigned long loc = (unsigned long)place;
-
-	if (loc < core || loc >= core + core_size)
-		return -EINVAL;
-
-	readonly = false;
-#ifdef CONFIG_DEBUG_SET_MODULE_RONX
-	if(!is_hkip_enabled())
-		if (loc < core + me->core_ro_size)
-			readonly = true;
-#endif
-
-	if (readonly)
-		set_memory_rw(loc & PAGE_MASK, 1);
-
-	ret = reloc_insn_imm(op, place, val, lsb, len, imm_type, RELOC_MODULE_LOADED);
-
-	if (readonly)
-		set_memory_ro(loc & PAGE_MASK, 1);
-
-	return ret;
 }
 
 int apply_relocate_add(Elf64_Shdr *sechdrs,
@@ -349,23 +232,23 @@
 		/* Data relocations. */
 		case R_AARCH64_ABS64:
 			overflow_check = false;
-			ovf = reloc_data(RELOC_OP_ABS, loc, val, 64, RELOC_MODULE_LOADING);
+			ovf = reloc_data(RELOC_OP_ABS, loc, val, 64);
 			break;
 		case R_AARCH64_ABS32:
-			ovf = reloc_data(RELOC_OP_ABS, loc, val, 32, RELOC_MODULE_LOADING);
+			ovf = reloc_data(RELOC_OP_ABS, loc, val, 32);
 			break;
 		case R_AARCH64_ABS16:
-			ovf = reloc_data(RELOC_OP_ABS, loc, val, 16, RELOC_MODULE_LOADING);
+			ovf = reloc_data(RELOC_OP_ABS, loc, val, 16);
 			break;
 		case R_AARCH64_PREL64:
 			overflow_check = false;
-			ovf = reloc_data(RELOC_OP_PREL, loc, val, 64, RELOC_MODULE_LOADING);
+			ovf = reloc_data(RELOC_OP_PREL, loc, val, 64);
 			break;
 		case R_AARCH64_PREL32:
-			ovf = reloc_data(RELOC_OP_PREL, loc, val, 32, RELOC_MODULE_LOADING);
+			ovf = reloc_data(RELOC_OP_PREL, loc, val, 32);
 			break;
 		case R_AARCH64_PREL16:
-			ovf = reloc_data(RELOC_OP_PREL, loc, val, 16, RELOC_MODULE_LOADING);
+			ovf = reloc_data(RELOC_OP_PREL, loc, val, 16);
 			break;
 
 		/* MOVW instruction relocations. */
@@ -373,133 +256,133 @@
 			overflow_check = false;
 		case R_AARCH64_MOVW_UABS_G0:
 			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 0,
-					      AARCH64_INSN_IMM_MOVKZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVKZ);
 			break;
 		case R_AARCH64_MOVW_UABS_G1_NC:
 			overflow_check = false;
 		case R_AARCH64_MOVW_UABS_G1:
 			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 16,
-					      AARCH64_INSN_IMM_MOVKZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVKZ);
 			break;
 		case R_AARCH64_MOVW_UABS_G2_NC:
 			overflow_check = false;
 		case R_AARCH64_MOVW_UABS_G2:
 			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 32,
-					      AARCH64_INSN_IMM_MOVKZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVKZ);
 			break;
 		case R_AARCH64_MOVW_UABS_G3:
 			/* We're using the top bits so we can't overflow. */
 			overflow_check = false;
 			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 48,
-					      AARCH64_INSN_IMM_MOVKZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVKZ);
 			break;
 		case R_AARCH64_MOVW_SABS_G0:
 			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 0,
-					      AARCH64_INSN_IMM_MOVNZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVNZ);
 			break;
 		case R_AARCH64_MOVW_SABS_G1:
 			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 16,
-					      AARCH64_INSN_IMM_MOVNZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVNZ);
 			break;
 		case R_AARCH64_MOVW_SABS_G2:
 			ovf = reloc_insn_movw(RELOC_OP_ABS, loc, val, 32,
-					      AARCH64_INSN_IMM_MOVNZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVNZ);
 			break;
 		case R_AARCH64_MOVW_PREL_G0_NC:
 			overflow_check = false;
 			ovf = reloc_insn_movw(RELOC_OP_PREL, loc, val, 0,
-					      AARCH64_INSN_IMM_MOVKZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVKZ);
 			break;
 		case R_AARCH64_MOVW_PREL_G0:
 			ovf = reloc_insn_movw(RELOC_OP_PREL, loc, val, 0,
-					      AARCH64_INSN_IMM_MOVNZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVNZ);
 			break;
 		case R_AARCH64_MOVW_PREL_G1_NC:
 			overflow_check = false;
 			ovf = reloc_insn_movw(RELOC_OP_PREL, loc, val, 16,
-					      AARCH64_INSN_IMM_MOVKZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVKZ);
 			break;
 		case R_AARCH64_MOVW_PREL_G1:
 			ovf = reloc_insn_movw(RELOC_OP_PREL, loc, val, 16,
-					      AARCH64_INSN_IMM_MOVNZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVNZ);
 			break;
 		case R_AARCH64_MOVW_PREL_G2_NC:
 			overflow_check = false;
 			ovf = reloc_insn_movw(RELOC_OP_PREL, loc, val, 32,
-					      AARCH64_INSN_IMM_MOVKZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVKZ);
 			break;
 		case R_AARCH64_MOVW_PREL_G2:
 			ovf = reloc_insn_movw(RELOC_OP_PREL, loc, val, 32,
-					      AARCH64_INSN_IMM_MOVNZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVNZ);
 			break;
 		case R_AARCH64_MOVW_PREL_G3:
 			/* We're using the top bits so we can't overflow. */
 			overflow_check = false;
 			ovf = reloc_insn_movw(RELOC_OP_PREL, loc, val, 48,
-					      AARCH64_INSN_IMM_MOVNZ, RELOC_MODULE_LOADING);
+					      AARCH64_INSN_IMM_MOVNZ);
 			break;
 
 		/* Immediate instruction relocations. */
 		case R_AARCH64_LD_PREL_LO19:
 			ovf = reloc_insn_imm(RELOC_OP_PREL, loc, val, 2, 19,
-					     AARCH64_INSN_IMM_19, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_19);
 			break;
 		case R_AARCH64_ADR_PREL_LO21:
 			ovf = reloc_insn_imm(RELOC_OP_PREL, loc, val, 0, 21,
-					     AARCH64_INSN_IMM_ADR, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_ADR);
 			break;
 #ifndef CONFIG_ARM64_ERRATUM_843419
 		case R_AARCH64_ADR_PREL_PG_HI21_NC:
 			overflow_check = false;
 		case R_AARCH64_ADR_PREL_PG_HI21:
 			ovf = reloc_insn_imm(RELOC_OP_PAGE, loc, val, 12, 21,
-					     AARCH64_INSN_IMM_ADR, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_ADR);
 			break;
 #endif
 		case R_AARCH64_ADD_ABS_LO12_NC:
 		case R_AARCH64_LDST8_ABS_LO12_NC:
 			overflow_check = false;
 			ovf = reloc_insn_imm(RELOC_OP_ABS, loc, val, 0, 12,
-					     AARCH64_INSN_IMM_12, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_12);
 			break;
 		case R_AARCH64_LDST16_ABS_LO12_NC:
 			overflow_check = false;
 			ovf = reloc_insn_imm(RELOC_OP_ABS, loc, val, 1, 11,
-					     AARCH64_INSN_IMM_12, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_12);
 			break;
 		case R_AARCH64_LDST32_ABS_LO12_NC:
 			overflow_check = false;
 			ovf = reloc_insn_imm(RELOC_OP_ABS, loc, val, 2, 10,
-					     AARCH64_INSN_IMM_12, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_12);
 			break;
 		case R_AARCH64_LDST64_ABS_LO12_NC:
 			overflow_check = false;
 			ovf = reloc_insn_imm(RELOC_OP_ABS, loc, val, 3, 9,
-					     AARCH64_INSN_IMM_12, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_12);
 			break;
 		case R_AARCH64_LDST128_ABS_LO12_NC:
 			overflow_check = false;
 			ovf = reloc_insn_imm(RELOC_OP_ABS, loc, val, 4, 8,
-					     AARCH64_INSN_IMM_12, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_12);
 			break;
 		case R_AARCH64_TSTBR14:
 			ovf = reloc_insn_imm(RELOC_OP_PREL, loc, val, 2, 14,
-					     AARCH64_INSN_IMM_14, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_14);
 			break;
 		case R_AARCH64_CONDBR19:
 			ovf = reloc_insn_imm(RELOC_OP_PREL, loc, val, 2, 19,
-					     AARCH64_INSN_IMM_19, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_19);
 			break;
 		case R_AARCH64_JUMP26:
 		case R_AARCH64_CALL26:
 			ovf = reloc_insn_imm(RELOC_OP_PREL, loc, val, 2, 26,
-					     AARCH64_INSN_IMM_26, RELOC_MODULE_LOADING);
+					     AARCH64_INSN_IMM_26);
 
 			if (IS_ENABLED(CONFIG_ARM64_MODULE_PLTS) &&
 			    ovf == -ERANGE) {
 				val = module_emit_plt_entry(me, loc, &rel[i], sym);
 				ovf = reloc_insn_imm(RELOC_OP_PREL, loc, val, 2,
-						     26, AARCH64_INSN_IMM_26, RELOC_MODULE_LOADING);
+						     26, AARCH64_INSN_IMM_26);
 			}
 			break;
 
@@ -539,180 +422,3 @@
 	return 0;
 }
 
-int static_relocate(struct module *me, unsigned long type, void *loc,
-		    unsigned long val)
-{
-	int ovf = 0;
-	bool overflow_check = true;
-	/* Perform the static relocation. */
-	switch (type) {
-		/* Null relocations. */
-		case R_ARM_NONE:
-		case R_AARCH64_NONE:
-			ovf = 0;
-			break;
-
-		/* Data relocations. */
-		case R_AARCH64_ABS64:
-			overflow_check = false;
-			ovf = reloc_data_loaded(me, RELOC_OP_ABS, loc, val, 64);
-			break;
-		case R_AARCH64_ABS32:
-			ovf = reloc_data_loaded(me, RELOC_OP_ABS, loc, val, 32);
-			break;
-		case R_AARCH64_ABS16:
-			ovf = reloc_data_loaded(me, RELOC_OP_ABS, loc, val, 16);
-			break;
-		case R_AARCH64_PREL64:
-			overflow_check = false;
-			ovf = reloc_data_loaded(me, RELOC_OP_PREL, loc, val, 64);
-			break;
-		case R_AARCH64_PREL32:
-			ovf = reloc_data_loaded(me, RELOC_OP_PREL, loc, val, 32);
-			break;
-		case R_AARCH64_PREL16:
-			ovf = reloc_data_loaded(me, RELOC_OP_PREL, loc, val, 16);
-			break;
-
-		/* MOVW instruction relocations. */
-		case R_AARCH64_MOVW_UABS_G0_NC:
-			overflow_check = false;
-		case R_AARCH64_MOVW_UABS_G0:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_ABS, loc, val, 0,
-				      AARCH64_INSN_IMM_MOVKZ);
-			break;
-		case R_AARCH64_MOVW_UABS_G1_NC:
-			overflow_check = false;
-		case R_AARCH64_MOVW_UABS_G1:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_ABS, loc, val, 16,
-				      AARCH64_INSN_IMM_MOVKZ);
-			break;
-		case R_AARCH64_MOVW_UABS_G2_NC:
-			overflow_check = false;
-		case R_AARCH64_MOVW_UABS_G2:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_ABS, loc, val, 32,
-				      AARCH64_INSN_IMM_MOVKZ);
-			break;
-		case R_AARCH64_MOVW_UABS_G3:
-			/* We're using the top bits so we can't overflow. */
-			overflow_check = false;
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_ABS, loc, val, 48,
-				      AARCH64_INSN_IMM_MOVKZ);
-			break;
-		case R_AARCH64_MOVW_SABS_G0:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_ABS, loc, val, 0,
-				      AARCH64_INSN_IMM_MOVNZ);
-			break;
-		case R_AARCH64_MOVW_SABS_G1:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_ABS, loc, val, 16,
-				      AARCH64_INSN_IMM_MOVNZ);
-			break;
-		case R_AARCH64_MOVW_SABS_G2:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_ABS, loc, val, 32,
-				      AARCH64_INSN_IMM_MOVNZ);
-			break;
-		case R_AARCH64_MOVW_PREL_G0_NC:
-			overflow_check = false;
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_PREL, loc, val, 0,
-				      AARCH64_INSN_IMM_MOVKZ);
-			break;
-		case R_AARCH64_MOVW_PREL_G0:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_PREL, loc, val, 0,
-				      AARCH64_INSN_IMM_MOVNZ);
-			break;
-		case R_AARCH64_MOVW_PREL_G1_NC:
-			overflow_check = false;
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_PREL, loc, val, 16,
-				      AARCH64_INSN_IMM_MOVKZ);
-			break;
-		case R_AARCH64_MOVW_PREL_G1:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_PREL, loc, val, 16,
-				      AARCH64_INSN_IMM_MOVNZ);
-			break;
-		case R_AARCH64_MOVW_PREL_G2_NC:
-			overflow_check = false;
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_PREL, loc, val, 32,
-				      AARCH64_INSN_IMM_MOVKZ);
-			break;
-		case R_AARCH64_MOVW_PREL_G2:
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_PREL, loc, val, 32,
-				      AARCH64_INSN_IMM_MOVNZ);
-			break;
-		case R_AARCH64_MOVW_PREL_G3:
-			/* We're using the top bits so we can't overflow. */
-			overflow_check = false;
-			ovf = reloc_insn_movw_loaded(me, RELOC_OP_PREL, loc, val, 48,
-				      AARCH64_INSN_IMM_MOVNZ);
-			break;
-
-		/* Immediate instruction relocations. */
-		case R_AARCH64_LD_PREL_LO19:
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_PREL, loc, val, 2, 19,
-				     AARCH64_INSN_IMM_19);
-			break;
-		case R_AARCH64_ADR_PREL_LO21:
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_PREL, loc, val, 0, 21,
-				     AARCH64_INSN_IMM_ADR);
-			break;
-#ifndef CONFIG_ARM64_ERRATUM_843419
-		case R_AARCH64_ADR_PREL_PG_HI21_NC:
-			overflow_check = false;
-		case R_AARCH64_ADR_PREL_PG_HI21:
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_PAGE, loc, val, 12, 21,
-				     AARCH64_INSN_IMM_ADR);
-			break;
-#endif
-		case R_AARCH64_ADD_ABS_LO12_NC:
-		case R_AARCH64_LDST8_ABS_LO12_NC:
-			overflow_check = false;
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_ABS, loc, val, 0, 12,
-				     AARCH64_INSN_IMM_12);
-			break;
-		case R_AARCH64_LDST16_ABS_LO12_NC:
-			overflow_check = false;
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_ABS, loc, val, 1, 11,
-				     AARCH64_INSN_IMM_12);
-			break;
-		case R_AARCH64_LDST32_ABS_LO12_NC:
-			overflow_check = false;
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_ABS, loc, val, 2, 10,
-				     AARCH64_INSN_IMM_12);
-			break;
-		case R_AARCH64_LDST64_ABS_LO12_NC:
-			overflow_check = false;
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_ABS, loc, val, 3, 9,
-				     AARCH64_INSN_IMM_12);
-			break;
-		case R_AARCH64_LDST128_ABS_LO12_NC:
-			overflow_check = false;
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_ABS, loc, val, 4, 8,
-				     AARCH64_INSN_IMM_12);
-			break;
-		case R_AARCH64_TSTBR14:
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_PREL, loc, val, 2, 14,
-				     AARCH64_INSN_IMM_14);
-			break;
-		case R_AARCH64_CONDBR19:
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_PREL, loc, val, 2, 19,
-				     AARCH64_INSN_IMM_19);
-			break;
-		case R_AARCH64_JUMP26:
-		case R_AARCH64_CALL26:
-			ovf = reloc_insn_imm_loaded(me, RELOC_OP_PREL, loc, val, 2, 26,
-				     AARCH64_INSN_IMM_26);
-			break;
-
-	default:
-		pr_err("module %s: unsupported RELA relocation: %lu\n",
-			me->name, type);
-		return -ENOEXEC;
-	}
-
-	if (overflow_check && ovf == -ERANGE) {
-		pr_err("module %s: overflow in relocation type %lu val %lx\n",
-			me->name, type, val);
-		return -ENOEXEC;
-	}
-
-	return 0;
-}
diff --git a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S
old mode 100644
new mode 100755
index 7cd1c93..9c4869e
--- a/arch/arm64/kernel/vmlinux.lds.S
+++ b/arch/arm64/kernel/vmlinux.lds.S
@@ -118,7 +118,6 @@
 			*(.exception.text)
 			__exception_text_end = .;
 			IRQENTRY_TEXT
-			ENTRY_TEXT
 			TEXT_TEXT
 			SCHED_TEXT
 			LOCK_TEXT
diff --git a/block/Makefile b/block/Makefile
old mode 100755
new mode 100644
index d26f210..0719ad3
--- a/block/Makefile
+++ b/block/Makefile
@@ -9,14 +9,12 @@
 			blk-mq-sysfs.o blk-mq-cpu.o blk-mq-cpumap.o ioctl.o \
 			genhd.o scsi_ioctl.o partition-generic.o ioprio.o \
 			partitions/
-obj-$(CONFIG_HISI_BLK_CORE)     += hisi-blk-core.o hisi-blk-settings.o
 obj-$(CONFIG_HISI_BLK_MQ) += hisi-blk-mq-tag.o
 obj-$(CONFIG_HISI_BLK_MQ_DUMP) += hisi-blk-mq-dump.o
 obj-$(CONFIG_HISI_IO_LATENCY_TRACE) += hisi-blk-latency.o
 obj-$(CONFIG_HISI_MANUAL_BKOPS)     += hisi-bkops-core.o hisi-bkops-sysfs.o
 obj-$(CONFIG_HISI_MQ_DISPATCH_DECISION)	+= hisi-blk-mq-dispatch-strategy.o
 obj-$(CONFIG_HISI_BLK_FLUSH_REDUCE) += hisi-blk-flush.o
-obj-$(CONFIG_HISI_DEBUG_FS) += hisi-blk-ft.o hisi-blk-sysfs.o
 obj-$(CONFIG_BOUNCE)	+= bounce.o
 obj-$(CONFIG_BLK_DEV_BSG)	+= bsg.o
 obj-$(CONFIG_BLK_DEV_BSGLIB)	+= bsg-lib.o
@@ -30,7 +28,6 @@
 obj-$(CONFIG_BLOCK_COMPAT)	+= compat_ioctl.o
 obj-$(CONFIG_BLK_CMDLINE_PARSER)	+= cmdline-parser.o
 obj-$(CONFIG_BLK_DEV_INTEGRITY) += bio-integrity.o blk-integrity.o t10-pi.o
-obj-$(CONFIG_HISI_BLOCK_FREQUENCE_CONTROL) += hisi_freq_ctl.o
 obj-$(CONFIG_HISI_PARTITION) += kirin_partition.o
 
 obj-$(CONFIG_BLK_DEV_BSG)	+= hisi_blk_scsi_kern.o
diff --git a/block/blk-core.c b/block/blk-core.c
index 7b8c229..bfd8c03 100755
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -43,9 +43,6 @@
 
 #include <linux/math64.h>
 
-#ifdef CONFIG_HISI_BLOCK_FREQUENCE_CONTROL
-#include "hisi_freq_ctl.h"
-#endif
 #ifdef CONFIG_HW_ZEROHUNG
 #include <chipset_common/hwzrhung/zrhung_wp_io.h>
 #endif
@@ -1537,12 +1534,6 @@
 		__part_stat_add(cpu, part, time_in_queue,
 				inflight * (now - part->stamp));/*lint !e63*/
 		__part_stat_add(cpu, part, io_ticks, (now - part->stamp));/*lint !e63*/
-#ifdef CONFIG_HISI_BLOCK_FREQUENCE_CONTROL
-		hisi_blk_freq_request(FREQ_REQ_ADD,
-				inflight * (now - part->stamp));
-	}else{
-		hisi_blk_freq_request(FREQ_REQ_REMOVE, (now - part->stamp));
-#endif
 	}
 	part->stamp = now;
 }
@@ -3882,9 +3873,6 @@
 			sizeof(struct request_queue), 0, SLAB_PANIC, NULL);
 #ifdef CONFIG_HISI_BLK_CORE
 	hisi_blk_dev_init();
-#endif
-#ifdef CONFIG_HISI_BLOCK_FREQUENCE_CONTROL
-	hisi_blk_freq_ctrl_init();
 #endif
 #ifdef CONFIG_HW_ZEROHUNG
 	iowp_workqueue_init();
diff --git a/block/hisi-bkops-core.c b/block/hisi-bkops-core.c
deleted file mode 120000
index 377de50..0000000
--- a/block/hisi-bkops-core.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-bkops-core.c
\ No newline at end of file
diff --git a/block/hisi-bkops-sysfs.c b/block/hisi-bkops-sysfs.c
deleted file mode 120000
index b2d4049..0000000
--- a/block/hisi-bkops-sysfs.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-bkops-sysfs.c
\ No newline at end of file
diff --git a/block/hisi-blk-core.c b/block/hisi-blk-core.c
deleted file mode 120000
index 1b2d126..0000000
--- a/block/hisi-blk-core.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-core.c
\ No newline at end of file
diff --git a/block/hisi-blk-flush.c b/block/hisi-blk-flush.c
deleted file mode 120000
index d4ceba1..0000000
--- a/block/hisi-blk-flush.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-flush.c
\ No newline at end of file
diff --git a/block/hisi-blk-ft.c b/block/hisi-blk-ft.c
deleted file mode 120000
index bedae43..0000000
--- a/block/hisi-blk-ft.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-ft.c
\ No newline at end of file
diff --git a/block/hisi-blk-latency.c b/block/hisi-blk-latency.c
deleted file mode 120000
index ef12b51..0000000
--- a/block/hisi-blk-latency.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-latency.c
\ No newline at end of file
diff --git a/block/hisi-blk-mq-dispatch-strategy.c b/block/hisi-blk-mq-dispatch-strategy.c
deleted file mode 120000
index a094d07..0000000
--- a/block/hisi-blk-mq-dispatch-strategy.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-mq-dispatch-strategy.c
\ No newline at end of file
diff --git a/block/hisi-blk-mq-dump.c b/block/hisi-blk-mq-dump.c
deleted file mode 120000
index f0680cb..0000000
--- a/block/hisi-blk-mq-dump.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-mq-dump.c
\ No newline at end of file
diff --git a/block/hisi-blk-mq-tag.c b/block/hisi-blk-mq-tag.c
deleted file mode 120000
index dab0361..0000000
--- a/block/hisi-blk-mq-tag.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-mq-tag.c
\ No newline at end of file
diff --git a/block/hisi-blk-settings.c b/block/hisi-blk-settings.c
deleted file mode 120000
index 5ef213e..0000000
--- a/block/hisi-blk-settings.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-settings.c
\ No newline at end of file
diff --git a/block/hisi-blk-sysfs.c b/block/hisi-blk-sysfs.c
deleted file mode 120000
index 5f8f09e..0000000
--- a/block/hisi-blk-sysfs.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi-blk-sysfs.c
\ No newline at end of file
diff --git a/block/hisi_freq_ctl.c b/block/hisi_freq_ctl.c
deleted file mode 120000
index f166121..0000000
--- a/block/hisi_freq_ctl.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi_freq_ctl.c
\ No newline at end of file
diff --git a/block/hisi_freq_ctl.h b/block/hisi_freq_ctl.h
deleted file mode 120000
index 4415fe4..0000000
--- a/block/hisi_freq_ctl.h
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/block/hisi_freq_ctl.h
\ No newline at end of file
diff --git a/drivers/Makefile b/drivers/Makefile
index 29eb331..72028b9 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -176,33 +176,17 @@
 obj-$(CONFIG_PERF_EVENTS)	+= perf/
 obj-$(CONFIG_RAS)		+= ras/
 obj-$(CONFIG_THUNDERBOLT)	+= thunderbolt/
-obj-$(CONFIG_CORESIGHT)		+= hwtracing/hisi_coresight/
+obj-$(CONFIG_CORESIGHT)		+= hwtracing/coresight/
 obj-y				+= hwtracing/intel_th/
-obj-$(CONFIG_TEE_CFC)		+= hwtracing/hisi_coresight/
+obj-$(CONFIG_TEE_CFC)		+= hwtracing/coresight/
 obj-$(CONFIG_STM)		+= hwtracing/stm/
 obj-$(CONFIG_ANDROID)		+= android/
 obj-$(CONFIG_NVMEM)		+= nvmem/
 obj-$(CONFIG_FPGA)		+= fpga/
 
-ifneq ($(HI_VCODEC_VENC_HiVNA),true)
-obj-$(CONFIG_HI_VCODEC_VENC) += vcodec/hi_vcodec/venc/drv/venc/
-else
-ifneq ($(HI_VCODEC_VENC_V210),true)
 obj-$(CONFIG_HI_VCODEC_VENC) += vcodec/hi_vcodec/venc_hivna/drv/venc/
-else
-obj-$(CONFIG_HI_VCODEC_VENC) += vcodec/hi_vcodec/venc_hivna_v210/drv/venc/
-endif
-endif
 
-ifneq ($(HI_VCODEC_VDEC_HiVNA),true)
-obj-$(CONFIG_HI_VCODEC_VDEC) += vcodec/hi_vcodec/vdec/
-else
-ifneq ($(HI_VCODEC_VDEC_V210),true)
 obj-$(CONFIG_HI_VCODEC_VDEC) += vcodec/hi_vcodec/vdec_hivna/
-else
-obj-$(CONFIG_HI_VCODEC_VDEC) += vcodec/hi_vcodec/vdec_hivna_v210/
-endif
-endif
 
 ifeq ($(BOARD_CHARGER_ENABLE_DRM),true)
 obj-$(CONFIG_IMAGINATION_D5500_DRM_VCODEC)  += vcodec/imagination/D5500_DRM/
diff --git a/drivers/clk/hisi-clk-debug.c b/drivers/clk/hisi-clk-debug.c
deleted file mode 120000
index eae0d59..0000000
--- a/drivers/clk/hisi-clk-debug.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../vendor/hisi/ap/kernel/drivers/clk/hisi-clk-debug.c
\ No newline at end of file
diff --git a/drivers/clk/hisi-clk-debug.h b/drivers/clk/hisi-clk-debug.h
deleted file mode 120000
index f3f919b..0000000
--- a/drivers/clk/hisi-clk-debug.h
+++ /dev/null
@@ -1 +0,0 @@
-../../../../vendor/hisi/ap/kernel/drivers/clk/hisi-clk-debug.h
\ No newline at end of file
diff --git a/drivers/connectivity/Makefile b/drivers/connectivity/Makefile
index b95a36b..2d7b9fb 100644
--- a/drivers/connectivity/Makefile
+++ b/drivers/connectivity/Makefile
@@ -1 +1,21 @@
+export BOARD_HAVE_UNION_CONNECTIVITY := true
+export BOARD_HAVE_HISI_CONNECTIVITY := true
+export BOARD_HAVE_BCM_CONNECTIVITY := true
+export HAVE_HISI_FEATURE_IR := true
+
+export HI110X_ANDROID_VERSION := N
+export HI110X_ANDROID_O_ONLY  := true
+export HI110X_LOG_VERSION     := 2.0
+HI110X_CONNECTIVITY_PATH      := vendor/hisi/connectivity
+HI110X_WPA_SUPPLICANT_PATH    := external/wpa_supplicant_hisi
+
+CFG_CONNECTIVITY_HI1102_C02 := false
+CFG_CONNECTIVITY_HI1102_C03 := true
+export CFG_CONNECTIVITY_HI1102_C02
+export CFG_CONNECTIVITY_HI1102_C03
+
+export HI110X_FIRMWARE_BUILDIN := false
+
+export CONFIG_HI110X_KERNEL_MODULES_BUILD_SUPPORT=no
+
 obj-$(CONFIG_CONNECTIVITY_HI110X) += hisi/
diff --git a/drivers/cpufreq/cpufreq_interactive.c b/drivers/cpufreq/cpufreq_interactive.c
old mode 100644
new mode 100755
index a69c6f9..1989cba
--- a/drivers/cpufreq/cpufreq_interactive.c
+++ b/drivers/cpufreq/cpufreq_interactive.c
@@ -60,10 +60,6 @@
 	struct cpufreq_frequency_table *freq_table;
 	spinlock_t target_freq_lock; /*protects target freq */
 	unsigned int target_freq;
-#ifdef CONFIG_HISI_CPUFREQ
-	unsigned int min_freq;
-	unsigned int prev_cpu_load;
-#endif
 	unsigned int floor_freq;
 	u64 pol_floor_val_time; /* policy floor_validate_time */
 	u64 loc_floor_val_time; /* per-cpu floor_validate_time */
@@ -146,11 +142,6 @@
 	int boost_hmp_upthreshold;
 	/* boost hmp downthreshold, default 448 */
 	int boost_hmp_downthreshold;
-#endif
-
-#ifdef CONFIG_HISI_CPUFREQ
-	/* allow freq drop as soon as  freq unlock */
-	bool fast_ramp_down;
 #endif
 };
 
@@ -405,10 +396,6 @@
 	loadadjfreq = (unsigned int)cputime_speedadj * 100;
 	cpu_load = loadadjfreq / pcpu->policy->cur;
 	tunables->boosted = tunables->boost_val || now < tunables->boostpulse_endtime;
-#ifdef CONFIG_HISI_CPUFREQ
-	/* record last load */
-	pcpu->prev_cpu_load = cpu_load;
-#endif
 
 #ifdef CONFIG_HISI_HMPTH_INTERACTIVE
 	if (tunables->hmp_boosted && !tunables->boosted) {
@@ -586,8 +573,9 @@
 			pcpu = &per_cpu(cpuinfo, i);
 			pcpu->pol_hispeed_val_time = hvt;
 		}
-		trace_cpufreq_interactive_setspeed(cpu, max_freq, policy->cur);
 	}
+
+	trace_cpufreq_interactive_setspeed(cpu, max_freq, policy->cur);
 }
 
 static int cpufreq_interactive_speedchange_task(void *data)
@@ -1126,28 +1114,6 @@
 	return count;
 }
 
-#ifdef CONFIG_HISI_CPUFREQ
-#define MAX_BUF_LEN	16
-static ssize_t show_fast_ramp_down(struct cpufreq_interactive_tunables *tunables,
-		char *buf)
-{
-	return snprintf(buf, MAX_BUF_LEN, "%u\n", tunables->fast_ramp_down);
-}
-
-static ssize_t store_fast_ramp_down(struct cpufreq_interactive_tunables *tunables,
-		const char *buf, size_t count)
-{
-	int ret;
-	unsigned long val;
-
-	ret = kstrtoul(buf, 0, &val);
-	if (ret < 0)
-		return ret;
-	tunables->fast_ramp_down = val;
-	return count;
-}
-#endif
-
 #ifdef CONFIG_HISI_HMPTH_INTERACTIVE
 static ssize_t show_boost_hmp(struct cpufreq_interactive_tunables *tunables,
 		char *buf)
@@ -1257,9 +1223,6 @@
 show_store_gov_pol_sys(boostpulse_min_interval);
 #endif
 show_store_gov_pol_sys(io_is_busy);
-#ifdef CONFIG_HISI_CPUFREQ
-show_store_gov_pol_sys(fast_ramp_down);
-#endif
 #ifdef CONFIG_HISI_HMPTH_INTERACTIVE
 show_store_gov_pol_sys(boost_hmp);
 show_store_gov_pol_sys(boost_hmp_upthreshold);
@@ -1292,9 +1255,6 @@
 gov_sys_pol_attr_rw(boostpulse_min_interval);
 #endif
 gov_sys_pol_attr_rw(io_is_busy);
-#ifdef CONFIG_HISI_CPUFREQ
-gov_sys_pol_attr_rw(fast_ramp_down);
-#endif
 #ifdef CONFIG_HISI_HMPTH_INTERACTIVE
 gov_sys_pol_attr_rw(boost_hmp);
 gov_sys_pol_attr_rw(boost_hmp_upthreshold);
@@ -1324,9 +1284,6 @@
 	&boostpulse_min_interval_gov_sys.attr,
 #endif
 	&io_is_busy_gov_sys.attr,
-#ifdef CONFIG_HISI_CPUFREQ
-	&fast_ramp_down_gov_sys.attr,
-#endif
 #ifdef CONFIG_HISI_HMPTH_INTERACTIVE
 	&boost_hmp_gov_sys.attr,
 	&boost_hmp_upthreshold_gov_sys.attr,
@@ -1356,9 +1313,6 @@
 	&boostpulse_min_interval_gov_pol.attr,
 #endif
 	&io_is_busy_gov_pol.attr,
-#ifdef CONFIG_HISI_CPUFREQ
-	&fast_ramp_down_gov_pol.attr,
-#endif
 #ifdef CONFIG_HISI_HMPTH_INTERACTIVE
 	&boost_hmp_gov_pol.attr,
 	&boost_hmp_upthreshold_gov_pol.attr,
@@ -1394,111 +1348,6 @@
 	.notifier_call = cpufreq_interactive_idle_notifier,
 };
 
-#ifdef CONFIG_HISI_CPUFREQ
-static bool cpufreq_interactive_get_policy_freq(struct cpufreq_policy *policy,
-						unsigned int *freq, u64 *wall)
-{
-	unsigned int max_freq = 0;
-	unsigned int j;
-	u64 now;
-	unsigned int delta_time;
-	u64 cputime_speedadj;
-	int cpu_load;
-	struct cpufreq_interactive_cpuinfo *pcpu;
-	struct cpufreq_interactive_tunables *tunables;
-	unsigned int new_freq;
-	unsigned int loadadjfreq;
-	unsigned int index;
-	unsigned long flags;
-	bool need_update_freq = false;
-
-	pcpu = &per_cpu(cpuinfo, policy->cpu); /*lint !e64*/
-	down_read(&pcpu->enable_sem);
-	if (pcpu->governor_enabled) {
-		if (policy->min < pcpu->min_freq)
-			need_update_freq = true;
-	}
-	up_read(&pcpu->enable_sem);
-
-	if (!need_update_freq)
-		goto exit;
-
-	/*lint -e570 -e574*/
-	for_each_cpu(j, policy->cpus) {
-		pcpu = &per_cpu(cpuinfo, j);/*lint !e64*/
-
-		down_read(&pcpu->enable_sem);
-		if (pcpu->governor_enabled == 0) {
-			up_read(&pcpu->enable_sem);
-			continue;
-		}
-
-		spin_lock_irqsave(&pcpu->load_lock, flags);
-		now = update_load(j);
-		*wall = now;
-		delta_time = (unsigned int)(now - pcpu->cputime_speedadj_timestamp);
-		cputime_speedadj = pcpu->cputime_speedadj;
-		spin_unlock_irqrestore(&pcpu->load_lock, flags);
-
-		tunables = pcpu->policy->governor_data;
-		spin_lock_irqsave(&pcpu->target_freq_lock, flags);
-		/* use last load if not long enough since last evaluated */
-		if (delta_time * 2 <= (unsigned int)tunables->timer_rate) {
-			cpu_load = pcpu->prev_cpu_load;
-			loadadjfreq = cpu_load * pcpu->policy->cur;
-		} else {
-			do_div(cputime_speedadj, delta_time);
-			loadadjfreq = (unsigned int)cputime_speedadj * 100;
-			cpu_load = loadadjfreq / pcpu->policy->cur;
-			pcpu->prev_cpu_load = cpu_load;
-		}
-
-		tunables->boosted = tunables->boost_val || now < tunables->boostpulse_endtime;
-		if (cpu_load >= tunables->go_hispeed_load || tunables->boosted) {
-			if (pcpu->policy->cur < tunables->hispeed_freq) {
-				new_freq = tunables->hispeed_freq;
-			} else {
-				new_freq = choose_freq(pcpu, loadadjfreq);
-
-				if (new_freq < tunables->hispeed_freq)
-					new_freq = tunables->hispeed_freq;
-			}
-		} else {
-			new_freq = choose_freq(pcpu, loadadjfreq);
-			if (new_freq > tunables->hispeed_freq &&
-					pcpu->policy->cur < tunables->hispeed_freq)
-				new_freq = tunables->hispeed_freq;
-		}
-		spin_unlock_irqrestore(&pcpu->target_freq_lock, flags);
-
-		trace_cpufreq_interactive_fast_ramp(j, cpu_load, pcpu->target_freq,
-					 pcpu->policy->cur, new_freq);
-
-		if (new_freq > max_freq)
-			max_freq = new_freq;
-
-		up_read(&pcpu->enable_sem);
-	}
-	/*lint +e570 +e574*/
-
-	if (cpufreq_frequency_table_target(policy, policy->freq_table,
-					   max_freq, CPUFREQ_RELATION_C,
-					   &index)) {
-		need_update_freq = false;
-		goto exit;
-	}
-
-	max_freq = policy->freq_table[index].frequency;
-	*freq = max_freq;
-
-	if (max_freq >= policy->cur)
-		need_update_freq = false;
-
-exit:
-	return need_update_freq;
-}
-#endif
-
 static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
 		unsigned int event)
 {
@@ -1508,11 +1357,6 @@
 	struct cpufreq_frequency_table *freq_table;
 	struct cpufreq_interactive_tunables *tunables;
 	unsigned long flags;
-#ifdef CONFIG_HISI_CPUFREQ
-	bool need_update_freq = false;
-	unsigned int target_freq = UINT_MAX;
-	u64 wall = 0ULL;
-#endif
 
 	if (have_governor_per_policy())
 		tunables = policy->governor_data;
@@ -1626,10 +1470,6 @@
 			pcpu = &per_cpu(cpuinfo, j);
 			pcpu->policy = policy;
 			pcpu->target_freq = policy->cur;
-#ifdef CONFIG_HISI_CPUFREQ
-			pcpu->prev_cpu_load = 0;
-			pcpu->min_freq = policy->min;
-#endif
 			pcpu->freq_table = freq_table;
 			pcpu->floor_freq = pcpu->target_freq;
 			pcpu->pol_floor_val_time =
@@ -1672,13 +1512,6 @@
 
 #ifdef CONFIG_HISI_CPUFREQ
 		mutex_lock(&gov_lock);
-
-		if (tunables->fast_ramp_down) { /*lint !e613*/
-			need_update_freq = cpufreq_interactive_get_policy_freq(policy, &target_freq, &wall);
-			if (need_update_freq)
-				__cpufreq_driver_target(policy,
-						target_freq, CPUFREQ_RELATION_C);
-		}
 #endif
 
 		for_each_cpu(j, policy->cpus) {
@@ -1691,14 +1524,6 @@
 			}
 
 			spin_lock_irqsave(&pcpu->target_freq_lock, flags);
-#ifdef CONFIG_HISI_CPUFREQ
-			pcpu->min_freq = policy->min;
-			if (need_update_freq) {
-				pcpu->target_freq = target_freq;
-				pcpu->pol_floor_val_time = wall;
-			}
-#endif
-
 			if (policy->max < pcpu->target_freq)
 				pcpu->target_freq = policy->max;
 			else if (policy->min > pcpu->target_freq)
diff --git a/drivers/hisi/Kconfig b/drivers/hisi/Kconfig
index 7e4c877..7c71b2d 100644
--- a/drivers/hisi/Kconfig
+++ b/drivers/hisi/Kconfig
@@ -53,9 +53,6 @@
 source "drivers/hisi/test_spinlock/Kconfig"
 source "drivers/hisi/hhee/Kconfig"
 source "drivers/hisi/ics/Kconfig"
-source "drivers/hisi/hkip_test/Kconfig"
-source "drivers/hisi/gator/Kconfig"
-source "drivers/hisi/hisi_pmu_dump/Kconfig"
 source "drivers/hisi/dieid/Kconfig"
 
 endif #HISILICON_PLATFORM
diff --git a/drivers/hisi/gator b/drivers/hisi/gator
deleted file mode 120000
index 3b4ccda..0000000
--- a/drivers/hisi/gator
+++ /dev/null
@@ -1 +0,0 @@
-../../../../vendor/hisi/ap/kernel/drivers/hisi/gator
\ No newline at end of file
diff --git a/drivers/hisi/hkip_test b/drivers/hisi/hkip_test
deleted file mode 120000
index 83b786a..0000000
--- a/drivers/hisi/hkip_test
+++ /dev/null
@@ -1 +0,0 @@
-../../../../vendor/hisi/ap/kernel/drivers/hisi/hkip_test/
\ No newline at end of file
diff --git a/drivers/hisi/modem b/drivers/hisi/modem
new file mode 120000
index 0000000..12a25f7
--- /dev/null
+++ b/drivers/hisi/modem
@@ -0,0 +1 @@
+../../../../vendor/hisi/modem/kernel/drivers/hisi/modem
\ No newline at end of file
diff --git a/drivers/hisi/modem/Kconfig b/drivers/hisi/modem/Kconfig
deleted file mode 100755
index f87c951..0000000
--- a/drivers/hisi/modem/Kconfig
+++ /dev/null
@@ -1,27 +0,0 @@
-menu "Hisi Modem"
-config HISI_BALONG_MODEM
-	bool "Hisilicon ap+modem config"
-	default n
-	help
-	Hisilicon ap+modem config support.
-
-config HISI_BALONG_MODEM_HI3650
-	bool "Hisilicon ap+modem config"
-	default n
-	help
-	Hisilicon ap+modem config support.
-
-config BALONG_OAM_PS
-	tristate "support tlmsp tlps gumsp gups taf"
-	default n
-	help
-	tlmsp tlps gumsp gups taf acore image
-
-config VOWIFI_NEW_FRW
-	bool "vowifi android n&o frw diff"
-	default n
-	help
-	vowifi android n&o frw diff
-
-source "drivers/hisi/modem/drv/Kconfig"
-endmenu
diff --git a/drivers/hisi/modem/Makefile b/drivers/hisi/modem/Makefile
deleted file mode 100755
index 0733fbf..0000000
--- a/drivers/hisi/modem/Makefile
+++ /dev/null
@@ -1,71 +0,0 @@
-choose_variant_modem ?= $(TARGET_BUILD_VARIANT)
-ifneq ($(choose_variant_modem),)
-export choose_variant_modem
-endif
--include $(srctree)/drivers/hisi/modem/config/product/$(OBB_PRODUCT_NAME)/config/balong_product_config.mk
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/platform/ccore/$(CFG_PLATFORM)/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/platform/dsp/$(CFG_PLATFORM)/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/platform/acore/$(CFG_PLATFORM)/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/platform/acore/$(CFG_PLATFORM)/drv/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/platform/common/$(CFG_PLATFORM)/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/platform/common/$(CFG_PLATFORM)/soc/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/adrv/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/drv/acore/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/drv/common/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/drv/common/include/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/tl/drv/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/product/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/tl/oam/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/tl/lps/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/acore/sys/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/acore/drv/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/acore/msp/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/acore/pam/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/acore/guc_as/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/acore/guc_nas/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/common/sys/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/common/drv/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/common/msp/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/common/pam/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/common/guc_as/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/common/guc_nas/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/nv/common/tl_as
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/phy/lphy/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/config/nvim/include/gu/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/taf/common/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/include/taf/acore/
-subdir-ccflags-y += -I$(srctree)/drivers/hisi/modem/config/product/$(OBB_PRODUCT_NAME)/config
-
-ifeq ($(strip $(OBB_LLT_MDRV)),y)
-subdir-ccflags-y += -DDRV_BUILD_LLT
-endif
-
-
-ifeq ($(LLT_BUILD_GCOV), y)
-subdir-ccflags-y += -DDRV_BUILD_GCOV
-endif
-
-obj-$(CONFIG_HISI_BALONG_MODEM) +=drv/
-
-ifneq ($(chip_type),es)
-KBUILD_CFLAGS += -DCHIP_TYPE_CS=FEATURE_ON
-endif
-
-ifeq ($(secdog),rsa2048)
-KBUILD_CFLAGS += -DSECDOG_SUPPORT_RSA_2048=FEATURE_ON
-endif
-
-#add modem user
-# ifeq ($(TARGET_BUILD_VARIANT),user)
-ifeq ($(choose_variant_modem),user)
-KBUILD_CFLAGS += -DCHOOSE_MODEM_USER
-endif
-
-ifneq ($(OBB_SEPARATE),true)
-obj-$(CONFIG_HISI_BALONG_MODEM) +=oam/ ps/ taf/ 
-
-#ifeq ($(CFG_FEATURE_IMS),FEATURE_ON)
-obj-$(CONFIG_HISI_BALONG_MODEM) +=ims/
-#endif
-
-endif
diff --git a/drivers/hisi/modem/config/errlog b/drivers/hisi/modem/config/errlog
deleted file mode 120000
index f974405..0000000
--- a/drivers/hisi/modem/config/errlog
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/config/errlog
\ No newline at end of file
diff --git a/drivers/hisi/modem/config/nvim/include b/drivers/hisi/modem/config/nvim/include
deleted file mode 120000
index 9af62de..0000000
--- a/drivers/hisi/modem/config/nvim/include
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/config/nvim/include
\ No newline at end of file
diff --git a/drivers/hisi/modem/config/osa b/drivers/hisi/modem/config/osa
deleted file mode 120000
index 181f90f..0000000
--- a/drivers/hisi/modem/config/osa
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/config/osa
\ No newline at end of file
diff --git a/drivers/hisi/modem/config/product b/drivers/hisi/modem/config/product
deleted file mode 120000
index 43b3c12..0000000
--- a/drivers/hisi/modem/config/product
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/config/product
\ No newline at end of file
diff --git a/drivers/hisi/modem/drv b/drivers/hisi/modem/drv
deleted file mode 120000
index ec6fd23..0000000
--- a/drivers/hisi/modem/drv
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/modem/drv/acore/kernel/drivers/hisi/modem/drv
\ No newline at end of file
diff --git a/drivers/hisi/modem/ims b/drivers/hisi/modem/ims
deleted file mode 120000
index 0268eb6..0000000
--- a/drivers/hisi/modem/ims
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/thirdparty/ims/rtosck/acore/
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/adrv b/drivers/hisi/modem/include/adrv
deleted file mode 120000
index 0f73585..0000000
--- a/drivers/hisi/modem/include/adrv
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/include/adrv/
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/drv/acore b/drivers/hisi/modem/include/drv/acore
deleted file mode 120000
index 4970e66..0000000
--- a/drivers/hisi/modem/include/drv/acore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/drv/acore
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/drv/common b/drivers/hisi/modem/include/drv/common
deleted file mode 120000
index 88cf1c2..0000000
--- a/drivers/hisi/modem/include/drv/common
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/drv/common
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/med b/drivers/hisi/modem/include/med
deleted file mode 120000
index 82f6f4a..0000000
--- a/drivers/hisi/modem/include/med
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/include/med
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/nv/acore b/drivers/hisi/modem/include/nv/acore
deleted file mode 120000
index 72ab5fd..0000000
--- a/drivers/hisi/modem/include/nv/acore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/nv/acore
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/nv/common b/drivers/hisi/modem/include/nv/common
deleted file mode 120000
index 614fdda..0000000
--- a/drivers/hisi/modem/include/nv/common
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/nv/common
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/nv/gu b/drivers/hisi/modem/include/nv/gu
deleted file mode 120000
index a82b2e7..0000000
--- a/drivers/hisi/modem/include/nv/gu
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/nv/gu
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/nv/product b/drivers/hisi/modem/include/nv/product
deleted file mode 120000
index 340b1fe..0000000
--- a/drivers/hisi/modem/include/nv/product
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/nv/product
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/nv/tl b/drivers/hisi/modem/include/nv/tl
deleted file mode 120000
index c9b49ef..0000000
--- a/drivers/hisi/modem/include/nv/tl
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/nv/tl
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/oam b/drivers/hisi/modem/include/oam
deleted file mode 120000
index bf56b45..0000000
--- a/drivers/hisi/modem/include/oam
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/include/oam
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/phy/lphy b/drivers/hisi/modem/include/phy/lphy
deleted file mode 120000
index ff73891..0000000
--- a/drivers/hisi/modem/include/phy/lphy
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/phy/lphy
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/phy/wphy b/drivers/hisi/modem/include/phy/wphy
deleted file mode 120000
index b187be5..0000000
--- a/drivers/hisi/modem/include/phy/wphy
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/include/phy/wphy
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/ps b/drivers/hisi/modem/include/ps
deleted file mode 120000
index fb6ad1f..0000000
--- a/drivers/hisi/modem/include/ps
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/include/ps
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/sdio b/drivers/hisi/modem/include/sdio
deleted file mode 120000
index f331491..0000000
--- a/drivers/hisi/modem/include/sdio
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/include/sdio
\ No newline at end of file
diff --git a/drivers/hisi/modem/include/taf b/drivers/hisi/modem/include/taf
deleted file mode 120000
index 30a4b23..0000000
--- a/drivers/hisi/modem/include/taf
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/include/taf
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/Makefile b/drivers/hisi/modem/oam/Makefile
deleted file mode 100755
index ba7b775..0000000
--- a/drivers/hisi/modem/oam/Makefile
+++ /dev/null
@@ -1 +0,0 @@
-obj-y += gu/ lt/
diff --git a/drivers/hisi/modem/oam/comm/acore b/drivers/hisi/modem/oam/comm/acore
deleted file mode 120000
index 4c86e6d..0000000
--- a/drivers/hisi/modem/oam/comm/acore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/oam/comm/acore
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/comm/comm b/drivers/hisi/modem/oam/comm/comm
deleted file mode 120000
index 4d19596..0000000
--- a/drivers/hisi/modem/oam/comm/comm
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/oam/comm/comm
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/gu/Kbuild b/drivers/hisi/modem/oam/gu/Kbuild
deleted file mode 120000
index eaebece..0000000
--- a/drivers/hisi/modem/oam/gu/Kbuild
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/oam/build/gu/APP_CORE/Makefile_GUMSP
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/gu/acore b/drivers/hisi/modem/oam/gu/acore
deleted file mode 120000
index 380c214..0000000
--- a/drivers/hisi/modem/oam/gu/acore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/oam/gu/acore
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/gu/comm b/drivers/hisi/modem/oam/gu/comm
deleted file mode 120000
index ad08a2c..0000000
--- a/drivers/hisi/modem/oam/gu/comm
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/oam/gu/comm
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/inc b/drivers/hisi/modem/oam/inc
deleted file mode 120000
index d0bf0f0..0000000
--- a/drivers/hisi/modem/oam/inc
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/oam/inc
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/lt/Kbuild b/drivers/hisi/modem/oam/lt/Kbuild
deleted file mode 120000
index b8711c9..0000000
--- a/drivers/hisi/modem/oam/lt/Kbuild
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/oam/build/lt/APP_CORE/Makefile_TLMSP
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/lt/acore b/drivers/hisi/modem/oam/lt/acore
deleted file mode 120000
index b8a3ee8c..0000000
--- a/drivers/hisi/modem/oam/lt/acore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/oam/lt/acore
\ No newline at end of file
diff --git a/drivers/hisi/modem/oam/lt/comm b/drivers/hisi/modem/oam/lt/comm
deleted file mode 120000
index 47baf05..0000000
--- a/drivers/hisi/modem/oam/lt/comm
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/oam/lt/comm
\ No newline at end of file
diff --git a/drivers/hisi/modem/platform b/drivers/hisi/modem/platform
deleted file mode 120000
index 2ff4dcb..0000000
--- a/drivers/hisi/modem/platform
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/modem/platform
\ No newline at end of file
diff --git a/drivers/hisi/modem/ps/Makefile b/drivers/hisi/modem/ps/Makefile
deleted file mode 100755
index 866919a..0000000
--- a/drivers/hisi/modem/ps/Makefile
+++ /dev/null
@@ -1 +0,0 @@
-obj-y += gu/ tl/
diff --git a/drivers/hisi/modem/ps/comm/comm/acore b/drivers/hisi/modem/ps/comm/comm/acore
deleted file mode 120000
index bc7bbed..0000000
--- a/drivers/hisi/modem/ps/comm/comm/acore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../../vendor/hisi/modem/ps/comm/comm/acore
\ No newline at end of file
diff --git a/drivers/hisi/modem/ps/comm/comm/common b/drivers/hisi/modem/ps/comm/comm/common
deleted file mode 120000
index d990055..0000000
--- a/drivers/hisi/modem/ps/comm/comm/common
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../../vendor/hisi/modem/ps/comm/comm/common
\ No newline at end of file
diff --git a/drivers/hisi/modem/ps/gu/Kbuild b/drivers/hisi/modem/ps/gu/Kbuild
deleted file mode 120000
index 4e1872e..0000000
--- a/drivers/hisi/modem/ps/gu/Kbuild
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/ps/build/gu/APP_CORE/Makefile_GUPS
\ No newline at end of file
diff --git a/drivers/hisi/modem/ps/inc/gu b/drivers/hisi/modem/ps/inc/gu
deleted file mode 120000
index d030b07..0000000
--- a/drivers/hisi/modem/ps/inc/gu
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/ps/inc/gu
\ No newline at end of file
diff --git a/drivers/hisi/modem/ps/tl/Kbuild b/drivers/hisi/modem/ps/tl/Kbuild
deleted file mode 120000
index c64e633..0000000
--- a/drivers/hisi/modem/ps/tl/Kbuild
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/ps/build/tl/APP_CORE/Makefile_TLPS
\ No newline at end of file
diff --git a/drivers/hisi/modem/taf/Kbuild b/drivers/hisi/modem/taf/Kbuild
deleted file mode 120000
index a59f0ce..0000000
--- a/drivers/hisi/modem/taf/Kbuild
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/taf/build/gu/APP_CORE/Makefile_TAF
\ No newline at end of file
diff --git a/drivers/hisi/modem/taf/comm/src/acore b/drivers/hisi/modem/taf/comm/src/acore
deleted file mode 120000
index 71a6220..0000000
--- a/drivers/hisi/modem/taf/comm/src/acore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../../vendor/hisi/modem/taf/comm/src/acore
\ No newline at end of file
diff --git a/drivers/hisi/modem/taf/comm/src/mcore b/drivers/hisi/modem/taf/comm/src/mcore
deleted file mode 120000
index 7128855..0000000
--- a/drivers/hisi/modem/taf/comm/src/mcore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../../vendor/hisi/modem/taf/comm/src/mcore
\ No newline at end of file
diff --git a/drivers/hisi/modem/taf/inc b/drivers/hisi/modem/taf/inc
deleted file mode 120000
index 09b50aa..0000000
--- a/drivers/hisi/modem/taf/inc
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../vendor/hisi/modem/taf/inc
\ No newline at end of file
diff --git a/drivers/hisi/modem/taf/lt/inc b/drivers/hisi/modem/taf/lt/inc
deleted file mode 120000
index 5409669..0000000
--- a/drivers/hisi/modem/taf/lt/inc
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../vendor/hisi/modem/taf/lt/inc
\ No newline at end of file
diff --git a/drivers/hisi/modem/taf/lt/src/acore b/drivers/hisi/modem/taf/lt/src/acore
deleted file mode 120000
index 2722ed0..0000000
--- a/drivers/hisi/modem/taf/lt/src/acore
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../../../../vendor/hisi/modem/taf/lt/src/acore
\ No newline at end of file
diff --git a/drivers/mmc/core/hisi_mmc_bkops.c b/drivers/mmc/core/hisi_mmc_bkops.c
deleted file mode 120000
index 0f87675..0000000
--- a/drivers/mmc/core/hisi_mmc_bkops.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/mmc/core/hisi_mmc_bkops.c
\ No newline at end of file
diff --git a/drivers/mmc/host/sdhci-dwc-mshc.c b/drivers/mmc/host/sdhci-dwc-mshc.c
deleted file mode 120000
index 100bae2..0000000
--- a/drivers/mmc/host/sdhci-dwc-mshc.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/mmc/host/sdhci-dwc-mshc.c
\ No newline at end of file
diff --git a/drivers/mmc/host/sdhci-dwc-mshc.h b/drivers/mmc/host/sdhci-dwc-mshc.h
deleted file mode 120000
index a723e4e..0000000
--- a/drivers/mmc/host/sdhci-dwc-mshc.h
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/mmc/host/sdhci-dwc-mshc.h
\ No newline at end of file
diff --git a/drivers/pci/host/pcie-eyeparam.c b/drivers/pci/host/pcie-eyeparam.c
deleted file mode 120000
index 1189386..0000000
--- a/drivers/pci/host/pcie-eyeparam.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/pci/host/pcie-eyeparam.c
\ No newline at end of file
diff --git a/drivers/pci/host/pcie-kirin-poweron-hi3660.c b/drivers/pci/host/pcie-kirin-poweron-hi3660.c
deleted file mode 120000
index 0be08e7..0000000
--- a/drivers/pci/host/pcie-kirin-poweron-hi3660.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/pci/host/pcie-kirin-poweron-hi3660.c
\ No newline at end of file
diff --git a/drivers/pci/host/pcie-kirin-test.c b/drivers/pci/host/pcie-kirin-test.c
deleted file mode 120000
index 2a952e3..0000000
--- a/drivers/pci/host/pcie-kirin-test.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/pci/host/pcie-kirin-test.c
\ No newline at end of file
diff --git a/drivers/pci/host/pcie-slt.c b/drivers/pci/host/pcie-slt.c
deleted file mode 120000
index f90fe28..0000000
--- a/drivers/pci/host/pcie-slt.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/pci/host/pcie-slt.c
\ No newline at end of file
diff --git a/drivers/pci/host/pcie_kirin980.c b/drivers/pci/host/pcie_kirin980.c
deleted file mode 120000
index e981b6b..0000000
--- a/drivers/pci/host/pcie_kirin980.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/pci/host/pcie_kirin980.c
\ No newline at end of file
diff --git a/drivers/regulator/hisi_regulator_ip_debug.c b/drivers/regulator/hisi_regulator_ip_debug.c
deleted file mode 120000
index 161b989..0000000
--- a/drivers/regulator/hisi_regulator_ip_debug.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../vendor/hisi/ap/kernel/drivers/regulator/hisi_regulator_ip_debug.c
\ No newline at end of file
diff --git a/drivers/scsi/ufs/hisi_ufs_bkops.c b/drivers/scsi/ufs/hisi_ufs_bkops.c
deleted file mode 120000
index bf89a6c..0000000
--- a/drivers/scsi/ufs/hisi_ufs_bkops.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/scsi/ufs/hisi_ufs_bkops.c
\ No newline at end of file
diff --git a/drivers/scsi/ufs/ufs_block_test.c b/drivers/scsi/ufs/ufs_block_test.c
deleted file mode 100644
index 7310db3..0000000
--- a/drivers/scsi/ufs/ufs_block_test.c
+++ /dev/null
@@ -1,1576 +0,0 @@
-/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt"\n"
-
-#include <linux/async.h>
-#include <linux/atomic.h>
-#include <linux/blkdev.h>
-#include <linux/debugfs.h>
-#include <linux/delay.h>
-#include <linux/module.h>
-#include <linux/test-iosched.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_host.h>
-#include <linux/devfreq.h>
-#include "ufshci.h"
-#include "ufshcd.h"
-#include "ufs.h"
-
-#define MODULE_NAME "ufs_block_test"
-#define UFS_TEST_BLK_DEV_TYPE_PREFIX "sd"
-
-#define TEST_MAX_BIOS_PER_REQ		128
-#define TEST_DEFAULT_SECTOR_RANGE		(1024*1024)	/* 512MB */
-#define LARGE_PRIME_1	1103515367
-#define LARGE_PRIME_2	35757
-#define MAGIC_SEED	7
-#define DEFAULT_NUM_OF_BIOS		2
-#define LONG_SEQUENTIAL_MIXED_TIMOUT_MS 100000
-#define THREADS_COMPLETION_TIMOUT msecs_to_jiffies(10000)	/* 10 sec */
-#define MAX_PARALLEL_QUERIES 33
-#define RANDOM_REQUEST_THREADS 4
-#define LUN_DEPTH_TEST_SIZE 9
-#define SECTOR_SIZE	512
-#define NUM_UNLUCKY_RETRIES	10
-
-extern struct gendisk *scsi_gendisk_get_from_dev(struct device *dev);
-/*
- * this defines the density of random requests in the address space, and
- * it represents the ratio between accessed sectors and non-accessed sectors
- */
-#define LONG_RAND_TEST_REQ_RATIO	64
-/* request queue limitation is 128 requests, and we leave 10 spare requests */
-#define QUEUE_MAX_REQUESTS 118
-#define MB_MSEC_RATIO_APPROXIMATION ((1024 * 1024) / 1000)
-/* actual number of MiB in test multiplied by 10, for single digit precision*/
-#define BYTE_TO_MB_x_10(x) ((x * 10) / (1024 * 1024))
-/* extract integer value */
-#define LONG_TEST_SIZE_INTEGER(x) (BYTE_TO_MB_x_10(x) / 10)
-/* and calculate the MiB value fraction */
-#define LONG_TEST_SIZE_FRACTION(x) (BYTE_TO_MB_x_10(x) - \
-		(LONG_TEST_SIZE_INTEGER(x) * 10))
-/* translation mask from sectors to block */
-#define SECTOR_TO_BLOCK_MASK 0x7
-
-/*cppcheck-suppress * */
-#define TEST_OPS(test_name, upper_case_name)				\
-static int ufs_test_ ## test_name ## _show(struct seq_file *file,	\
-		void *data)						\
-{ return ufs_test_show(file, UFS_TEST_ ## upper_case_name); }		\
-static int ufs_test_ ## test_name ## _open(struct inode *inode,		\
-		struct file *file)					\
-{ return single_open(file, ufs_test_ ## test_name ## _show,		\
-		inode->i_private); }					\
-static ssize_t ufs_test_ ## test_name ## _write(struct file *file,	\
-		const char __user *buf, size_t count, loff_t *ppos)	\
-{ return ufs_test_write(file, buf, count, ppos,				\
-			UFS_TEST_ ## upper_case_name); }		\
-static const struct file_operations ufs_test_ ## test_name ## _ops = {	\
-	.open = ufs_test_ ## test_name ## _open,			\
-	.read = seq_read,						\
-	.write = ufs_test_ ## test_name ## _write,			\
-};
-
-#define add_test(utd, test_name, upper_case_name)			\
-ufs_test_add_test(utd, UFS_TEST_ ## upper_case_name, "ufs_test_"#test_name,\
-				&(ufs_test_ ## test_name ## _ops));	\
-
-enum ufs_test_testcases {
-	UFS_TEST_WRITE_READ_TEST,
-	UFS_TEST_MULTI_QUERY,
-	UFS_TEST_DATA_INTEGRITY,
-
-	UFS_TEST_LONG_SEQUENTIAL_READ,
-	UFS_TEST_LONG_SEQUENTIAL_WRITE,
-	UFS_TEST_LONG_SEQUENTIAL_MIXED,
-
-	UFS_TEST_LONG_RANDOM_READ,
-	UFS_TEST_LONG_RANDOM_WRITE,
-
-	UFS_TEST_PARALLEL_READ_AND_WRITE,
-	UFS_TEST_LUN_DEPTH,
-
-	UFS_TEST_READ,
-	NUM_TESTS,
-};
-
-enum ufs_test_stage {
-	DEFAULT,
-	UFS_TEST_ERROR,
-
-	UFS_TEST_LONG_SEQUENTIAL_MIXED_STAGE1,
-	UFS_TEST_LONG_SEQUENTIAL_MIXED_STAGE2,
-
-	UFS_TEST_LUN_DEPTH_TEST_RUNNING,
-	UFS_TEST_LUN_DEPTH_DONE_ISSUING_REQ,
-};
-
-/* device test */
-static struct blk_dev_test_type *ufs_bdt;
-
-struct ufs_test_data {
-	/* Data structure for debugfs dentrys */
-	struct dentry **test_list;
-	/*
-	 * Data structure containing individual test information, including
-	 * self-defined specific data
-	 */
-	struct test_info test_info;
-
-	/* A wait queue for OPs to complete */
-	wait_queue_head_t wait_q;
-	/* a flag for write compleation */
-	bool queue_complete;
-	/*
-	 * To determine the number of r/w bios. When seed = 0, random is
-	 * disabled and 2 BIOs are written.
-	 */
-	unsigned int random_test_seed;
-	struct dentry *random_test_seed_dentry;
-
-	/* A counter for the number of test requests completed */
-	unsigned int completed_req_count;
-	/* Test stage */
-	enum ufs_test_stage test_stage;
-
-	/* Parameters for maintaining multiple threads */
-	int fail_threads;
-	atomic_t outstanding_threads;
-	struct completion outstanding_complete;
-
-	/* user-defined size of address space in which to perform I/O */
-	u32 sector_range;
-	/* total number of requests to be submitted in long test */
-	u32 long_test_num_reqs;
-
-	struct test_iosched *test_iosched;
-};
-
-static int ufs_test_add_test(struct ufs_test_data *utd,
-			     enum ufs_test_testcases test_id, char *test_str,
-			     const struct file_operations *test_fops)
-{
-	int ret = 0;
-	struct dentry *tests_root;
-
-	if (test_id >= NUM_TESTS)
-		return -EINVAL;
-
-	tests_root = utd->test_iosched->debug.debug_tests_root;
-	if (!tests_root) {
-		pr_err("%s: Failed to create debugfs root.", __func__);
-		return -EINVAL;
-	}
-
-	utd->test_list[test_id] = debugfs_create_file(test_str,
-						      S_IRUGO | S_IWUGO,
-						      tests_root, utd,
-						      test_fops);
-	if (!utd->test_list[test_id]) {
-		pr_err("%s: Could not create the test %s", test_str, __func__);
-		ret = -ENOMEM;
-	}
-	return ret;
-}
-
-/**
- * struct test_scenario - keeps scenario data that creates unique pattern
- * @td: per test reference
- * @direction: pattern initial direction
- * @toggle_direction: every toggle_direction requests switch direction for one
- *			request
- * @total_req: number of request to issue
- * @rnd_req: should request issue to random LBA with random size
- * @run_q: the maximum number of request to hold in queue (before run_queue())
- */
-struct test_scenario {
-	struct test_iosched *test_iosched;
-	int direction;
-	int toggle_direction;
-	int total_req;
-	bool rnd_req;
-	int run_q;
-};
-
-enum scenario_id {
-	/* scenarios for parallel read and write test */
-	SCEN_RANDOM_READ_50,
-	SCEN_RANDOM_WRITE_50,
-
-	SCEN_RANDOM_READ_32_NO_FLUSH,
-	SCEN_RANDOM_WRITE_32_NO_FLUSH,
-
-	SCEN_RANDOM_MAX,
-};
-
-static struct test_scenario test_scenario[SCEN_RANDOM_MAX] = {
-	{NULL, READ, 0, 50, true, 5},	/* SCEN_RANDOM_READ_50 */
-	{NULL, WRITE, 0, 50, true, 5},	/* SCEN_RANDOM_WRITE_50 */
-
-	/* SCEN_RANDOM_READ_32_NO_FLUSH */
-	{NULL, READ, 0, 32, true, 64},
-	/* SCEN_RANDOM_WRITE_32_NO_FLUSH */
-	{NULL, WRITE, 0, 32, true, 64},
-};
-
-static
-struct test_scenario *get_scenario(struct test_iosched *test_iosched,
-				   enum scenario_id id)
-{
-	struct test_scenario *ret = &test_scenario[id];
-
-	ret->test_iosched = test_iosched;
-	return ret;
-}
-
-static char *ufs_test_get_test_case_str(int testcase)
-{
-	switch (testcase) {
-	case UFS_TEST_WRITE_READ_TEST:
-		return "UFS write read test";
-	case UFS_TEST_MULTI_QUERY:
-		return "Test multiple queries at the same time";
-	case UFS_TEST_LONG_RANDOM_READ:
-		return "UFS long random read test";
-	case UFS_TEST_LONG_RANDOM_WRITE:
-		return "UFS long random write test";
-	case UFS_TEST_DATA_INTEGRITY:
-		return "UFS random data integrity test";
-	case UFS_TEST_LONG_SEQUENTIAL_READ:
-		return "UFS long sequential read test";
-	case UFS_TEST_LONG_SEQUENTIAL_WRITE:
-		return "UFS long sequential write test";
-	case UFS_TEST_LONG_SEQUENTIAL_MIXED:
-		return "UFS long sequential mixed test";
-	case UFS_TEST_PARALLEL_READ_AND_WRITE:
-		return "UFS parallel read and write test";
-	case UFS_TEST_LUN_DEPTH:
-		return "UFS LUN depth test";
-	case UFS_TEST_READ:
-		return "UFS test READ";
-	}
-	return "Unknown test";
-}
-
-static unsigned int ufs_test_pseudo_random_seed(unsigned int *seed_number,
-						unsigned int min_val,
-						unsigned int max_val)
-{
-	int ret = 0;
-
-	if (!seed_number)
-		return 0;
-
-	*seed_number = ((unsigned int)(((unsigned long)*seed_number
-					* (unsigned long)LARGE_PRIME_1) +
-				       LARGE_PRIME_2));
-	ret = (unsigned int)((*seed_number) % max_val);
-
-	return (ret > min_val ? ret : min_val);
-}
-
-/**
- * pseudo_rnd_sector_and_size - provides random sector and size for test request
- * @seed: random seed
- * @min_start_sector: minimum lba
- * @start_sector: pointer for output start sector
- * @num_of_bios: pointer for output number of bios
- *
- * Note that for UFS sector number has to be aligned with block size. Since
- * scsi will send the block number as the LBA.
- */
-static void pseudo_rnd_sector_and_size(struct ufs_test_data *utd,
-				       unsigned int *start_sector,
-				       unsigned int *num_of_bios)
-{
-	struct test_iosched *tios = utd->test_iosched;
-	u32 min_start_sector = tios->start_sector;
-	unsigned int max_sec = min_start_sector + utd->sector_range;
-
-	do {
-		*start_sector =
-		    ufs_test_pseudo_random_seed(&utd->random_test_seed, 1,
-						max_sec);
-		*num_of_bios =
-		    ufs_test_pseudo_random_seed(&utd->random_test_seed, 1,
-						TEST_MAX_BIOS_PER_REQ);
-		if (!(*num_of_bios))
-			*num_of_bios = 1;
-	} while ((*start_sector < min_start_sector) ||
-		 (*start_sector + (*num_of_bios * TEST_BIO_SIZE)) > max_sec);
-	/*
-	 * The test-iosched API is working with sectors 512b, while UFS LBA
-	 * is in blocks (4096). Thus the last 3 bits has to be cleared.
-	 */
-	*start_sector &= ~SECTOR_TO_BLOCK_MASK;
-}
-
-static void ufs_test_pseudo_rnd_size(unsigned int *seed,
-				     unsigned int *num_of_bios)
-{
-	*num_of_bios = ufs_test_pseudo_random_seed(seed, 1,
-						   TEST_MAX_BIOS_PER_REQ);
-	if (!(*num_of_bios))
-		*num_of_bios = DEFAULT_NUM_OF_BIOS;
-}
-
-static inline int ufs_test_pm_runtime_cfg_sync(struct test_iosched *tios,
-					       bool enable)
-{
-	struct scsi_device *sdev;
-	struct ufs_hba *hba;
-	int ret;
-
-	BUG_ON(!tios || !tios->req_q || !tios->req_q->queuedata);
-	sdev = (struct scsi_device *)tios->req_q->queuedata;
-	BUG_ON(!sdev->host);
-	hba = shost_priv(sdev->host);
-	BUG_ON(!hba);
-
-	if (enable) {
-		ret = pm_runtime_get_sync(hba->dev);
-		/* Positive non-zero return values are not errors */
-		if (ret < 0) {
-			pr_err("%s: pm_runtime_get_sync failed, ret=%d\n",
-			       __func__, ret);
-			return ret;
-		}
-		return 0;
-	}
-	pm_runtime_put_sync(hba->dev);
-	return 0;
-}
-
-static int ufs_test_show(struct seq_file *file, int test_case)
-{
-	char *test_description;
-
-	switch (test_case) {
-	case UFS_TEST_WRITE_READ_TEST:
-		test_description = "\nufs_write_read_test\n"
-		    "=========\n"
-		    "Description:\n"
-		    "This test write once a random block and than reads it to "
-		    "verify its content. Used to debug first time transactions.\n";
-		break;
-	case UFS_TEST_MULTI_QUERY:
-		test_description = "Test multiple queries at the same time.\n";
-		break;
-	case UFS_TEST_DATA_INTEGRITY:
-		test_description = "\nufs_data_integrity_test\n"
-		    "=========\n"
-		    "Description:\n"
-		    "This test writes 118 requests of size 4KB to randomly chosen LBAs.\n"
-		    "The test then reads from these LBAs and checks that the\n"
-		    "correct buffer has been read.\n";
-		break;
-	case UFS_TEST_LONG_SEQUENTIAL_READ:
-		test_description = "\nufs_long_sequential_read_test\n"
-		    "=========\n"
-		    "Description:\n"
-		    "This test runs the following scenarios\n"
-		    "- Long Sequential Read Test: this test measures read "
-		    "throughput at the driver level by sequentially reading many "
-		    "large requests.\n";
-		break;
-	case UFS_TEST_LONG_RANDOM_READ:
-		test_description = "\nufs_long_random_read_test\n"
-		    "=========\n"
-		    "Description:\n"
-		    "This test runs the following scenarios\n"
-		    "- Long Random Read Test: this test measures read "
-		    "IOPS at the driver level by reading many 4KB requests"
-		    "with random LBAs\n";
-		break;
-	case UFS_TEST_LONG_SEQUENTIAL_WRITE:
-		test_description = "\nufs_long_sequential_write_test\n"
-		    "=========\n"
-		    "Description:\n"
-		    "This test runs the following scenarios\n"
-		    "- Long Sequential Write Test: this test measures write "
-		    "throughput at the driver level by sequentially writing many "
-		    "large requests\n";
-		break;
-	case UFS_TEST_LONG_RANDOM_WRITE:
-		test_description = "\nufs_long_random_write_test\n"
-		    "=========\n"
-		    "Description:\n"
-		    "This test runs the following scenarios\n"
-		    "- Long Random Write Test: this test measures write "
-		    "IOPS at the driver level by writing many 4KB requests"
-		    "with random LBAs\n";
-		break;
-	case UFS_TEST_LONG_SEQUENTIAL_MIXED:
-		test_description = "\nufs_long_sequential_mixed_test_read\n"
-		    "=========\n"
-		    "Description:\n"
-		    "The test will verify correctness of sequential data pattern "
-		    "written to the device while new data (with same pattern) is "
-		    "written simultaneously.\n"
-		    "First this test will run a long sequential write scenario."
-		    "This first stage will write the pattern that will be read "
-		    "later. Second, sequential read requests will read and "
-		    "compare the same data. The second stage reads, will issue in "
-		    "Parallel to write requests with the same LBA and size.\n"
-		    "NOTE: The test requires a long timeout.\n";
-		break;
-	case UFS_TEST_PARALLEL_READ_AND_WRITE:
-		test_description = "\nufs_test_parallel_read_and_write\n"
-		    "=========\n"
-		    "Description:\n"
-		    "This test initiate two threads. Each thread is issuing "
-		    "multiple random requests. One thread will issue only read "
-		    "requests, while the other will only issue write requests.\n";
-		break;
-	case UFS_TEST_LUN_DEPTH:
-		test_description = "\nufs_test_lun_depth\n"
-		    "=========\n"
-		    "Description:\n"
-		    "This test is trying to stress the edge cases of the UFS "
-		    "device queue. This queue has two such edges, the total queue "
-		    "depth and the command per LU. To test those edges properly, "
-		    "two deviations from the edge in addition to the edge are "
-		    "tested as well. One deviation will be fixed (1), and the "
-		    "second will be picked randomly.\n"
-		    "The test will fill a request queue with random read "
-		    "requests. The amount of request will vary each iteration and "
-		    "will be either the one of the edges or the sum of this edge "
-		    "with one deviations.\n"
-		    "The test will test for each iteration once only reads and "
-		    "once only writes.\n";
-		break;
-	case UFS_TEST_READ:
-		test_description = "\nufs_test_read\n";
-		break;
-	default:
-		test_description = "Unknown test";
-	}
-
-	seq_puts(file, test_description);
-	return 0;
-}
-
-static struct gendisk *ufs_test_get_rq_disk(struct test_iosched *test_iosched)
-{
-	struct request_queue *req_q = test_iosched->req_q;
-	struct scsi_device *sd;
-
-	if (!req_q) {
-		pr_info("%s: Could not fetch request_queue", __func__);
-		goto exit;
-	}
-
-	sd = (struct scsi_device *)req_q->queuedata;
-	if (!sd) {
-		pr_info("%s: req_q is missing required queuedata", __func__);
-		goto exit;
-	}
-
-	return scsi_gendisk_get_from_dev(&sd->sdev_gendev);
-
-exit:
-	return NULL;
-}
-
-static int ufs_test_put_gendisk(struct test_iosched *test_iosched)
-{
-	struct request_queue *req_q = test_iosched->req_q;
-	struct scsi_device *sd;
-	int ret = 0;
-
-	if (!req_q) {
-		pr_info("%s: Could not fetch request_queue", __func__);
-		ret = -EINVAL;
-		goto exit;
-	}
-
-	sd = (struct scsi_device *)req_q->queuedata;
-	if (!sd) {
-		pr_info("%s: req_q is missing required queuedata", __func__);
-		ret = -EINVAL;
-		goto exit;
-	}
-
-	scsi_gendisk_put(&sd->sdev_gendev);
-
-exit:
-	return ret;
-}
-
-static int ufs_test_prepare(struct test_iosched *tios)
-{
-	return ufs_test_pm_runtime_cfg_sync(tios, true);
-}
-
-static int ufs_test_post(struct test_iosched *tios)
-{
-	int ret;
-
-	ret = ufs_test_pm_runtime_cfg_sync(tios, false);
-	if (!ret)
-		ret = ufs_test_put_gendisk(tios);
-
-	return ret;
-}
-
-static int ufs_test_check_result(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	if (utd->test_stage == UFS_TEST_ERROR) {
-		pr_err("%s: An error occurred during the test.", __func__);
-		return TEST_FAILED;
-	}
-
-	if (utd->fail_threads != 0) {
-		pr_err("%s: About %d threads failed during execution.",
-		       __func__, utd->fail_threads);
-		return utd->fail_threads;
-	}
-
-	return 0;
-}
-
-static bool ufs_write_read_completion(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	if (!utd->queue_complete) {
-		utd->queue_complete = true;
-		wake_up(&utd->wait_q);
-		return false;
-	}
-	return true;
-}
-
-static int ufs_test_run_write_read_test(struct test_iosched *test_iosched)
-{
-	int ret = 0;
-	unsigned int start_sec;
-	unsigned int num_bios;
-	struct request_queue *q = test_iosched->req_q;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	start_sec = test_iosched->start_sector + sizeof(int) * BIO_U32_SIZE
-	    * test_iosched->num_of_write_bios;
-	if (utd->random_test_seed != 0)
-		ufs_test_pseudo_rnd_size(&utd->random_test_seed, &num_bios);
-	else
-		num_bios = DEFAULT_NUM_OF_BIOS;
-
-	/* Adding a write request */
-	pr_info("%s: Adding a write request with %d bios to Q, req_id=%d",
-		__func__, num_bios, test_iosched->wr_rd_next_req_id);
-
-	utd->queue_complete = false;
-	ret = test_iosched_add_wr_rd_test_req(test_iosched, 0, WRITE, start_sec,
-					      num_bios, TEST_PATTERN_5A, NULL);
-	if (ret) {
-		pr_err("%s: failed to add a write request", __func__);
-		return ret;
-	}
-
-	/* waiting for the write request to finish */
-	blk_post_runtime_resume(q, 0);
-	wait_event(utd->wait_q, utd->queue_complete);
-
-	/* Adding a read request */
-	pr_info("%s: Adding a read request to Q", __func__);
-
-	ret = test_iosched_add_wr_rd_test_req(test_iosched, 0, READ, start_sec,
-					      num_bios, TEST_PATTERN_5A, NULL);
-	if (ret) {
-		pr_err("%s: failed to add a read request", __func__);
-		return ret;
-	}
-
-	blk_post_runtime_resume(q, 0);
-	return ret;
-}
-
-static void ufs_test_thread_complete(struct ufs_test_data *utd, int result)
-{
-	if (result)
-		utd->fail_threads++;
-	atomic_dec(&utd->outstanding_threads);
-	if (!atomic_read(&utd->outstanding_threads))
-		complete(&utd->outstanding_complete);
-}
-
-#if 1
-static void ufs_test_random_async_query(void *data, async_cookie_t cookie)
-{
-	int op;
-	struct test_iosched *test_iosched = data;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-	struct scsi_device *sdev;
-	struct ufs_hba *hba;
-	int buff_len = QUERY_DESC_UNIT_MAX_SIZE;
-	u8 desc_buf[QUERY_DESC_UNIT_MAX_SIZE];
-	bool flag;
-	u32 att;
-	int ret = 0;
-
-	sdev = (struct scsi_device *)test_iosched->req_q->queuedata;
-	BUG_ON(!sdev->host);
-	hba = shost_priv(sdev->host);
-	BUG_ON(!hba);
-
-	op = ufs_test_pseudo_random_seed(&utd->random_test_seed, 1, 8);
-	/*
-	 * When write data (descriptor/attribute/flag) queries are issued,
-	 * regular work and functionality must be kept. The data is read
-	 * first to make sure the original state is restored.
-	 */
-	switch (op) {
-	case UPIU_QUERY_OPCODE_READ_DESC:
-	case UPIU_QUERY_OPCODE_WRITE_DESC:
-		ret =
-		    ufshcd_query_descriptor_retry(hba,
-						  UPIU_QUERY_OPCODE_READ_DESC,
-						  QUERY_DESC_IDN_UNIT, 0, 0,
-						  desc_buf, &buff_len);
-		break;
-	case UPIU_QUERY_OPCODE_WRITE_ATTR:
-	case UPIU_QUERY_OPCODE_READ_ATTR:
-		ret = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_READ_ATTR,
-					QUERY_ATTR_IDN_EE_CONTROL, 0, 0, &att);
-		if (ret || op == UPIU_QUERY_OPCODE_READ_ATTR)
-			break;
-
-		ret = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_WRITE_ATTR,
-					QUERY_ATTR_IDN_EE_CONTROL, 0, 0, &att);
-		break;
-	case UPIU_QUERY_OPCODE_READ_FLAG:
-	case UPIU_QUERY_OPCODE_SET_FLAG:
-	case UPIU_QUERY_OPCODE_CLEAR_FLAG:
-	case UPIU_QUERY_OPCODE_TOGGLE_FLAG:
-		/* We read the QUERY_FLAG_IDN_BKOPS_EN and restore it later */
-		ret = ufshcd_query_flag(hba, UPIU_QUERY_OPCODE_READ_FLAG,
-					QUERY_FLAG_IDN_BKOPS_EN, &flag);
-		if (ret || op == UPIU_QUERY_OPCODE_READ_FLAG)
-			break;
-
-		/* After changing the flag we have to change it back */
-		ret = ufshcd_query_flag(hba, op, QUERY_FLAG_IDN_BKOPS_EN, NULL);
-		if ((op == UPIU_QUERY_OPCODE_SET_FLAG && flag) ||
-		    (op == UPIU_QUERY_OPCODE_CLEAR_FLAG && !flag))
-			/* No need to change it back */
-			break;
-
-		if (flag)
-			ret |= ufshcd_query_flag(hba,
-						 UPIU_QUERY_OPCODE_SET_FLAG,
-						 QUERY_FLAG_IDN_BKOPS_EN, NULL);
-		else
-			ret |= ufshcd_query_flag(hba,
-						 UPIU_QUERY_OPCODE_CLEAR_FLAG,
-						 QUERY_FLAG_IDN_BKOPS_EN, NULL);
-		break;
-	default:
-		pr_err("%s: Random error unknown op %d", __func__, op);
-	}
-
-	if (ret)
-		pr_err("%s: Query thread with op %d, failed with err %d.",
-		       __func__, op, ret);
-
-	ufs_test_thread_complete(utd, ret);
-}
-#endif
-static void scenario_free_end_io_fn(struct request *rq, int err)
-{
-	struct test_request *test_rq;
-	struct test_iosched *test_iosched = rq->q->elevator->elevator_data;
-
-	BUG_ON(!rq);
-	test_rq = (struct test_request *)rq->elv.priv[0];
-	BUG_ON(!test_rq);
-
-	spin_lock_irq(&test_iosched->lock);
-	test_iosched->dispatched_count--;
-	list_del_init(&test_rq->queuelist);
-	__blk_put_request(test_iosched->req_q, test_rq->rq);
-	spin_unlock_irq(&test_iosched->lock);
-
-	test_iosched_free_test_req_data_buffer(test_rq);
-	kfree(test_rq);
-
-	if (err)
-		pr_err("%s: request %d completed, err=%d", __func__,
-		       test_rq->req_id, err);
-
-	check_test_completion(test_iosched);
-}
-
-static bool ufs_test_multi_thread_completion(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-	return atomic_read(&utd->outstanding_threads) <= 0 &&
-	    utd->test_stage != UFS_TEST_LUN_DEPTH_TEST_RUNNING;
-}
-
-static bool long_rand_test_check_completion(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	if (utd->completed_req_count > utd->long_test_num_reqs) {
-		pr_err
-		    ("%s: Error: Completed more requests than total test requests.\nTerminating test.",
-		     __func__);
-		return true;
-	}
-	return utd->completed_req_count == utd->long_test_num_reqs;
-}
-
-static bool long_seq_test_check_completion(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	if (utd->completed_req_count > utd->long_test_num_reqs) {
-		pr_err
-		    ("%s: Error: Completed more requests than total test requests",
-		     __func__);
-		pr_err("%s: Terminating test.", __func__);
-		return true;
-	}
-	return utd->completed_req_count == utd->long_test_num_reqs;
-}
-
-/**
- * ufs_test_toggle_direction() - decides whether toggling is
- * needed. Toggle factor zero means no toggling.
- *
- * toggle_factor - iteration to toggle = toggling frequency
- * iteration - the current request iteration
- *
- * Returns nonzero if toggling is needed, and 0 when toggling is
- * not needed.
- */
-static inline int ufs_test_toggle_direction(int toggle_factor, int iteration)
-{
-	if (!toggle_factor)
-		return 0;
-
-	return !(iteration % toggle_factor);
-}
-
-static void ufs_test_run_scenario(void *data, async_cookie_t cookie)
-{
-	struct test_scenario *ts = (struct test_scenario *)data;
-	struct test_iosched *test_iosched = ts->test_iosched;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-	int start_sec;
-	int i;
-	int ret = 0;
-
-	BUG_ON(!ts);
-	start_sec = ts->test_iosched->start_sector;
-
-	for (i = 0; i < ts->total_req; i++) {
-		int num_bios = DEFAULT_NUM_OF_BIOS;
-		int direction;
-
-		if (ufs_test_toggle_direction(ts->toggle_direction, i))
-			direction = (ts->direction == WRITE) ? READ : WRITE;
-		else
-			direction = ts->direction;
-
-		/* use randomly generated requests */
-		if (ts->rnd_req && utd->random_test_seed != 0)
-			pseudo_rnd_sector_and_size(utd, &start_sec, &num_bios);
-
-		ret = test_iosched_add_wr_rd_test_req(test_iosched, 0,
-						      direction, start_sec,
-						      num_bios, TEST_PATTERN_5A,
-						      scenario_free_end_io_fn);
-		if (ret) {
-			pr_err("%s: failed to create request", __func__);
-			break;
-		}
-
-		/*
-		 * We want to run the queue every run_q requests, or,
-		 * when the requests pool is exhausted
-		 */
-
-		if (test_iosched->dispatched_count >= QUEUE_MAX_REQUESTS ||
-		    (ts->run_q && !(i % ts->run_q)))
-			blk_post_runtime_resume(test_iosched->req_q, 0);
-	}
-
-	blk_post_runtime_resume(test_iosched->req_q, 0);
-	ufs_test_thread_complete(utd, ret);
-}
-
-static int ufs_test_run_multi_query_test(struct test_iosched *test_iosched)
-{
-	int i;
-	struct ufs_test_data *utd;
-	struct scsi_device *sdev;
-	struct ufs_hba *hba;
-
-	BUG_ON(!test_iosched || !test_iosched->req_q ||
-	       !test_iosched->req_q->queuedata);
-	sdev = (struct scsi_device *)test_iosched->req_q->queuedata;
-	BUG_ON(!sdev->host);
-	hba = shost_priv(sdev->host);
-	BUG_ON(!hba);
-
-	utd = test_iosched->blk_dev_test_data;
-	atomic_set(&utd->outstanding_threads, 0);
-	utd->fail_threads = 0;
-	init_completion(&utd->outstanding_complete);
-	for (i = 0; i < MAX_PARALLEL_QUERIES; ++i) {
-		atomic_inc(&utd->outstanding_threads);
-		async_schedule(ufs_test_random_async_query, test_iosched);
-	}
-
-	if (!wait_for_completion_timeout(&utd->outstanding_complete,
-					 THREADS_COMPLETION_TIMOUT)) {
-		pr_err("%s: Multi-query test timed-out %d threads left",
-		       __func__, atomic_read(&utd->outstanding_threads));
-	}
-	test_iosched_mark_test_completion(test_iosched);
-	return 0;
-}
-
-static int ufs_test_run_parallel_read_and_write_test(struct test_iosched
-						     *test_iosched)
-{
-	struct test_scenario *read_data, *write_data;
-	int i;
-	bool changed_seed = false;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	read_data = get_scenario(test_iosched, SCEN_RANDOM_READ_50);
-	write_data = get_scenario(test_iosched, SCEN_RANDOM_WRITE_50);
-
-	/* allow randomness even if user forgot */
-	if (utd->random_test_seed <= 0) {
-		changed_seed = true;
-		utd->random_test_seed = 1;
-	}
-
-	atomic_set(&utd->outstanding_threads, 0);
-	utd->fail_threads = 0;
-	init_completion(&utd->outstanding_complete);
-
-	for (i = 0; i < (RANDOM_REQUEST_THREADS / 2); i++) {
-		async_schedule(ufs_test_run_scenario, read_data);
-		async_schedule(ufs_test_run_scenario, write_data);
-		atomic_add(2, &utd->outstanding_threads);
-	}
-
-	if (!wait_for_completion_timeout(&utd->outstanding_complete,
-					 THREADS_COMPLETION_TIMOUT)) {
-		pr_err("%s: Multi-thread test timed-out %d threads left",
-		       __func__, atomic_read(&utd->outstanding_threads));
-	}
-	check_test_completion(test_iosched);
-
-	/* clear random seed if changed */
-	if (changed_seed)
-		utd->random_test_seed = 0;
-
-	return 0;
-}
-
-static void ufs_test_run_synchronous_scenario(struct test_scenario *read_data)
-{
-	struct ufs_test_data *utd = read_data->test_iosched->blk_dev_test_data;
-	init_completion(&utd->outstanding_complete);
-	atomic_set(&utd->outstanding_threads, 1);
-	async_schedule(ufs_test_run_scenario, read_data);
-	if (!wait_for_completion_timeout(&utd->outstanding_complete,
-					 THREADS_COMPLETION_TIMOUT)) {
-		pr_err("%s: Multi-thread test timed-out %d threads left",
-		       __func__, atomic_read(&utd->outstanding_threads));
-	}
-}
-
-static int ufs_test_run_lun_depth_test(struct test_iosched *test_iosched)
-{
-	struct test_scenario *read_data, *write_data;
-	struct scsi_device *sdev;
-	bool changed_seed = false;
-	int i = 0, num_req[LUN_DEPTH_TEST_SIZE];
-	int lun_qdepth, nutrs, num_scenarios;
-	struct ufs_test_data *utd;
-
-	BUG_ON(!test_iosched || !test_iosched->req_q ||
-	       !test_iosched->req_q->queuedata);
-	sdev = (struct scsi_device *)test_iosched->req_q->queuedata;
-	lun_qdepth = sdev->max_queue_depth;
-	nutrs = sdev->host->can_queue;
-	utd = test_iosched->blk_dev_test_data;
-
-	/* allow randomness even if user forgot */
-	if (utd->random_test_seed <= 0) {
-		changed_seed = true;
-		utd->random_test_seed = 1;
-	}
-
-	/* initialize the number of request for each iteration */
-	num_req[i++] =
-	    ufs_test_pseudo_random_seed(&utd->random_test_seed, 1,
-					lun_qdepth - 2);
-	num_req[i++] = lun_qdepth - 1;
-	num_req[i++] = lun_qdepth;
-	num_req[i++] = lun_qdepth + 1;
-	/* if (nutrs-lun_qdepth-2 <= 0), do not run this scenario */
-	if (nutrs - lun_qdepth - 2 > 0)
-		num_req[i++] =
-		    lun_qdepth + 1 +
-		    ufs_test_pseudo_random_seed(&utd->random_test_seed, 1,
-						nutrs - lun_qdepth - 2);
-
-	/* if nutrs == lun_qdepth, do not run these three scenarios */
-	if (nutrs != lun_qdepth) {
-		num_req[i++] = nutrs - 1;
-		num_req[i++] = nutrs;
-		num_req[i++] = nutrs + 1;
-	}
-
-	/* a random number up to 10, not to cause overflow or timeout */
-	num_req[i++] =
-	    nutrs + 1 + ufs_test_pseudo_random_seed(&utd->random_test_seed, 1,
-						    10);
-
-	num_scenarios = i;
-	utd->test_stage = UFS_TEST_LUN_DEPTH_TEST_RUNNING;
-	utd->fail_threads = 0;
-	read_data = get_scenario(test_iosched, SCEN_RANDOM_READ_32_NO_FLUSH);
-	write_data = get_scenario(test_iosched, SCEN_RANDOM_WRITE_32_NO_FLUSH);
-
-	for (i = 0; i < num_scenarios; i++) {
-		int reqs = num_req[i];
-
-		read_data->total_req = reqs;
-		write_data->total_req = reqs;
-
-		ufs_test_run_synchronous_scenario(read_data);
-		ufs_test_run_synchronous_scenario(write_data);
-	}
-
-	utd->test_stage = UFS_TEST_LUN_DEPTH_DONE_ISSUING_REQ;
-	check_test_completion(test_iosched);
-
-	/* clear random seed if changed */
-	if (changed_seed)
-		utd->random_test_seed = 0;
-
-	return 0;
-}
-
-static void long_test_free_end_io_fn(struct request *rq, int err)
-{
-	struct test_request *test_rq;
-	struct test_iosched *test_iosched = rq->q->elevator->elevator_data;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	if (!rq) {
-		pr_err("%s: error: NULL request", __func__);
-		return;
-	}
-
-	test_rq = (struct test_request *)rq->elv.priv[0];
-
-	BUG_ON(!test_rq);
-
-	spin_lock_irq(&test_iosched->lock);
-	test_iosched->dispatched_count--;
-	list_del_init(&test_rq->queuelist);
-	__blk_put_request(test_iosched->req_q, test_rq->rq);
-	spin_unlock_irq(&test_iosched->lock);
-
-	if (utd->test_stage == UFS_TEST_LONG_SEQUENTIAL_MIXED_STAGE2 &&
-	    rq_data_dir(rq) == READ && compare_buffer_to_pattern(test_rq)) {
-		/* if the pattern does not match */
-		pr_err("%s: read pattern not as expected", __func__);
-		utd->test_stage = UFS_TEST_ERROR;
-		check_test_completion(test_iosched);
-		return;
-	}
-
-	test_iosched_free_test_req_data_buffer(test_rq);
-	kfree(test_rq);
-	utd->completed_req_count++;
-
-	if (err)
-		pr_err("%s: request %d completed, err=%d", __func__,
-		       test_rq->req_id, err);
-
-	check_test_completion(test_iosched);
-}
-
-/**
- * run_long_test - main function for long sequential test
- * @td - test specific data
- *
- * This function is used to fill up (and keep full) the test queue with
- * requests. There are two scenarios this function works with:
- * 1. Only read/write (STAGE_1 or no stage)
- * 2. Simultaneous read and write to the same LBAs (STAGE_2)
- */
-static int run_long_test(struct test_iosched *test_iosched)
-{
-	int ret = 0;
-	int direction, num_bios_per_request;
-	static unsigned int inserted_requests;
-	u32 sector, seed, num_bios, seq_sector_delta;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	BUG_ON(!test_iosched);
-	sector = test_iosched->start_sector;
-	if (test_iosched->sector_range)
-		utd->sector_range = test_iosched->sector_range;
-	else
-		utd->sector_range = TEST_DEFAULT_SECTOR_RANGE;
-
-	if (utd->test_stage != UFS_TEST_LONG_SEQUENTIAL_MIXED_STAGE2) {
-		test_iosched->test_count = 0;
-		utd->completed_req_count = 0;
-		inserted_requests = 0;
-	}
-
-	/* Set test parameters */
-	switch (test_iosched->test_info.testcase) {
-	case UFS_TEST_LONG_RANDOM_READ:
-		num_bios_per_request = 1;
-		utd->long_test_num_reqs = (utd->sector_range * SECTOR_SIZE) /
-		    (LONG_RAND_TEST_REQ_RATIO * TEST_BIO_SIZE *
-		     num_bios_per_request);
-		direction = READ;
-		break;
-	case UFS_TEST_LONG_RANDOM_WRITE:
-		num_bios_per_request = 1;
-		utd->long_test_num_reqs = (utd->sector_range * SECTOR_SIZE) /
-		    (LONG_RAND_TEST_REQ_RATIO * TEST_BIO_SIZE *
-		     num_bios_per_request);
-		direction = WRITE;
-		break;
-	case UFS_TEST_LONG_SEQUENTIAL_READ:
-		num_bios_per_request = TEST_MAX_BIOS_PER_REQ;
-		utd->long_test_num_reqs = (utd->sector_range * SECTOR_SIZE) /
-		    (num_bios_per_request * TEST_BIO_SIZE);
-		direction = READ;
-		break;
-	case UFS_TEST_LONG_SEQUENTIAL_WRITE:
-	case UFS_TEST_LONG_SEQUENTIAL_MIXED:
-		num_bios_per_request = TEST_MAX_BIOS_PER_REQ;
-		utd->long_test_num_reqs = (utd->sector_range * SECTOR_SIZE) /
-		    (num_bios_per_request * TEST_BIO_SIZE);
-	default:
-		direction = WRITE;
-	}
-
-	seq_sector_delta = num_bios_per_request * (TEST_BIO_SIZE / SECTOR_SIZE);
-
-	seed = utd->random_test_seed ? utd->random_test_seed : MAGIC_SEED;
-
-	pr_info("%s: Adding %d requests, first req_id=%d", __func__,
-		utd->long_test_num_reqs, test_iosched->wr_rd_next_req_id);
-
-	do {
-		/*
-		 * since our requests come from a pool containing 128
-		 * requests, we don't want to exhaust this quantity,
-		 * therefore we add up to QUEUE_MAX_REQUESTS (which
-		 * includes a safety margin) and then call the block layer
-		 * to fetch them
-		 */
-		if (test_iosched->test_count >= QUEUE_MAX_REQUESTS) {
-			blk_post_runtime_resume(test_iosched->req_q, 0);
-			continue;
-		}
-
-		switch (test_iosched->test_info.testcase) {
-		case UFS_TEST_LONG_SEQUENTIAL_READ:
-		case UFS_TEST_LONG_SEQUENTIAL_WRITE:
-		case UFS_TEST_LONG_SEQUENTIAL_MIXED:
-			/* don't need to increment on the first iteration */
-			if (inserted_requests)
-				sector += seq_sector_delta;
-			break;
-		case UFS_TEST_LONG_RANDOM_READ:
-		case UFS_TEST_LONG_RANDOM_WRITE:
-			pseudo_rnd_sector_and_size(utd, &sector, &num_bios);
-		default:
-			break;
-		}
-
-		ret = test_iosched_add_wr_rd_test_req(test_iosched, 0,
-						      direction, sector,
-						      num_bios_per_request,
-						      TEST_PATTERN_5A,
-						      long_test_free_end_io_fn);
-		if (ret) {
-			pr_err("%s: failed to create request", __func__);
-			break;
-		}
-		inserted_requests++;
-		if (utd->test_stage == UFS_TEST_LONG_SEQUENTIAL_MIXED_STAGE2) {
-			ret = test_iosched_add_wr_rd_test_req(test_iosched, 0,
-							      READ, sector,
-							      num_bios_per_request,
-							      TEST_PATTERN_5A,
-							      long_test_free_end_io_fn);
-			if (ret) {
-				pr_err("%s: failed to create request",
-				       __func__);
-				break;
-			}
-			inserted_requests++;
-		}
-
-	} while (inserted_requests < utd->long_test_num_reqs);
-
-	/* in this case the queue will not run in the above loop */
-	if (utd->long_test_num_reqs < QUEUE_MAX_REQUESTS)
-		blk_post_runtime_resume(test_iosched->req_q, 0);
-
-	return ret;
-}
-
-static int run_mixed_long_seq_test(struct test_iosched *test_iosched)
-{
-	int ret;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	utd->test_stage = UFS_TEST_LONG_SEQUENTIAL_MIXED_STAGE1;
-	ret = run_long_test(test_iosched);
-	if (ret)
-		goto out;
-
-	pr_info("%s: First write iteration completed.", __func__);
-	pr_info("%s: Starting mixed write and reads sequence.", __func__);
-	utd->test_stage = UFS_TEST_LONG_SEQUENTIAL_MIXED_STAGE2;
-	ret = run_long_test(test_iosched);
-out:
-	return ret;
-}
-
-static int long_rand_test_calc_iops(struct test_iosched *test_iosched)
-{
-	unsigned long mtime, num_ios, iops;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	mtime = ktime_to_ms(utd->test_info.test_duration);
-	num_ios = utd->completed_req_count;
-
-	pr_info("%s: time is %lu msec, IOS count is %lu", __func__, mtime,
-		num_ios);
-
-	/* preserve some precision */
-	num_ios *= 1000;
-	/* calculate those iops */
-	iops = num_ios / mtime;
-
-	pr_info("%s: IOPS: %lu IOP/sec\n", __func__, iops);
-
-	return ufs_test_post(test_iosched);
-}
-
-static int long_seq_test_calc_throughput(struct test_iosched *test_iosched)
-{
-	unsigned long fraction, integer;
-	unsigned long mtime, byte_count;
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	mtime = ktime_to_ms(utd->test_info.test_duration);
-	byte_count = utd->test_info.test_byte_count;
-
-	pr_info("%s: time is %lu msec, size is %lu.%lu MiB", __func__, mtime,
-		LONG_TEST_SIZE_INTEGER(byte_count),
-		LONG_TEST_SIZE_FRACTION(byte_count));
-
-	/* we first multiply in order not to lose precision */
-	mtime *= MB_MSEC_RATIO_APPROXIMATION;
-	/* divide values to get a MiB/sec integer value with one
-	   digit of precision
-	 */
-	fraction = integer = (byte_count * 10) / mtime;
-	integer /= 10;
-	/* and calculate the MiB value fraction */
-	fraction -= integer * 10;
-
-	pr_info("%s: Throughput: %lu.%lu MiB/sec\n", __func__, integer,
-		fraction);
-
-	return ufs_test_post(test_iosched);
-}
-
-static bool ufs_data_integrity_completion(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-	bool ret = false;
-
-	if (!test_iosched->dispatched_count) {
-		/* q is empty in this case */
-		if (!utd->queue_complete) {
-			utd->queue_complete = true;
-			wake_up(&utd->wait_q);
-		} else {
-			/* declare completion only on second time q is empty */
-			ret = true;
-		}
-	}
-
-	return ret;
-}
-
-static int ufs_test_run_data_integrity_test(struct test_iosched *test_iosched)
-{
-	int ret = 0;
-	int i, j;
-	unsigned int start_sec, num_bios, retries = NUM_UNLUCKY_RETRIES;
-	struct request_queue *q = test_iosched->req_q;
-	int sectors[QUEUE_MAX_REQUESTS] = { 0 };
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	start_sec = test_iosched->start_sector;
-	utd->queue_complete = false;
-
-	if (utd->random_test_seed != 0) {
-		ufs_test_pseudo_rnd_size(&utd->random_test_seed, &num_bios);
-	} else {
-		num_bios = DEFAULT_NUM_OF_BIOS;
-		utd->random_test_seed = MAGIC_SEED;
-	}
-
-	/* Adding write requests */
-	pr_info("%s: Adding %d write requests, first req_id=%d", __func__,
-		QUEUE_MAX_REQUESTS, test_iosched->wr_rd_next_req_id);
-
-	for (i = 0; i < QUEUE_MAX_REQUESTS; i++) {
-		/* make sure that we didn't draw the same start_sector twice */
-		while (retries--) {
-			pseudo_rnd_sector_and_size(utd, &start_sec, &num_bios);
-			sectors[i] = start_sec;
-			for (j = 0; (j < i) && (sectors[i] != sectors[j]); j++)
-				/* just increment j */ ;
-			if (j == i)
-				break;
-		}
-		if (!retries) {
-			pr_err("%s: too many unlucky start_sector draw retries",
-			       __func__);
-			ret = -EINVAL;
-			return ret;
-		}
-		retries = NUM_UNLUCKY_RETRIES;
-
-		ret = test_iosched_add_wr_rd_test_req(test_iosched, 0, WRITE,
-						      start_sec, 1, i,
-						      long_test_free_end_io_fn);
-
-		if (ret) {
-			pr_err("%s: failed to add a write request", __func__);
-			return ret;
-		}
-	}
-
-	/* waiting for the write request to finish */
-	blk_post_runtime_resume(q, 0);
-	wait_event(utd->wait_q, utd->queue_complete);
-
-	/* Adding read requests */
-	pr_info("%s: Adding %d read requests, first req_id=%d", __func__,
-		QUEUE_MAX_REQUESTS, test_iosched->wr_rd_next_req_id);
-
-	for (i = 0; i < QUEUE_MAX_REQUESTS; i++) {
-		ret = test_iosched_add_wr_rd_test_req(test_iosched, 0, READ,
-						      sectors[i], 1, i,
-						      long_test_free_end_io_fn);
-
-		if (ret) {
-			pr_err("%s: failed to add a read request", __func__);
-			return ret;
-		}
-	}
-
-	blk_post_runtime_resume(q, 0);
-	return ret;
-}
-
-static ssize_t ufs_test_write(struct file *file, const char __user *buf,
-			      size_t count, loff_t *ppos, int test_case)
-{
-	int ret = 0;
-	int i;
-	int number;
-	struct seq_file *seq_f = file->private_data;
-	struct ufs_test_data *utd = seq_f->private;
-
-	ret = kstrtoint_from_user(buf, count, 0, &number);
-	if (ret < 0) {
-		pr_err("%s: Error while reading test parameter value %d",
-		       __func__, ret);
-		return ret;
-	}
-
-	if (number <= 0)
-		number = 1;
-
-	pr_info("%s:the test will run for %d iterations.", __func__, number);
-	memset(&utd->test_info, 0, sizeof(struct test_info));
-
-	/* Initializing test */
-	utd->test_info.data = utd;
-	utd->test_info.get_test_case_str_fn = ufs_test_get_test_case_str;
-	utd->test_info.testcase = test_case;
-	utd->test_info.get_rq_disk_fn = ufs_test_get_rq_disk;
-	utd->test_info.check_test_result_fn = ufs_test_check_result;
-	utd->test_info.post_test_fn = ufs_test_post;
-	utd->test_info.prepare_test_fn = ufs_test_prepare;
-	utd->test_stage = DEFAULT;
-
-	pr_info("%s:test_case is %d.", __func__, test_case);
-	switch (test_case) {
-	case UFS_TEST_WRITE_READ_TEST:
-		utd->test_info.run_test_fn = ufs_test_run_write_read_test;
-		utd->test_info.check_test_completion_fn =
-		    ufs_write_read_completion;
-		break;
-	case UFS_TEST_MULTI_QUERY:
-		utd->test_info.run_test_fn = ufs_test_run_multi_query_test;
-		utd->test_info.check_test_result_fn = ufs_test_check_result;
-		break;
-	case UFS_TEST_DATA_INTEGRITY:
-		utd->test_info.run_test_fn = ufs_test_run_data_integrity_test;
-		utd->test_info.check_test_completion_fn =
-		    ufs_data_integrity_completion;
-		break;
-	case UFS_TEST_LONG_RANDOM_READ:
-	case UFS_TEST_LONG_RANDOM_WRITE:
-		utd->test_info.run_test_fn = run_long_test;
-		utd->test_info.post_test_fn = long_rand_test_calc_iops;
-		utd->test_info.check_test_result_fn = ufs_test_check_result;
-		utd->test_info.check_test_completion_fn =
-		    long_rand_test_check_completion;
-		break;
-	case UFS_TEST_LONG_SEQUENTIAL_READ:
-	case UFS_TEST_LONG_SEQUENTIAL_WRITE:
-		utd->test_info.run_test_fn = run_long_test;
-		utd->test_info.post_test_fn = long_seq_test_calc_throughput;
-		utd->test_info.check_test_result_fn = ufs_test_check_result;
-		utd->test_info.check_test_completion_fn =
-		    long_seq_test_check_completion;
-		break;
-	case UFS_TEST_LONG_SEQUENTIAL_MIXED:
-		utd->test_info.timeout_msec = LONG_SEQUENTIAL_MIXED_TIMOUT_MS;
-		utd->test_info.run_test_fn = run_mixed_long_seq_test;
-		utd->test_info.post_test_fn = long_seq_test_calc_throughput;
-		utd->test_info.check_test_result_fn = ufs_test_check_result;
-		break;
-	case UFS_TEST_PARALLEL_READ_AND_WRITE:
-		utd->test_info.run_test_fn =
-		    ufs_test_run_parallel_read_and_write_test;
-		utd->test_info.check_test_completion_fn =
-		    ufs_test_multi_thread_completion;
-		break;
-	case UFS_TEST_LUN_DEPTH:
-		utd->test_info.run_test_fn = ufs_test_run_lun_depth_test;
-		break;
-	case UFS_TEST_READ:
-		utd->test_info.run_test_fn = NULL;
-		break;
-	default:
-		pr_err("%s: Unknown test-case: %d", __func__, test_case);
-		WARN_ON(true);
-	}
-
-	/* Running the test multiple times */
-	for (i = 0; i < number; ++i) {
-		pr_info("%s: Cycle # %d / %d", __func__, i + 1, number);
-		pr_info("%s: ====================", __func__);
-
-		utd->test_info.test_byte_count = 0;
-		ret = test_iosched_start_test(utd->test_iosched,
-					      &utd->test_info);
-		if (ret) {
-			pr_err("%s: Test failed, err=%d.", __func__, ret);
-			return ret;
-		}
-
-		/* Allow FS requests to be dispatched */
-		msleep(1000);
-	}
-
-	pr_info("%s: Completed all the ufs test iterations.", __func__);
-
-	return count;
-}
-
-TEST_OPS(write_read_test, WRITE_READ_TEST);
-TEST_OPS(multi_query, MULTI_QUERY);
-TEST_OPS(data_integrity, DATA_INTEGRITY);
-TEST_OPS(long_random_read, LONG_RANDOM_READ);
-TEST_OPS(long_random_write, LONG_RANDOM_WRITE);
-TEST_OPS(long_sequential_read, LONG_SEQUENTIAL_READ);
-TEST_OPS(long_sequential_write, LONG_SEQUENTIAL_WRITE);
-TEST_OPS(long_sequential_mixed, LONG_SEQUENTIAL_MIXED);
-TEST_OPS(parallel_read_and_write, PARALLEL_READ_AND_WRITE);
-TEST_OPS(lun_depth, LUN_DEPTH);
-TEST_OPS(read, READ);
-
-static void ufs_test_debugfs_cleanup(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-	debugfs_remove_recursive(test_iosched->debug.debug_root);
-	kfree(utd->test_list);
-}
-
-static int ufs_test_debugfs_init(struct ufs_test_data *utd)
-{
-	struct dentry *utils_root, *tests_root;
-	int ret = 0;
-	struct test_iosched *ts = utd->test_iosched;
-
-	utils_root = ts->debug.debug_utils_root;
-	tests_root = ts->debug.debug_tests_root;
-
-	utd->test_list = kmalloc(sizeof(struct dentry *) * NUM_TESTS,
-				 GFP_KERNEL);
-	if (!utd->test_list) {
-		pr_err("%s: failed to allocate tests dentrys", __func__);
-		return -ENODEV;
-	}
-
-	if (!utils_root || !tests_root) {
-		pr_err("%s: Failed to create debugfs root.", __func__);
-		ret = -EINVAL;
-		goto exit_err;
-	}
-
-	utd->random_test_seed_dentry = debugfs_create_u32("random_test_seed",
-							  S_IRUGO | S_IWUGO,
-							  utils_root,
-							  &utd->
-							  random_test_seed);
-
-	if (!utd->random_test_seed_dentry) {
-		pr_err("%s: Could not create debugfs random_test_seed.",
-		       __func__);
-		ret = -ENOMEM;
-		goto exit_err;
-	}
-
-	ret = add_test(utd, write_read_test, WRITE_READ_TEST);
-	if (ret)
-		goto exit_err;
-	ret = add_test(utd, data_integrity, DATA_INTEGRITY);
-	if (ret)
-		goto exit_err;
-	ret = add_test(utd, long_random_read, LONG_RANDOM_READ);
-	if (ret)
-		goto exit_err;
-	ret = add_test(utd, long_random_write, LONG_RANDOM_WRITE);
-	if (ret)
-		goto exit_err;
-	ret = add_test(utd, long_sequential_read, LONG_SEQUENTIAL_READ);
-	if (ret)
-		goto exit_err;
-	ret = add_test(utd, long_sequential_write, LONG_SEQUENTIAL_WRITE);
-	if (ret)
-		goto exit_err;
-	ret = add_test(utd, long_sequential_mixed, LONG_SEQUENTIAL_MIXED);
-	if (ret)
-		goto exit_err;
-	add_test(utd, multi_query, MULTI_QUERY);
-	if (ret)
-		goto exit_err;
-	add_test(utd, parallel_read_and_write, PARALLEL_READ_AND_WRITE);
-	if (ret)
-		goto exit_err;
-	add_test(utd, lun_depth, LUN_DEPTH);
-	if (ret)
-		goto exit_err;
-	add_test(utd, read, READ);
-	if (ret)
-		goto exit_err;
-
-	goto exit;
-
-exit_err:
-	ufs_test_debugfs_cleanup(ts);
-exit:
-	return ret;
-}
-
-static int ufs_test_probe(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd;
-	int ret;
-
-	utd = kzalloc(sizeof(*utd), GFP_KERNEL);
-	if (!utd) {
-		pr_err("%s: failed to allocate ufs test data\n", __func__);
-		return -ENOMEM;
-	}
-
-	init_waitqueue_head(&utd->wait_q);
-	utd->test_iosched = test_iosched;
-	test_iosched->blk_dev_test_data = utd;
-
-	ret = ufs_test_debugfs_init(utd);
-	if (ret) {
-		pr_err("%s: failed to init debug-fs entries, ret=%d\n",
-		       __func__, ret);
-		kfree(utd);
-	}
-
-	return ret;
-}
-
-static void ufs_test_remove(struct test_iosched *test_iosched)
-{
-	struct ufs_test_data *utd = test_iosched->blk_dev_test_data;
-
-	ufs_test_debugfs_cleanup(test_iosched);
-	test_iosched->blk_dev_test_data = NULL;
-	kfree(utd);
-}
-
-static int __init ufs_test_init(void)
-{
-	ufs_bdt = kzalloc(sizeof(*ufs_bdt), GFP_KERNEL);
-	if (!ufs_bdt)
-		return -ENOMEM;
-
-	ufs_bdt->type_prefix = UFS_TEST_BLK_DEV_TYPE_PREFIX;
-	ufs_bdt->init_fn = ufs_test_probe;
-	ufs_bdt->exit_fn = ufs_test_remove;
-	INIT_LIST_HEAD(&ufs_bdt->list);
-
-	test_iosched_register(ufs_bdt);
-
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(ufs_test_init);
-
-static void __exit ufs_test_exit(void)
-{
-	test_iosched_unregister(ufs_bdt);
-	kfree(ufs_bdt);
-}
-
-module_init(ufs_test_init);
-module_exit(ufs_test_exit);
-
-MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("UFC test");
diff --git a/drivers/scsi/ufs/ufs_fault_inject.c b/drivers/scsi/ufs/ufs_fault_inject.c
deleted file mode 100644
index 5d8d392..0000000
--- a/drivers/scsi/ufs/ufs_fault_inject.c
+++ /dev/null
@@ -1,710 +0,0 @@
-/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * UFS fault inject - add fault inject interface to the ufshcd.
- * This infrastructure can be used for debugging the driver from userspace.
- *
- */
-
-#include <linux/random.h>
-#include <linux/debugfs.h>
-#include <linux/fault-inject.h>
-#include "ufs_fault_inject.h"
-#include "unipro.h"
-#include "ufshci.h"
-#include "ufshcd.h"
-
-#ifdef CONFIG_SCSI_UFS_FAULT_INJECT
-#define DEFAULT_ERR_INDEX (0xFFFFFFFF)
-
-struct fault_inject_files {
-	struct dentry *debugfs_root;
-	struct dentry *err_inj_scenario;
-	struct dentry *err_inj_err_index;
-	struct dentry *err_inj_stats;
-	u32 err_inj_scenario_mask;
-	struct fault_attr fail_attr;
-};
-
-/* UFSHCD UIC layer error flags */
-enum {
-	UFSHCD_UIC_NON_FATAL_ERROR = (0x0),
-	UFSHCD_UIC_DL_PA_INIT_ERROR = (1 << 0), /* Data link layer error */
-	UFSHCD_UIC_NL_ERROR = (1 << 1), /* Network layer error */
-	UFSHCD_UIC_TL_ERROR = (1 << 2), /* Transport Layer error */
-	UFSHCD_UIC_DME_ERROR = (1 << 3), /* DME error */
-};
-
-static DECLARE_FAULT_ATTR(fail_default_attr);
-static char *fail_request;
-static struct fault_inject_files fault_inject_files;
-module_param(fail_request, charp, S_IRUGO);
-
-/**
- * struct ufsdbg_err_scenario - error scenario use case
- * @name: the name of the error scenario
- * @err_code_arr: error codes array for this error scenario
- * @num_err_codes: number of error codes in err_code_arr
- */
-struct ufsdbg_err_scenario {
-	const char *name;
-	const int *err_code_arr;
-	u32 num_err_codes;
-	u32 err_code_index;
-	u32 num_err_injected;
-};
-
-/*
- * the following static arrays are aggregation of possible errors
- * that might occur during the relevant error scenario
- */
-static const int err_inject_intr_err_codes[] = {
-	CONTROLLER_FATAL_ERROR,
-	SYSTEM_BUS_FATAL_ERROR,
-	DEVICE_FATAL_ERROR,
-	UIC_ERROR,
-	/* CMD_HANG_ERROR, */ /* doesn't work */
-};
-
-static const int err_inject_uic_intr_cause_err_codes[] = {
-	UFSHCD_UIC_NON_FATAL_ERROR,
-	UFSHCD_UIC_DL_PA_INIT_ERROR,
-	UFSHCD_UIC_NL_ERROR,
-	UFSHCD_UIC_TL_ERROR,
-	UFSHCD_UIC_DME_ERROR,
-};
-
-static const int err_inject_uic_cmd_err_codes[] = {
-	UIC_CMD_RESULT_INVALID_ATTR,
-	UIC_CMD_RESULT_INVALID_ATTR_VALUE,
-	UIC_CMD_RESULT_READ_ONLY_ATTR,
-	UIC_CMD_RESULT_WRITE_ONLY_ATTR,
-	UIC_CMD_RESULT_BAD_INDEX,
-	UIC_CMD_RESULT_LOCKED_ATTR,
-	UIC_CMD_RESULT_PEER_COMM_FAILURE,
-	UIC_CMD_RESULT_BUSY,
-	UIC_CMD_RESULT_DME_FAILURE,
-};
-
-static const int err_inject_pwr_mode_change_err_codes[] = {
-	PWR_OK,
-	PWR_REMOTE,
-	PWR_BUSY,
-	PWR_ERROR_CAP,
-	PWR_FATAL_ERROR,
-};
-
-static const int err_inject_tr_ocs_err_codes[] = {
-	OCS_INVALID_CMD_TABLE_ATTR,
-	OCS_INVALID_PRDT_ATTR,
-	OCS_MISMATCH_DATA_BUF_SIZE,
-	OCS_MISMATCH_RESP_UPIU_SIZE,
-	OCS_PEER_COMM_FAILURE,
-	OCS_ABORTED,
-	OCS_FATAL_ERROR,
-	OCS_INVALID_COMMAND_STATUS,
-};
-
-static const int err_inject_tr_rsp_err_codes[] = {
-	TARGET_FAIL,
-};
-
-static const int err_inject_scsi_status_err_codes[] = {
-	SAM_STAT_CHECK_CONDITION,
-	SAM_STAT_CONDITION_MET,
-	SAM_STAT_BUSY,
-	SAM_STAT_INTERMEDIATE,
-	SAM_STAT_TASK_SET_FULL,
-	SAM_STAT_ACA_ACTIVE,
-	SAM_STAT_TASK_ABORTED,
-};
-
-static const int err_inject_tm_ocs_err_codes[] = {
-	TM_OCS_INVALID_TM_FUNCTION_ATTR,
-	TM_OCS_MISMATCH_TM_REQUEST_SIZE,
-	TM_OCS_MISMATCH_TM_RESPONSE_SIZE,
-	TM_OCS_PEER_COMM_FAILURE,
-	TM_OCS_ABORTED,
-	TM_OCS_FATAL_ERROR,
-	TM_OCS_INVALID_OCS_VALUE,
-};
-
-static const int err_inject_tm_rsp_err_codes[] = {
-	UPIU_TASK_MANAGEMENT_FUNC_COMPL,
-	UPIU_TASK_MANAGEMENT_FUNC_NOT_SUPPORTED,
-	UPIU_TASK_MANAGEMENT_FUNC_FAILED,
-	UPIU_INCORRECT_LOGICAL_UNIT_NO,
-};
-
-static struct ufsdbg_err_scenario err_scen_arr[] = {
-	{
-		"ERR_INJECT_INTR",
-		err_inject_intr_err_codes,
-		ARRAY_SIZE(err_inject_intr_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-	{
-		"ERR_INJECT_UIC_INTR_CAUSE",
-		err_inject_uic_intr_cause_err_codes,
-		ARRAY_SIZE(err_inject_uic_intr_cause_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-	{
-		"ERR_INJECT_UIC_CMD_ERR",
-		err_inject_uic_cmd_err_codes,
-		ARRAY_SIZE(err_inject_uic_cmd_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-	{
-		"ERR_INJECT_PWR_MODE_CHANGE_ERR",
-		err_inject_pwr_mode_change_err_codes,
-		ARRAY_SIZE(err_inject_pwr_mode_change_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-	{
-		"ERR_INJECT_TRANSFER_OCS",
-		err_inject_tr_ocs_err_codes,
-		ARRAY_SIZE(err_inject_tr_ocs_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-	{
-		"ERR_INJECT_TRANSFER_RSP",
-		err_inject_tr_rsp_err_codes,
-		ARRAY_SIZE(err_inject_tr_rsp_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-	{
-		"ERR_INJECT_SCSI_STATUS",
-		err_inject_scsi_status_err_codes,
-		ARRAY_SIZE(err_inject_scsi_status_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-	{
-		"ERR_INJECT_TM_OCS",
-		err_inject_tm_ocs_err_codes,
-		ARRAY_SIZE(err_inject_tm_ocs_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-	{
-		"ERR_INJECT_TM_RSP",
-		err_inject_tm_rsp_err_codes,
-		ARRAY_SIZE(err_inject_tm_rsp_err_codes),
-		DEFAULT_ERR_INDEX,
-	},
-};
-
-static bool inject_fatal_err_tr(struct ufs_hba *hba, u8 ocs_err)
-{
-	unsigned int tag;
-
-	/* clear all outstanding requests*/
-	for_each_set_bit(tag, &hba->outstanding_reqs, hba->nutrs) { /*lint !e574*/
-		ufshcd_writel(hba, ~(1UL << tag),
-			REG_UTP_TRANSFER_REQ_LIST_CLEAR);
-		(&hba->lrb[tag])->utr_descriptor_ptr->header.dword_2 =
-			cpu_to_be32(ocs_err);
-	}
-	/* fatal error injected */
-	return true;
-}
-
-static bool inject_fatal_err_tm(struct ufs_hba *hba, u8 ocs_err)
-{
-	int tag;
-
-	/* clear all outstanding tasks*/
-	for_each_set_bit(tag, &hba->outstanding_reqs, hba->nutrs) {
-		ufshcd_writel(hba, ~(1 << tag), REG_UTP_TASK_REQ_LIST_CLEAR);
-		(&hba->utmrdl_base_addr[tag])->header.dword_2 =
-			cpu_to_be32(ocs_err);
-	}
-	/* fatal error injected */
-	return 1;
-}
-
-static bool inject_cmd_hang_tr(struct ufs_hba *hba)
-{
-	int tag;
-
-	tag = find_first_bit(&hba->outstanding_reqs, hba->nutrs);
-	if (tag == hba->nutrs)
-		return 0;
-
-	__clear_bit(tag, &hba->outstanding_reqs);
-	hba->lrb[tag].cmd = NULL;
-	__clear_bit(tag, &hba->lrb_in_use);
-
-	/* command hang injected */
-	return 1;
-}
-
-static int inject_cmd_hang_tm(struct ufs_hba *hba)
-{
-	int tag;
-
-	tag = find_first_bit(&hba->outstanding_tasks, hba->nutmrs);
-	if (tag == hba->nutmrs)
-		return 0;
-
-	__clear_bit(tag, &hba->outstanding_tasks);
-	__clear_bit(tag, &hba->tm_slots_in_use);
-
-	/* command hang injected */
-	return 1;
-}
-static void
-ufsdbg_uic_intr_cause_request(struct ufs_hba *hba, u32 *intr_status)
-{
-	return; /* do nothing now */
-}
-
-static void
-ufsdbg_intr_fail_request(struct ufs_hba *hba, u32 *intr_status)
-{
-	u8 ocs_err;
-
-	pr_info("%s: fault-inject error: 0x%x\n",
-			__func__, *intr_status);
-
-	switch (*intr_status) {
-	case DEVICE_FATAL_ERROR:/*fall through*/
-		ocs_err = OCS_FATAL_ERROR;
-		goto handle_fatal_err;
-	case CONTROLLER_FATAL_ERROR: /* fall through */
-		ocs_err = OCS_FATAL_ERROR;
-		goto handle_fatal_err;
-	case SYSTEM_BUS_FATAL_ERROR:
-		ocs_err = OCS_INVALID_CMD_TABLE_ATTR;
-handle_fatal_err:
-		/* clear UTRLRSR & UTMRLRSR*/
-		ufshcd_writel(hba, 0, REG_UTP_TRANSFER_REQ_LIST_RUN_STOP);
-		ufshcd_writel(hba, 0, REG_UTP_TASK_REQ_LIST_RUN_STOP);
-		if (!inject_fatal_err_tr(hba, ocs_err))
-			if (!inject_fatal_err_tm(hba, ocs_err))
-				goto out;
-		break;
-	case CMD_HANG_ERROR:
-		if (!inject_cmd_hang_tr(hba))
-			inject_cmd_hang_tm(hba);
-		break;
-	case UIC_ERROR:
-		/* do nothing */
-		break;
-	default:
-		dev_err(hba->dev, "invalid fault interrupt");
-		/* some configurations ignore panics caused by BUG() */
-		break;
-	}
-out:
-	return;
-}
-
-static bool
-ufsdbg_find_err_code(enum ufsdbg_err_inject_scenario usecase,
-			 int *ret, u32 *index)
-{
-	struct ufsdbg_err_scenario *err_scen = &err_scen_arr[usecase];
-	u32 err_code_index;
-
-	if (!err_scen->num_err_codes)
-		return false;
-
-	if ((err_scen->err_code_index < err_scen->num_err_codes)) {
-		err_code_index = err_scen->err_code_index;
-	} else if (err_scen->err_code_index == DEFAULT_ERR_INDEX) {
-		err_code_index = prandom_u32() % err_scen->num_err_codes;
-	} else {
-		pr_err("ufs fault inject invalid err code\n");
-		return false;
-	}
-	*index = err_code_index;
-	*ret = err_scen->err_code_arr[err_code_index];
-	return true;
-}
-
-static bool ufsdbg_should_fail(struct ufs_hba *hba,
-	enum ufsdbg_err_inject_scenario usecase, int success_value,
-	int *ret_value, int *opt_ret, u32 *err_code_index)
-{
-	/* sanity check and verify error scenario bit */
-	if ((unlikely(!hba || !ret_value)) ||
-		(likely(!(fault_inject_files.err_inj_scenario_mask &
-						BIT(usecase)))))
-		return false;
-
-	if (usecase >= ERR_INJECT_MAX_ERR_SCENARIOS) {
-		dev_err(hba->dev, "%s: invalid usecase value (%d)\n", __func__,
-			usecase);
-		return false;
-	}
-
-	if (!ufsdbg_find_err_code(usecase, opt_ret, err_code_index))
-		return false;
-
-	/* UIC_INTR_CAUSE will be injected in spite of should_fail,
-	   always inject UIC_INTR_CAUSE err*/
-	if ((!should_fail(&fault_inject_files.fail_attr, 1))
-		&& (usecase != ERR_INJECT_UIC_INTR_CAUSE))
-		return false;
-
-	/* if an error already occurred/injected */
-	if (*ret_value != success_value)
-		return false;
-
-	return true;
-
-}
-
-void ufsdbg_error_inject_dispatcher(struct ufs_hba *hba,
-			enum ufsdbg_err_inject_scenario usecase,
-			int success_value, int *ret_value)
-{
-	int opt_ret = 0;
-	u32 err_code_index = 0;
-
-	if (!ufsdbg_should_fail(hba, usecase, success_value, ret_value, &opt_ret,
-		    &err_code_index))
-		goto out;
-
-	switch (usecase) {
-	case ERR_INJECT_INTR:
-		/* an error already occurred */
-		if (*ret_value & UFSHCD_ERROR_MASK)
-			goto out;
-
-		ufsdbg_intr_fail_request(hba, (u32 *)&opt_ret);
-		break;
-	case ERR_INJECT_UIC_INTR_CAUSE:
-		ufsdbg_uic_intr_cause_request(hba, (u32 *)&opt_ret);
-		break;
-	case ERR_INJECT_UIC_CMD_ERR:
-		opt_ret |= *ret_value;
-		break;
-	case ERR_INJECT_PWR_MODE_CHANGE_ERR:
-		mdelay(200);
-		break;
-	case ERR_INJECT_TRANSFER_OCS:
-		break;
-	case ERR_INJECT_TRANSFER_RSP:
-		opt_ret = *ret_value | (opt_ret << 8);
-		break;
-	case ERR_INJECT_SCSI_STATUS:
-		opt_ret |= *ret_value;
-		break;
-	case ERR_INJECT_TM_OCS:
-	case ERR_INJECT_TM_RSP:
-	case ERR_INJECT_MAX_ERR_SCENARIOS:
-		break;
-	default:
-		dev_err(hba->dev, "%s: unsupported error scenario\n", __func__);
-		goto out;
-	}
-
-	*ret_value = opt_ret;
-	err_scen_arr[usecase].num_err_injected++;  /*lint !e661*/
-	dev_err(hba->dev,
-		"%s: Error Code: %d (0x%x), Index [%d], Scenario: \"%s\", ",
-		__func__, *ret_value, *ret_value, err_code_index,
-		err_scen_arr[usecase].name);  /*lint !e661*/
-out:
-	/**
-	 * here it's guaranteed that ret_value has the correct value,
-	 * whether it was assigned with a new value, or kept its own
-	 * original incoming value
-	 */
-	return;
-}
-
-static int ufsdbg_err_inj_scenario_read(struct seq_file *file, void *data)
-{
-	enum ufsdbg_err_inject_scenario err_case;
-
-	seq_printf(file, "%-40s %-17s %-15s\n",
-		   "Error Scenario:", "Bit[#]", "STATUS");
-
-	for (err_case = ERR_INJECT_INTR;
-		err_case < ERR_INJECT_MAX_ERR_SCENARIOS; err_case++) {
-		seq_printf(file, "%-40s 0x%-15lx %-15s\n",
-			   err_scen_arr[err_case].name,
-			   UFS_BIT(err_case),
-			   fault_inject_files.err_inj_scenario_mask &
-				UFS_BIT(err_case) ? "ENABLE" : "DISABLE");
-	}
-
-	seq_printf(file, "bitwise of error scenario is 0x%x\n\n",
-		   fault_inject_files.err_inj_scenario_mask);
-
-	seq_puts(file, "usage example:\n");
-	seq_puts(file, "echo 0x1 > /sys/kernel/debug/ufs_fault_inject/err_inj_scenario\n");
-	seq_puts(file, "in order to enable ERR_INJECT_INTR\n");
-
-	return 0;
-}
-
-static
-int ufsdbg_err_inj_scenario_open(struct inode *inode, struct file *file)
-{
-	return single_open(file,
-			ufsdbg_err_inj_scenario_read, inode->i_private);
-}
-
-static ssize_t ufsdbg_err_inj_scenario_write(struct file *file,
-					 const char __user *ubuf, size_t cnt,
-					 loff_t *ppos)
-{
-	int ret;
-	int err_scen = 0;
-
-
-	ret = kstrtoint_from_user(ubuf, cnt, 0, &err_scen);
-	if (ret) {
-		pr_err("%s: Invalid argument\n", __func__);
-		return ret;
-	}
-
-	fault_inject_files.err_inj_scenario_mask = err_scen;
-
-	return cnt;
-}
-
-static const struct file_operations ufsdbg_err_inj_scenario_ops = {
-	.open		= ufsdbg_err_inj_scenario_open,
-	.read		= seq_read,
-	.write		= ufsdbg_err_inj_scenario_write,
-};
-
-static int ufsdbg_err_inj_stats_read(struct seq_file *file, void *data)
-{
-	int err;
-
-	seq_printf(file, "%-40s %-20s\n",
-		   "Error Scenario:", "Num of Errors Injected");
-
-	for (err = 0; err < ERR_INJECT_MAX_ERR_SCENARIOS; err++) {
-		seq_printf(file, "%-40s %-20d\n",
-			err_scen_arr[err].name,
-			err_scen_arr[err].num_err_injected);
-	}
-
-	return 0;
-}
-
-static
-int ufsdbg_err_inj_stats_open(struct inode *inode, struct file *file)
-{
-	return single_open(file,
-			ufsdbg_err_inj_stats_read, inode->i_private);
-}
-
-static ssize_t ufsdbg_err_inj_stats_write(struct file *file,
-					 const char __user *ubuf, size_t cnt,
-					 loff_t *ppos)
-{
-	int err;
-
-	for (err = 0; err < ERR_INJECT_MAX_ERR_SCENARIOS; err++)
-		err_scen_arr[err].num_err_injected = 0;
-
-	return cnt;
-}
-
-static const struct file_operations ufsdbg_err_inj_stats_ops = {
-	.open		= ufsdbg_err_inj_stats_open,
-	.read		= seq_read,
-	.write		= ufsdbg_err_inj_stats_write,
-};
-
-
-static int ufsdbg_err_inj_err_index_read(struct seq_file *file, void *data)
-{
-	int scenario = 0;
-	int ec_index = 0;
-
-	seq_puts(file, "Selected Scenarios and Error Codes are as follows:\n\n");
-	for (scenario = 0;
-	     scenario < ERR_INJECT_MAX_ERR_SCENARIOS;
-	     scenario++) {
-		ec_index = err_scen_arr[scenario].err_code_index;
-		if ((ec_index >= 0) &&
-		    (ec_index < err_scen_arr[scenario].num_err_codes)) { /*lint !e574*/
-			seq_printf(file, "Scenario: %-35s(Index: %d), Error Code: %d(Index: %d)\n",
-				err_scen_arr[scenario].name,
-				scenario,
-				err_scen_arr[scenario].err_code_arr[ec_index],
-				ec_index);
-		}
-	}
-	seq_puts(file,
-		"\n\nUsage:\n"
-		"To select a specific fault, write 'S E' to err_inj_index, where:\n"
-		" S - scenario index\n"
-		" E - error code index of the scenario\n"
-		"     All available error code index:\n");
-	for (scenario = 0;
-	     scenario < ERR_INJECT_MAX_ERR_SCENARIOS;
-	     scenario++) {
-		seq_printf(file, "     Scenario: %-35s(Index: %d), Error Code Index Range: [0, %d]\n",
-			err_scen_arr[scenario].name,
-			scenario,
-			err_scen_arr[scenario].num_err_codes - 1);
-	}
-	seq_puts(file, "\nTo select a random fault, write 'S 0xFFFFFFFF' to "
-		       "err_inj_index:\n\n");
-
-	seq_puts(file, "usage example:\n");
-	seq_puts(file, "echo 0x1 > /sys/kernel/debug/ufs_fault_inject/err_inj_scenario\n");
-	seq_puts(file, "echo 0 1 > /sys/kernel/debug/ufs_fault_inject/err_inj_index\n");
-	seq_puts(file, "to enable SYSTEM_BUS_FATAL_ERROR in scenario ERR_INJECT_INTR\n");
-	return 0;
-}
-
-static
-int ufsdbg_err_inj_err_index_open(struct inode *inode, struct file *file)
-{
-	return single_open(file,
-			ufsdbg_err_inj_err_index_read, inode->i_private);
-}
-
-static ssize_t ufsdbg_err_inj_err_index_write(struct file *file,
-					 const char __user *ubuf, size_t cnt,
-					 loff_t *ppos)
-{
-	int ret;
-	int scenario = 0;
-	int err_code_index = 0;
-	char err_index_str[BUFFER_SIZE] = { 0 };
-	loff_t buff_pos = 0;
-
-	ret = simple_write_to_buffer(err_index_str, BUFFER_SIZE,
-					 &buff_pos, ubuf, cnt);
-	ret = sscanf(err_index_str, "%d %d", &scenario, &err_code_index);
-
-	if ((scenario < 0) ||
-	    (scenario >= ERR_INJECT_MAX_ERR_SCENARIOS)) {
-		pr_err("%s: Invalid scenario: scenario=%d, valid range: [0,%d)\n",
-			__func__,
-			scenario,
-			ERR_INJECT_MAX_ERR_SCENARIOS);
-		return cnt;
-	}
-	if ((err_code_index < 0) ||
-	    (err_code_index >= err_scen_arr[scenario].num_err_codes)) { /*lint !e574*/
-		pr_info("%s: Invalid err_code_index: err_code_index=%d, valid range: [0,%d)\n",
-			__func__,
-			err_code_index,
-			err_scen_arr[scenario].num_err_codes);
-		pr_info("%s: Err_code_index if secenario %d is set to 0x%x\n",
-			__func__, scenario, DEFAULT_ERR_INDEX);
-		err_scen_arr[scenario].err_code_index = DEFAULT_ERR_INDEX;
-	} else {
-		err_scen_arr[scenario].err_code_index = err_code_index;
-	}
-	return cnt;
-}
-
-static const struct file_operations ufsdbg_err_inj_err_index_ops = {
-	.open		= ufsdbg_err_inj_err_index_open,
-	.read		= seq_read,
-	.write		= ufsdbg_err_inj_err_index_write,
-};
-static void ufsdbg_setup_fault_injection(void)
-{
-	struct dentry *fault_dir;
-
-	fault_inject_files.fail_attr = fail_default_attr;
-
-	if (fail_request)
-		setup_fault_attr(&fault_inject_files.fail_attr, fail_request);
-
-	/* suppress dump stack every time failure is injected */
-	fault_inject_files.fail_attr.verbose = 0;
-
-	fault_dir = fault_create_debugfs_attr("inject_fault",
-					fault_inject_files.debugfs_root,
-					&fault_inject_files.fail_attr);
-
-	if (IS_ERR(fault_dir)) {
-		pr_err("%s: failed to create debugfs entry for fault injection\n",
-			__func__);
-		return;
-	}
-
-	fault_inject_files.err_inj_scenario =
-		debugfs_create_file("err_inj_scenario",
-				   S_IRUGO | S_IWUGO,
-				   fault_inject_files.debugfs_root, NULL,
-				   &ufsdbg_err_inj_scenario_ops);
-
-	if (!fault_inject_files.err_inj_scenario) {
-		pr_err("%s: Could not create debugfs entry for err_scenario",
-				__func__);
-		goto fail_err_inj_scenario;
-	}
-
-	fault_inject_files.err_inj_stats =
-		debugfs_create_file("err_inj_stats", S_IRUSR | S_IWUSR,
-					fault_inject_files.debugfs_root, NULL,
-					&ufsdbg_err_inj_stats_ops);
-	if (!fault_inject_files.err_inj_stats) {
-		pr_err("%s:  failed create err_inj_stats debugfs entry\n",
-			__func__);
-		goto fail_err_inj_stats;
-	}
-
-	fault_inject_files.err_inj_err_index =
-		debugfs_create_file("err_inj_index", S_IRUSR | S_IWUSR,
-					fault_inject_files.debugfs_root, NULL,
-					&ufsdbg_err_inj_err_index_ops);
-	if (!fault_inject_files.err_inj_err_index) {
-		pr_err("%s:  failed create err_inj_index debugfs entry\n",
-			__func__);
-		goto fail_err_inj_err_index;
-	}
-	return;
-
-fail_err_inj_err_index:
-	debugfs_remove(fault_inject_files.err_inj_stats);
-fail_err_inj_stats:
-	debugfs_remove(fault_inject_files.err_inj_scenario);
-fail_err_inj_scenario:
-	debugfs_remove_recursive(fault_dir);
-}
-
-void ufs_fault_inject_fs_setup(void)
-{
-	fault_inject_files.debugfs_root
-		= debugfs_create_dir("ufs_fault_inject", NULL);
-	if (IS_ERR(fault_inject_files.debugfs_root))
-		/* Don't complain -- debugfs just isn't enabled */
-		goto err_no_root;
-	if (!fault_inject_files.debugfs_root) {
-		/*
-		 * Complain -- debugfs is enabled, but it failed to
-		 * create the directory
-		 */
-		pr_err("%s: NULL debugfs root directory, exiting", __func__);
-		goto err_no_root;
-	}
-
-	ufsdbg_setup_fault_injection();
-
-	return;
-
-err_no_root:
-	pr_err("%s: failed to initialize debugfs\n", __func__);
-}
-
-void ufs_fault_inject_fs_remove(void)
-{
-	debugfs_remove_recursive(fault_inject_files.debugfs_root);
-}
-
-#endif /* End of CONFIG_SCSI_UFS_FAULT_INJECT */
diff --git a/drivers/scsi/ufs/ufs_test.c b/drivers/scsi/ufs/ufs_test.c
deleted file mode 100644
index 4e9a2ec..0000000
--- a/drivers/scsi/ufs/ufs_test.c
+++ /dev/null
@@ -1,2820 +0,0 @@
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt"\n"
-
-#include <linux/async.h>
-#include <linux/atomic.h>
-#include <linux/blkdev.h>
-#include <linux/debugfs.h>
-#include <linux/delay.h>
-#include <linux/module.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_eh.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_host.h>
-#include <linux/devfreq.h>
-#include <linux/platform_device.h>
-#include <linux/fs.h>
-#include <linux/scatterlist.h>
-#include <asm/unaligned.h>
-#include <linux/uaccess.h>
-#include "ufshci.h"
-#include "ufshcd.h"
-#include "ufs.h"
-#include "ufs_test.h"
-
-#define MODULE_NAME "ufs_test"
-#define UFS_TEST_VER "V1.0.0.1"
-
-
-#define SCSI_SENSE_BUF_LEN             0x20
-#define SCSI_INQUIRY_LEN               36
-#define SCSI_MODE_SENSE_LEN            36
-#define SCSI_READ_CAPACITY_LEN         8
-#define BLOCK_COUNT 4096
-#define PRDT_SG_NUM 128
-#define RC_LEN 32
-
-enum ufs_test_testcases {
-	UFS_TEST_QUERY,
-	NUM_TESTS,
-};
-
-static DEFINE_MUTEX(ufs_test_lock);
-static LIST_HEAD(ufs_test_file_test);
-static LIST_HEAD(ufs_test_result);
-
-struct ufs_test_transfer_result {
-	struct list_head link;
-	unsigned int count;
-	unsigned int sectors;
-	struct timespec ts;
-	unsigned int rate;
-	unsigned int iops;
-};
-
-struct ufs_test_general_result {
-	struct list_head link;
-	int testcase;
-	int result;
-	struct list_head tr_lst;
-};
-
-struct ufs_test_debugfs_file {
-	struct list_head link;
-	struct dentry *file;
-	struct ufs_hba *hba;
-};
-
-struct ufs_test_ud {
-	struct dentry *debugfs_root;
-	struct ufs_hba *hba;
-};
-
-struct ufs_test {
-	struct ufs_hba *hba;
-	unsigned int g_lun;
-	unsigned long g_start_addr;
-	unsigned long g_length;
-	unsigned long g_trunk_size;
-	unsigned long g_data_mode;
-	unsigned long max_addr;
-	unsigned long lun_max_lba[UFS_UPIU_MAX_GENERAL_LUN];
-	unsigned int g_cmd;
-	unsigned int g_resp;
-	unsigned int g_para;
-};
-
-struct ufs_test_case {
-	const char *name;
-	int (*prepare)(struct ufs_test *);
-	int (*run)(struct ufs_test *);
-	int (*cleanup)(struct ufs_test *);
-};
-
-struct ufs_test_query_case {
-	const char *name;
-	int (*prepare)(void);
-	int (*run)(void);
-	int (*cleanup)(void);
-};
-
-enum cmdflag {
-	CMDNONE,
-	CONTEXT_ID = 1,
-	SYSDTAG = (1 << 4),
-	CACHE,
-};
-
-enum ufs_test_status_type {
-	TEST_STATUS_OK = 0,
-	TEST_STATUS_CMD_ERR,
-	TEST_STATUS_DATA_CHECK_ERR,
-	TEST_STATUS_PARAM_ERR,
-	TEST_STATUS_TIMER_OUT,
-	TEST_STATUS_NOT_SUPPORT,
-};
-
-static unsigned int ufs_test_rate(uint64_t bytes, struct timespec *ts)
-{
-	uint64_t ns;
-
-	ns = ts->tv_sec;
-	ns *= 1000000000;
-	ns += ts->tv_nsec;
-
-	bytes *= 1000000000;
-
-	while (ns > UINT_MAX) {
-		bytes >>= 1;
-		ns >>= 1;
-	}
-
-	if (!ns)
-		return 0;
-	do_div(bytes, (uint32_t) ns);
-
-	return bytes;
-}
-
-static void ufs_test_print_rate(uint64_t bytes,
-				struct timespec *ts1, struct timespec *ts2)
-{
-	unsigned int rate, iops, sectors = bytes >> 9;
-	struct timespec ts;
-
-	ts = timespec_sub(*ts2, *ts1);
-
-	rate = ufs_test_rate(bytes, &ts);
-	iops = ufs_test_rate(100, &ts);	/* I/O ops per sec x 100 */
-	pr_info("Transfer of %u sectors (%u%s KiB) took %lu.%09lu"
-			"seconds (%u kB/s, %u KiB/s, %u.%02u IOPS)\n",
-			sectors, sectors >> 1,
-			(sectors & 1 ? ".5" : ""), (unsigned long)ts.tv_sec,
-			(unsigned long)ts.tv_nsec, rate / 1000, rate / 1024,
-			iops / 100, iops % 100);
-}
-
-static int __find_substr(char *str, char *substr, char **endstr)
-{
-	char *pStr, *pDst;
-
-	pStr = str;
-	pDst = substr;
-	while (*pStr == ' ') {
-		pStr++;
-	};
-
-	/* End of string */
-	if (*pStr == '\0')
-		return 1;
-
-	while (*pStr != ' ') {
-		*pDst = *pStr;
-		if (*pStr == '\0')
-			break;
-		pStr++;
-		pDst++;
-	};
-	*pDst = 0;
-	*endstr = pStr;
-	return 0;
-}
-
-static int ufs_test_prepare(struct ufs_test *test)
-{
-	u8 *desc_buf;
-	int qLogicalBlockCount;
-	int buf_len = QUERY_DESC_UNIT_MAX_SIZE;
-	int i;
-	int err;
-
-	desc_buf = kmalloc(sizeof(u8 *) * QUERY_DESC_UNIT_MAX_SIZE, GFP_KERNEL);
-	if (!desc_buf)
-		return -ENOMEM;
-	memset(desc_buf, 0, QUERY_DESC_UNIT_MAX_SIZE);
-
-	for (i = 0; i < UFS_UPIU_MAX_GENERAL_LUN; i++) {
-		err = ufshcd_query_descriptor_retry(test->hba,
-						  UPIU_QUERY_OPCODE_READ_DESC,
-						  QUERY_DESC_IDN_UNIT, i, 0,
-						  desc_buf, &buf_len);
-		if (!err) {
-			qLogicalBlockCount = get_unaligned_be64(&desc_buf[11]);
-			test->lun_max_lba[i] = qLogicalBlockCount;
-			if (test->max_addr < qLogicalBlockCount) {
-				test->max_addr = qLogicalBlockCount;
-				test->g_lun = i;
-		    }
-		} else{
-			kfree(desc_buf);
-			return err;
-		}
-	}
-	kfree(desc_buf);
-	if (test->max_addr < BLOCK_COUNT * 32)
-		return -ENOMEM;
-
-	if (test->g_start_addr == 0)
-		test->g_start_addr = test->max_addr - BLOCK_COUNT * 32;
-
-	if (test->g_length == 0)
-		test->g_length = BLOCK_COUNT;
-
-	if ((test->g_start_addr +
-	     (test->g_length + BLOCK_COUNT - 1) / BLOCK_COUNT) >=
-	    test->max_addr)
-		err = TEST_STATUS_PARAM_ERR;
-
-	return err;
-}
-
-void dump_sense_buffer(char *buf, int buf_len)
-{
-	int index = 0;
-
-	pr_info("----Sense buffer----");
-	for (index = 0; index < buf_len; index++)
-		pr_info("buf[%d] = %x", index, buf[index]);
-	pr_info("----end of buffer---");
-}
-
-unsigned long ufs_test_random(void)
-{
-	static unsigned long ufs_test_rand;
-
-	ufs_test_rand = jiffies;
-	/* See "Numerical Recipes in C", second edition, p. 284 */
-	ufs_test_rand = ufs_test_rand * 1664525L + 1013904223L;
-	return ufs_test_rand;
-}
-
-void check_condition_err(struct scsi_cmnd *cmd)
-{
-	int sense_valid = 0;
-	struct scsi_sense_hdr sshdr;
-
-	sense_valid = scsi_command_normalize_sense(cmd, &sshdr);
-	switch (sshdr.sense_key) {
-	case NO_SENSE:
-		pr_info("No additional info or no error");
-		break;
-	case RECOVERED_ERROR:
-		pr_info("Cmd complete success with some revovery action");
-		break;
-	case NOT_READY:
-		pr_info("Lun is not accessible");
-		break;
-	case MEDIUM_ERROR:
-		pr_info("Medium_err cause this fail, Just like ECC err");
-		break;
-	case HARDWARE_ERROR:
-		pr_info("Hardware_err cause this fail");
-		break;
-	case ILLEGAL_REQUEST:
-		pr_info("Your device is not support this scsi cmd or"
-				"your paramters in your cdb is wrong");
-		break;
-	case UNIT_ATTENTION:
-		pr_info("Unit_attention, you need to reset or power-on");
-		break;
-	case DATA_PROTECT:
-		pr_info("Failure due to access of protected area of medium");
-		break;
-	case BLANK_CHECK:
-		pr_info("Not applicable for block device");
-		break;
-	case COPY_ABORTED:
-		pr_info("Not applicable for block device");
-		break;
-	case ABORTED_COMMAND:
-		pr_info("device aborted execution of the cmd");
-		break;
-	case VOLUME_OVERFLOW:
-		pr_info("Failure to write all data beacuse"
-				"end of range or partition");
-		break;
-	case MISCOMPARE:
-		pr_info("Indicates source data did not"
-				"match data read from medium");
-		break;
-	default:
-		break;
-	}
-}
-
-void sg_init_multi(struct scatterlist *sg, const void *buf,
-		unsigned int buflen, int n)
-{
-	int i;
-	char *p = (char *)buf;
-
-	sg_init_table(sg, n);
-	for (i = 0; i < n; i++)
-		sg_set_buf(sg + i, p + buflen * i, buflen);
-}
-
-static struct completion ufs_test_completion;
-static struct scsi_device ufs_test_scsi_device;
-
-void ufs_test_done(struct scsi_cmnd *cmd)
-{
-	complete(&ufs_test_completion);
-}
-
-void ufs_test_init_comm_scsi_cmd(struct scsi_cmnd *cmd, struct ufs_hba *hba,
-				 unsigned char *cdb,
-				 unsigned char *sense_buffer)
-{
-	ufs_test_scsi_device.host = hba->host;
-	cmd->device = &ufs_test_scsi_device;
-	cmd->cmd_len = COMMAND_SIZE(cdb[0]);
-	cmd->cmnd = cdb;
-	cmd->sense_buffer = sense_buffer;
-	cmd->scsi_done = ufs_test_done;
-	cmd->request = NULL;
-}
-
-void ufs_test_init_none_dma_scsi_cmd(struct scsi_cmnd *cmd, struct ufs_hba *hba,
-				     unsigned char *cdb,
-				     unsigned char *sense_buffer)
-{
-	ufs_test_init_comm_scsi_cmd(cmd, hba, cdb, sense_buffer);
-
-	cmd->sc_data_direction = DMA_NONE;
-	cmd->sdb.table.sgl = NULL;
-	cmd->sdb.table.nents = 0;
-	cmd->sdb.length = SCSI_SENSE_BUF_LEN;
-}
-
-void ufs_test_init_dma_scsi_cmd(struct scsi_cmnd *cmd, struct ufs_hba *hba,
-				unsigned char *cdb, unsigned char *sense_buffer,
-				enum dma_data_direction sc_data_direction,
-				struct scatterlist *sglist, unsigned int nseg,
-				unsigned int sg_len)
-{
-	ufs_test_init_comm_scsi_cmd(cmd, hba, cdb, sense_buffer);
-
-	cmd->sc_data_direction = sc_data_direction;
-	cmd->sdb.table.sgl = sglist;
-	cmd->sdb.table.nents = nseg;
-	cmd->sdb.length = sg_len;
-
-	cmd->serial_number = 0;
-	cmd->prot_op = SCSI_PROT_NORMAL;
-	cmd->sdb.resid = 0;
-	cmd->transfersize = BLOCK_COUNT;
-}
-
-void ufs_test_init_cdb(unsigned char cdb[10], int write, unsigned int block,
-		       unsigned int block_cnt, enum cmdflag cmd_flag)
-{
-	cdb[0] = write ? WRITE_10 : READ_10;
-	cdb[1] = 0;
-	cdb[2] = (unsigned char)(block >> 24) & 0xff;
-	cdb[3] = (unsigned char)(block >> 16) & 0xff;
-	cdb[4] = (unsigned char)(block >> 8) & 0xff;
-	cdb[5] = (unsigned char)block & 0xff;
-	cdb[6] = cmd_flag;
-	cdb[7] = (unsigned char)(block_cnt >> 8) & 0xff;
-	cdb[8] = (unsigned char)block_cnt & 0xff;
-	cdb[9] = 0;
-}
-
-extern int ufshcd_uic_hibern8_exit(struct ufs_hba *hba);
-static int ufs_test_do_scsi_cmd(struct ufs_hba *hba, struct scsi_cmnd *cmd,
-				int lun)
-{
-	struct ufshcd_lrb *lrbp;
-	unsigned long flags;
-	int tag;
-	int err = 0;
-	struct completion wait;
-
-	wait_event(hba->dev_cmd.tag_wq, ufshcd_get_dev_cmd_tag(hba, &tag));
-
-	spin_lock_irqsave(hba->host->host_lock, flags);
-	if (hba->ufshcd_state != UFSHCD_STATE_OPERATIONAL) {
-		err = SCSI_MLQUEUE_HOST_BUSY;
-		goto out_unlock;
-	}
-	spin_unlock_irqrestore(hba->host->host_lock, flags);
-	err = ufshcd_hold(hba, true);
-	if (err) {
-		pr_err("ufshcd_hold err:%d\n", err);
-		err = SCSI_MLQUEUE_HOST_BUSY;
-		clear_bit_unlock(tag, &hba->lrb_in_use);
-		goto out;
-	}
-	WARN_ON(hba->clk_gating.state != CLKS_ON);
-	lrbp = &hba->lrb[tag];
-
-	WARN_ON(lrbp->cmd);
-	lrbp->cmd = cmd;
-	lrbp->sense_bufflen = UFSHCD_REQ_SENSE_SIZE;
-	lrbp->sense_buffer = cmd->sense_buffer;
-	lrbp->task_tag = tag;
-	lrbp->lun = lun;
-	lrbp->intr_cmd = !ufshcd_is_intr_aggr_allowed(hba) ? true : false;
-	lrbp->command_type = UTP_CMD_TYPE_SCSI;
-
-	hba->dev_cmd.complete = &wait;
-
-	/* form UPIU before issuing the command */
-	ufshcd_compose_upiu(hba, lrbp);
-	err = ufshcd_map_sg(lrbp);
-	if (err) {
-		pr_err("ufshcd_map_sg err:%d##\n", err);
-		lrbp->cmd = NULL;
-		clear_bit_unlock(tag, &hba->lrb_in_use);
-		ufshcd_release(hba);
-		goto out;
-	}
-	/* Make sure descriptors are ready before ringing the doorbell */
-	wmb();
-
-	if (ufshcd_is_link_hibern8(hba) && !ufshcd_uic_hibern8_exit(hba))
-		ufshcd_set_link_active(hba);
-	/* issue command to the controller */
-	spin_lock_irqsave(hba->host->host_lock, flags);
-	ufshcd_send_command(hba, tag);
-out_unlock:
-	spin_unlock_irqrestore(hba->host->host_lock, flags);
-out:
-	wake_up(&hba->dev_cmd.tag_wq);
-	return err;
-}
-
-static int ufs_test_simple_transfer(struct ufs_hba *hba, int block,
-				    int block_cnt, int rw_flag,
-				    enum cmdflag cmd_flag, int lun)
-{
-	struct scsi_cmnd *cmd;
-	int err = 0;
-	struct scatterlist *sglist = NULL;
-	unsigned char *buf;
-	unsigned char cdb[10] = { 0 };
-	struct scsi_device *sdp = hba->sdev_ufs_device;
-	char sense_buf[SCSI_SENSE_BUFFERSIZE] = { 0 };
-	int i;
-	enum dma_data_direction direction;
-	struct scsi_device *sdev;
-
-	if (rw_flag)
-		direction = DMA_TO_DEVICE;
-	else
-		direction = DMA_FROM_DEVICE;
-
-	cmd = scsi_get_command(sdp, GFP_ATOMIC);
-
-	ufs_test_init_cdb(cdb, rw_flag, block, block_cnt, cmd_flag);
-
-	buf =
-	    kmalloc(BLOCK_COUNT * block_cnt + UFSHCD_REQ_SENSE_SIZE,
-		    GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	sglist = kmalloc(block_cnt * sizeof(struct scatterlist), GFP_KERNEL);
-	if (!sglist) {
-		kfree(buf);
-		return -ENOMEM;
-	}
-	memset(buf, 0, (BLOCK_COUNT * block_cnt + UFSHCD_REQ_SENSE_SIZE));
-
-	sg_init_multi(sglist, buf, BLOCK_COUNT, block_cnt);
-
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf, direction, sglist,
-				   block_cnt, BLOCK_COUNT * block_cnt);
-
-	__shost_for_each_device(sdev, hba->host) {
-		if (lun == sdev->lun)
-			cmd->device = sdev;
-	}
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			err = TEST_STATUS_OK;
-		} else {
-			pr_info("%s Fail, cmd_result:0x%x,lun:%d"
-					"the error reason is:",
-					__func__, cmd->result, lun);
-			check_condition_err(cmd);
-			err = TEST_STATUS_CMD_ERR;
-		}
-	} else {
-		pr_info("%s wait_for_completion_io_timeout time out\n",
-			__func__);
-		err = -ETIME;
-	}
-
-	kfree(sglist);
-	kfree(buf);
-	return err;
-}
-
-static int ufs_scsi_test_unit_ready_do(struct ufs_hba *hba, int lun)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	char cdb[] = {
-		TEST_UNIT_READY, 0, 0, 0, 0, 0,
-	};
-	char buf[SCSI_SENSE_BUF_LEN] = { 0 };
-	int i;
-
-	init_completion(&ufs_test_completion);
-	ufs_test_init_none_dma_scsi_cmd(cmd, hba, cdb, buf);
-	if (!cmd)
-		pr_err("init_basic_scsi_cmd faild");
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			pr_info("%s ##PASS##-lun:%x", __func__, lun);
-			err = TEST_STATUS_OK;
-		} else {
-			pr_info("%s Fail, cmd_result:0x%x,lun:%d"
-					"the error reason is:",
-					__func__, cmd->result, lun);
-			err = TEST_STATUS_CMD_ERR;
-			check_condition_err(cmd);
-		}
-	} else {
-		pr_err("%s wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-
-	return err;
-}
-
-static int ufs_scsi_test_unit_ready(struct ufs_test *test)
-{
-	int lun[5] = {0x81, 0xD0, 0xB0, 0xC4, 0x0};
-	int i, ret = 0;
-
-	for (i = 0; i < 5; i++)
-		ret = ufs_scsi_test_unit_ready_do(test->hba, lun[i]);
-	return ret;
-}
-
-/* We just send an invalid start_stop_unit to *
- * check if device can send the error response*
- * Beacuse Ufs_sleep and Ufs_active mode may *
- * not change just by only one cmd. *
- * */
-static int ufs_scsi_start_stop_unit(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	char cdb[] = {
-		START_STOP, 0, 0, 0, 0x11, 0,};
-	char buf[SCSI_SENSE_BUF_LEN] = { 0 };
-	int i;
-	u32 status1, status2;
-	struct scsi_device *sdev;
-	struct ufs_hba *hba = test->hba;
-
-	__shost_for_each_device(sdev, hba->host) {
-		if (0xD0 == sdev->lun)
-			cmd->device = sdev;
-	}
-	err = ufshcd_query_attr(hba_addr, UPIU_QUERY_OPCODE_READ_ATTR,
-				QUERY_ATTR_IDN_POWER_MODE, 0, 0, &status1);
-	pr_err("SSU-curent_state is:%02x\n", status1);
-
-	init_completion(&ufs_test_completion);
-	ufs_test_init_none_dma_scsi_cmd(cmd, hba, cdb, buf);
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, 0xD0);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			err =
-			    ufshcd_query_attr(hba_addr,
-					      UPIU_QUERY_OPCODE_READ_ATTR,
-					      QUERY_ATTR_IDN_POWER_MODE, 0, 0,
-					      &status2);
-			pr_err("SSU-after_state is:%02x\n", status2);
-			if (status2 != status1) {
-				err = TEST_STATUS_OK;
-				pr_info("%s ***Active_mode**PASS##\n",
-					__func__);
-			}
-		} else {
-			pr_info("%s Fail, the status is:0x%x\n", __func__,
-				cmd->result);
-			err = TEST_STATUS_CMD_ERR;
-			check_condition_err(cmd);
-		}
-
-	} else {
-		pr_info("%s-wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-
-	return err;
-}
-
-static int ufs_scsi_send_inqury(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	char cdb[] = {
-		INQUIRY, 0, 0, SCSI_INQUIRY_LEN >> 8, SCSI_INQUIRY_LEN, 0,
-	};
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	unsigned int nseg = 1;
-	unsigned char *dma_buf;
-	char sense_buf[SCSI_INQUIRY_LEN] = { 0 };
-	int i;
-	struct ufs_hba *hba = test->hba;
-
-	dma_buf = kmalloc(BLOCK_COUNT, GFP_KERNEL);
-	if (!dma_buf)
-		return -ENOMEM;
-	memset(dma_buf, 0, BLOCK_COUNT);
-
-	sg_init_one(sglist, dma_buf, BLOCK_COUNT);
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf, DMA_FROM_DEVICE,
-				   sglist, nseg, BLOCK_COUNT);
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (cmd->result == 0) {
-			pr_info("%s ##PASS##!", __func__);
-			err = TEST_STATUS_OK;
-		} else
-			goto out;
-	} else {
-		pr_info("%s-wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-out:
-	kfree(dma_buf);
-	return err;
-}
-
-static int ufs_scsi_read_capacity_do(struct ufs_hba *hba, char *cdb, int lun)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	unsigned int nseg = 1;
-	unsigned char *dma_buf;
-	char sense_buf[UFSHCD_REQ_SENSE_SIZE] = { 0 };
-	unsigned sector_size = 0;
-	u8 *desc_buf;
-	int buf_len = QUERY_DESC_UNIT_MAX_SIZE;
-	int bLogicalBlockSize = 0, qLogicalBlockCount;
-	int i;
-	unsigned long long lba;
-
-	dma_buf = kmalloc(BLOCK_COUNT, GFP_KERNEL);
-	if (!dma_buf)
-		return -ENOMEM;
-
-	desc_buf = kmalloc(sizeof(u8 *) * QUERY_DESC_UNIT_MAX_SIZE, GFP_KERNEL);
-	if (!desc_buf) {
-		kfree(dma_buf);
-		return -ENOMEM;
-	}
-	memset(dma_buf, 0, BLOCK_COUNT);
-	memset(desc_buf, 0, QUERY_DESC_UNIT_MAX_SIZE);
-
-	sg_init_one(sglist, dma_buf, BLOCK_COUNT);
-
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf, DMA_FROM_DEVICE,
-				   sglist, nseg, BLOCK_COUNT);
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		sector_size = get_unaligned_be32(&dma_buf[4]);
-		if (cdb[0] == READ_CAPACITY)
-			lba = get_unaligned_be32(&dma_buf[0]);
-		else
-			lba = get_unaligned_be64(&dma_buf[0]);
-
-		pr_info("SCSI_Read_capacity response sucess"
-				"cdb[0]:%d  lba:%llu lun:%d\n",
-				cdb[0], lba, lun);
-		err =
-		    ufshcd_query_descriptor_retry(hba,
-						  UPIU_QUERY_OPCODE_READ_DESC,
-						  QUERY_DESC_IDN_UNIT, lun, 0,
-						  desc_buf, &buf_len);
-		if (!err) {
-			bLogicalBlockSize = desc_buf[10];
-			qLogicalBlockCount = get_unaligned_be64(&desc_buf[11]);
-			pr_info("Query_Desc: lba:%d lun%d\n",
-				qLogicalBlockCount, lun);
-			if ((sector_size == (1 << bLogicalBlockSize))
-			    && (lba == qLogicalBlockCount - 1))
-				err = TEST_STATUS_OK;
-		} else {
-			kfree(dma_buf);
-			kfree(desc_buf);
-			return err;
-		}
-	} else {
-		pr_err("%s-wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-
-	kfree(dma_buf);
-	kfree(desc_buf);
-	return err;
-}
-
-static int ufs_scsi_read_capacity(struct ufs_test *test)
-{
-	int ret;
-	int i;
-	unsigned char cdb_10[10] = {
-		READ_CAPACITY, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	};
-	unsigned char cdb_16[16];
-
-	memset(cdb_16, 0, 16);
-	cdb_16[0] = SERVICE_ACTION_IN_16;
-	cdb_16[1] = SAI_READ_CAPACITY_16;
-	cdb_16[13] = RC_LEN;
-	for (i = 0; i < 7; i++) {
-		ret = ufs_scsi_read_capacity_do(test->hba, cdb_10, i);
-		if (ret)
-			goto out;
-		ret = ufs_scsi_read_capacity_do(test->hba, cdb_16, i);
-		if (ret)
-			goto out;
-	}
-out:
-	return ret;
-}
-
-static int ufs_scsi_report_lun(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	char cdb[] = {
-		REPORT_LUNS, 0, 0, 0, 0, 0, 0x28, 0, 0, 0, 0, 0,
-	};
-	char buf[8] = { 0 };
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	unsigned int nseg = 1;
-	unsigned char *dma_buf;
-	int i;
-	struct ufs_hba *hba = test->hba;
-
-	dma_buf = kmalloc(BLOCK_COUNT, GFP_KERNEL);
-	if (!dma_buf)
-		return -ENOMEM;
-
-	memset(dma_buf, 0, BLOCK_COUNT);
-
-	sg_init_one(sglist, dma_buf, BLOCK_COUNT);
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, buf, DMA_FROM_DEVICE, sglist,
-				   nseg, BLOCK_COUNT);
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			err = TEST_STATUS_OK;
-			pr_info("%s ##PASS##!", __func__);
-		} else {
-			pr_info("%s cmd_result:0x%x the error reason is:",
-				__func__, cmd->result);
-			check_condition_err(cmd);
-			err = TEST_STATUS_CMD_ERR;
-		}
-    } else {
-		pr_info("%s-wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-
-	return err;
-}
-
-static int ufs_scsi_mode_sense(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	unsigned char cdb[MAX_CDB_SIZE];
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	unsigned int nseg = 1;
-	unsigned char *dma_buf;
-	char sense_buf[SCSI_INQUIRY_LEN] = {0};
-	int i;
-	struct ufs_hba *hba = test->hba;
-
-	memset(&cdb[0], 0, MAX_CDB_SIZE);
-
-	cdb[0] = MODE_SENSE_10;
-	cdb[1] = 0x18;
-	cdb[2] = 0xa;
-	put_unaligned_be16(0x1C, &cdb[7]);
-
-	dma_buf = kmalloc(BLOCK_COUNT, GFP_KERNEL);
-	if (!dma_buf)
-		return -ENOMEM;
-	memset(dma_buf, 0, BLOCK_COUNT);
-
-	sg_init_one(sglist, dma_buf, BLOCK_COUNT);
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf, DMA_FROM_DEVICE,
-				   sglist, nseg, BLOCK_COUNT);
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			err = TEST_STATUS_OK;
-			pr_info("%s ##PASS##!", __func__);
-		} else {
-			pr_err("%s, cmd_result:0x%x the error reason is:",
-			       __func__, cmd->result);
-			err = TEST_STATUS_CMD_ERR;
-			check_condition_err(cmd);
-		}
-	} else {
-		pr_info("%s-wait_for_completion_io_timeout time out",
-		       __func__);
-		err = -ETIME;
-	}
-	return err;
-}
-
-static int ufs_scsi_mode_select(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	unsigned char cdb[MAX_CDB_SIZE] = {0};
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	unsigned int nseg = 1;
-	unsigned char *dma_buf;
-	char sense_buf[SCSI_SENSE_BUFFERSIZE] = {0};
-	int i;
-	struct ufs_hba *hba = test->hba;
-
-	cdb[0] = MODE_SELECT_10;
-	cdb[1] = 1 << 4;
-	put_unaligned_be16(0x1C, &cdb[7]);
-
-	dma_buf = kmalloc(BLOCK_COUNT, GFP_KERNEL);
-	if (!dma_buf)
-		return -ENOMEM;
-	memset(dma_buf, 0, BLOCK_COUNT);
-
-	sg_init_one(sglist, dma_buf, BLOCK_COUNT);
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf, DMA_TO_DEVICE,
-				   sglist, nseg, BLOCK_COUNT);
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			err = TEST_STATUS_OK;
-			pr_info("%s ##PASS##!", __func__);
-		} else {
-			pr_err("%s, cmd_result:0x%x the error reason is:",
-			       __func__, cmd->result);
-			err = TEST_STATUS_CMD_ERR;
-			check_condition_err(cmd);
-		}
-	} else {
-		pr_info("%s-wait_for_completion_io_timeout time out",
-		       __func__);
-		err = -ETIME;
-	}
-	return 0;
-}
-static int ufs_scsi_sync_cache(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	unsigned char cdb[MAX_CDB_SIZE];
-	int blk_cnt = 1;
-	char sense_buf[UFSHCD_REQ_SENSE_SIZE] = { 0 };
-	int i;
-	struct ufs_hba *hba = test->hba;
-
-	memset(&cdb[0], 0, MAX_CDB_SIZE);
-
-	cdb[0] = SYNCHRONIZE_CACHE;
-	cdb[7] = (unsigned char)(blk_cnt >> 8) & 0xff;
-	cdb[8] = (unsigned char)(blk_cnt) & 0xff;
-
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_none_dma_scsi_cmd(cmd, hba, cdb, sense_buf);
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			err = TEST_STATUS_OK;
-			pr_info("%s ##PASS##!", __func__);
-		} else {
-			pr_info("%s Fail, cmd_result:0x%x", __func__,
-				cmd->result);
-			check_condition_err(cmd);
-			err = TEST_STATUS_CMD_ERR;
-		}
-	} else {
-		pr_info("%s-wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-
-	return err;
-}
-
-static int ufs_scsi_verify(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	unsigned char cdb[MAX_CDB_SIZE];
-	char sense_buf[UFSHCD_REQ_SENSE_SIZE] = { 0 };
-	int i;
-	int block;
-	int block_cnt = 1;
-	struct ufs_hba *hba = test->hba;
-
-	block = test->g_start_addr;
-	memset(&cdb[0], 0, MAX_CDB_SIZE);
-
-	cdb[0] = VERIFY;
-	cdb[2] = (unsigned char)(block >> 24) & 0xff;
-	cdb[3] = (unsigned char)(block >> 16) & 0xff;
-	cdb[4] = (unsigned char)(block >> 8) & 0xff;
-	cdb[5] = (unsigned char)block & 0xff;
-	cdb[7] = (unsigned char)(block_cnt >> 8) & 0xff;
-	cdb[8] = (unsigned char)block_cnt & 0xff;
-
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_none_dma_scsi_cmd(cmd, hba, cdb, sense_buf);
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			err = TEST_STATUS_OK;
-			pr_info("%s ##PASS##!", __func__);
-		} else {
-			pr_info("%s Fail, cmd_result:0x%x", __func__,
-				cmd->result);
-			err = TEST_STATUS_CMD_ERR;
-			check_condition_err(cmd);
-		}
-	} else {
-		pr_info("%s-wait_for_completion_io_timeout time out",
-		       __func__);
-		err = -ETIME;
-	}
-
-	return err;
-}
-
-static int ufs_scsi_request_sense(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	unsigned char cdb[MAX_COMMAND_SIZE];
-	char sense_buf[UFSHCD_REQ_SENSE_SIZE] = { 0 };
-	int i;
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	unsigned int nseg = 1;
-	unsigned char *dma_buf;
-	struct ufs_hba *hba = test->hba;
-
-	memset(&cdb[0], 0, MAX_COMMAND_SIZE);
-	cdb[0] = REQUEST_SENSE;
-	cdb[4] = UFSHCD_REQ_SENSE_SIZE;
-
-	dma_buf = kmalloc(BLOCK_COUNT, GFP_KERNEL);
-	if (!dma_buf)
-		return -ENOMEM;
-	memset(dma_buf, 0, BLOCK_COUNT);
-
-	sg_init_one(sglist, dma_buf, BLOCK_COUNT);
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf, DMA_FROM_DEVICE,
-				   sglist, nseg, BLOCK_COUNT);
-	if (!cmd)
-		pr_info("init_basic_scsi_cmd failed");
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			err = TEST_STATUS_OK;
-			pr_info("%s ##PASS##!", __func__);
-		} else {
-			pr_info("%s Fail, cmd_result:0x%x", __func__,
-				cmd->result);
-			err = TEST_STATUS_CMD_ERR;
-			check_condition_err(cmd);
-		}
-	} else {
-		pr_info("ufs_test-wait_for_completion_io_timeout time out");
-		err = -ETIME;
-	}
-
-	return err;
-}
-
-struct inqury_pro_param {
-	u8 evpd;
-	u8 page_code;
-	int alloc_len;
-	u8 control;
-	u8 result[3];
-};
-
-struct inquiry_cmd {
-	unsigned int evpd;
-	unsigned int page_code;
-	unsigned int alloc_len;
-	unsigned int control;
-};
-
-struct inquiry_rsp {
-	unsigned int rsp_len;
-	unsigned int response;
-	unsigned int status;
-	unsigned int sense_key;
-	unsigned int add_sense_code;
-};
-
-struct inquiry_info {
-	struct inquiry_cmd cmd;
-	struct inquiry_rsp rsp;
-};
-
-static int ufs_test_do_inquiry(struct ufs_hba *hba,
-		struct inquiry_info *msg, int lun)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	int err = 0;
-	unsigned char cdb[MAX_COMMAND_SIZE] = {0};
-	char sense_buf[UFSHCD_REQ_SENSE_SIZE] = { 0 };
-	unsigned int nseg = 1;
-	unsigned char *dma_buf;
-
-	/* init scsi cmnd */
-	cdb[0] = INQUIRY;
-	cdb[1] = msg->cmd.evpd;	/* Query VPD */
-	cdb[2] = msg->cmd.page_code;	/* Page Code */
-	cdb[3] = (msg->cmd.alloc_len >> 8) & 0xff;
-	cdb[4] = (msg->cmd.alloc_len & 0xff);
-	cdb[5] = msg->cmd.control;
-
-	init_completion(&ufs_test_completion);
-
-	dma_buf = kmalloc(BLOCK_COUNT, GFP_KERNEL);
-	if (!dma_buf)
-		return -ENOMEM;
-	memset(dma_buf, 0, BLOCK_COUNT);
-
-	sg_init_one(sglist, dma_buf, BLOCK_COUNT);
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf,
-					DMA_FROM_DEVICE, sglist, nseg,
-					BLOCK_COUNT);
-	if (!cmd)
-		pr_info("init_basic_scsi_cmd failed");
-
-	err = ufs_test_do_scsi_cmd(hba, cmd, lun);
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (cmd->result == 0) {
-			pr_info("%s success!", __func__);
-			err = TEST_STATUS_OK;
-		} else {
-			pr_info
-			    ("%s Fail, cmd_result:0x%x,error resp is:",
-			     __func__, cmd->result);
-			check_condition_err(cmd);
-			goto out;
-		}
-	} else {
-		pr_info("%s wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-out:
-	return err;
-}
-
-struct inquiry_info inquiry_test_cases[] = {
-	{{0, 0, 36, 0}, {36, 0, 0, 0, 0} },
-	{{0, 0x83, 36, 0}, {0, 0, 0, 0, 0} },
-	{{0, 0, 37, 0}, {36, 0, 0, 0, 0} },
-	{{0, 0, 35, 0}, {35, 0, 0, 0, 0} },
-};
-
-static int ufs_test_protocol_inquiry(struct ufs_test *test)
-{
-	int i;
-	int err;
-	int result = 0;
-
-	for (i = 0; i < ARRAY_SIZE(inquiry_test_cases); i++) {
-		err = ufs_test_do_inquiry(test->hba,
-				&inquiry_test_cases[i], test->g_lun);
-		result += err;
-		if (err)
-			printk
-			    ("inquiry_protocol failed, index:%d,err: 0x%x\n",
-			     i, err);
-	}
-
-	return result;
-}
-
-struct mode_sense_msg {
-	int pc;
-	int page_code;
-	int sub_page_code;
-	int len;
-};
-static int ufs_test_mode_sense(struct ufs_hba *hba, struct mode_sense_msg *msg,
-			       unsigned char *sense_buffer)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	unsigned char cdb[MAX_COMMAND_SIZE] = { 0 };
-	char buf[SCSI_SENSE_BUF_LEN] = { 0 };
-
-	/* init scsi cmnd */
-	cdb[0] = MODE_SENSE;
-	cdb[1] = (unsigned char)0x80;
-	cdb[2] = (unsigned char)((msg->pc & 3) << 5) | (msg->page_code & 0x3f);
-	cdb[3] = (unsigned char)msg->sub_page_code;
-	cdb[7] = (unsigned char)((msg->pc >> 8) & 0xff);
-	cdb[8] = (unsigned char)(msg->pc & 0xff);
-
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_none_dma_scsi_cmd(cmd, hba, cdb, buf);
-	if (!cmd)
-		pr_err("init_basic_scsi_cmd failed");
-
-	err = ufs_test_do_scsi_cmd(hba, cmd, 0);
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result)
-			pr_info("Protocol_Mode_Sense cmd Success!");
-	} else {
-		pr_err("%s wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-
-	return err;
-}
-
-int ufs_test_protocol_mode_sense(struct ufs_test *test)
-{
-	int i;
-	int err;
-	struct scsi_sense_hdr sshdr;
-	unsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE] = { 0 };
-	struct mode_sense_msg msgs[] = {
-		{0, 0xa, 0, 0},};
-	struct ufs_hba *hba = test->hba;
-	struct mode_sense_msg chk_condition_msgs[] = {
-		{0, 2, 0, 0x1c},
-		{1, 2, 0, 0x1c},
-		{2, 2, 0, 0x1c},
-		{3, 2, 0, 0x1c},
-		{0, 0xa, 1, 0x1c},
-	};
-
-    for (i = 0; i < ARRAY_SIZE(msgs); i++) {
-		err = ufs_test_mode_sense(hba, &msgs[i], sense_buffer);
-		if (err)
-			return i;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(chk_condition_msgs); i++) {
-		err =
-		    ufs_test_mode_sense(hba, &chk_condition_msgs[i],
-					sense_buffer);
-		if (err != SAM_STAT_CHECK_CONDITION)
-			return i;
-		else {
-			scsi_normalize_sense(sense_buffer,
-					     SCSI_SENSE_BUFFERSIZE, &sshdr);
-			pr_info("sense_key: 0x%x, asc: 0x%x", sshdr.sense_key,
-			       sshdr.asc);
-			if (sshdr.sense_key != ILLEGAL_REQUEST
-			    || ((sshdr.asc != 0x24) && (sshdr.asc != 0x0)))
-				return i;
-		}
-	}
-
-	return 0;
-}
-
-static int ufs_scsi_basic_process(struct ufs_hba *hba, unsigned char *cdb,
-				  int dma_direction, int lun)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	char sense_buf[UFSHCD_REQ_SENSE_SIZE] = { 0 };
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	unsigned int nseg = 1;
-	unsigned char *dma_buf;
-	int i;
-	struct scsi_device *sdev;
-
-	init_completion(&ufs_test_completion);
-
-	if (DMA_NONE == dma_direction)
-		ufs_test_init_none_dma_scsi_cmd(cmd, hba, cdb, sense_buf);
-	else {
-		dma_buf = kmalloc(BLOCK_COUNT, GFP_KERNEL);
-		if (!dma_buf)
-			return -ENOMEM;
-		memset(dma_buf, 0, BLOCK_COUNT);
-
-		sg_init_one(sglist, dma_buf, BLOCK_COUNT);
-		ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf,
-					   dma_direction, sglist, nseg,
-					   BLOCK_COUNT);
-	}
-	__shost_for_each_device(sdev, hba->host) {
-		if (lun == sdev->lun)
-			cmd->device = sdev;
-	}
-
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (0 == cmd->result) {
-			pr_info("%s success!", __func__);
-			err = TEST_STATUS_OK;
-		} else {
-			pr_info("cmd Fail, cmd_result:0x%x,%x:%d", cmd->result,
-				cdb[0], (cdb[4] >> 4));
-			check_condition_err(cmd);
-			err = TEST_STATUS_CMD_ERR;
-		}
-	} else {
-		pr_info("%s wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-
-	return err;
-}
-
-static int ufs_test_protocol_report_lun(struct ufs_test *test)
-{
-	int i, ret;
-	unsigned char cdb[6][12] = {
-		{REPORT_LUNS, 0, 0, 0, 0, 0, 0x28, 0, 0, 0, 0, 0},
-		{REPORT_LUNS, 0, 0, 0, 0, 0, 0x48, 0, 0, 0, 0, 0},
-		{REPORT_LUNS, 0, 1, 0, 0, 0, 0x28, 0, 0, 0, 0, 0},
-		{REPORT_LUNS, 0, 3, 0, 0, 0, 0x68, 0, 0, 0, 0, 0},
-		{REPORT_LUNS, 0, 1, 0, 0, 0, 0x0F, 0, 0, 0, 0, 0},
-		{REPORT_LUNS, 0, 1, 0, 0, 0, 0x20, 0, 0, 0, 0, 0},
-	};
-
-	for (i = 0; i < 6; i++)
-		ret =
-		    ufs_scsi_basic_process(test->hba, cdb[i], DMA_FROM_DEVICE,
-					   test->g_lun);
-
-	return ret;
-}
-
-static int ufs_test_protocol_sync_cache(struct ufs_test *test)
-{
-	int i, ret;
-	unsigned char cdb[5][10] = {
-		{SYNCHRONIZE_CACHE, 0, 0, 0, 0, 0, 0, 0, 1, 0},
-		{SYNCHRONIZE_CACHE, (1 << 2), 0, 0, 0, 0, 0, 0, 1, 0},
-		{SYNCHRONIZE_CACHE, (1 << 1), 0, 0, 0, 0, 0, 0, 1, 0},
-		{SYNCHRONIZE_CACHE, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-	};
-
-	for (i = 0; i < 5; i++)
-		ret = ufs_scsi_basic_process(test->hba,
-					cdb[i], DMA_NONE, test->g_lun);
-
-	return ret;
-}
-
-static int ufs_test_protocol_start_stop_unit(struct ufs_test *test)
-{
-	int i, ret;
-	unsigned char cdb[5][6] = {
-		{START_STOP, 0, 0, 0, 0, 0},
-		{START_STOP, 1, 0, 0, 0, 0},
-		{START_STOP, 0, 0, 0, 1, 0},
-		{START_STOP, 1, 0, 0, 1, 0},
-		{START_STOP, 0, 0, 0, 0x41, 0},/*Sleep power mode*/
-	};
-
-	for (i = 0; i < 4; i++)
-		ret = ufs_scsi_basic_process(test->hba,
-					cdb[i], DMA_NONE, test->g_lun);
-
-	if (ret)
-		ufs_scsi_start_stop_unit(test);
-
-	return ret;
-}
-
-static int ufs_test_protocol_verify(struct ufs_test *test)
-{
-	int i, ret;
-	unsigned char cdb[2][10] = {
-		{VERIFY, 0, 0, 0, 0, 0, 0, 0, 0, 0},
-		{VERIFY, 0, 0, 0, 0, 0, 0, 0, 0xA, 0},
-	};
-
-	for (i = 0; i < 2; i++)
-		ret = ufs_scsi_basic_process(test->hba, cdb[i], DMA_NONE, 2);
-
-	ret = ufs_scsi_read_capacity(test);
-	return ret;
-}
-
-static int dump_and_check_lun_info(struct ufs_test *test)
-{
-	u8 *unit_buf, *geometry_buf;
-	int unit_len, geometry_len;
-	int err;
-	int bLogicalBlockSize, bMinAddrBlockSize, bMaxOutBufferSize,
-	    bMaxInBufferSize, qLogicalBlockCount;
-	int rpmb_bLogicalBlockSize;
-	int i, lb_len;
-
-	unit_len = QUERY_DESC_UNIT_MAX_SIZE;
-	unit_buf = kmalloc(sizeof(u8 *) * QUERY_DESC_UNIT_MAX_SIZE, GFP_KERNEL);
-	if (!unit_buf)
-		return -ENOMEM;
-
-	geometry_len = QUERY_DESC_GEOMETRY_MAZ_SIZE;
-	geometry_buf =
-	    kmalloc(sizeof(u8 *) * QUERY_DESC_GEOMETRY_MAZ_SIZE, GFP_KERNEL);
-	if (!geometry_buf) {
-		kfree(unit_buf);
-		return -ENOMEM;
-	}
-	for (i = 0; i < 7; i++) {
-		err = ufshcd_query_descriptor_retry(hba_addr,
-						  UPIU_QUERY_OPCODE_READ_DESC,
-						  QUERY_DESC_IDN_UNIT, i, 0,
-						  unit_buf, &unit_len);
-
-		if (!err) {
-			bLogicalBlockSize = unit_buf[10];
-			pr_info("##Logical_lun##-unit_len:%d lun:%d size:%d\n",
-			       unit_len, i, bLogicalBlockSize);
-		} else {
-			kfree(unit_buf);
-			kfree(geometry_buf);
-			return err;
-		}
-	}
-
-	err = ufshcd_query_descriptor_retry(hba_addr,
-					UPIU_QUERY_OPCODE_READ_DESC,
-					QUERY_DESC_IDN_UNIT, 0xC4, 0,
-					unit_buf, &unit_len);
-
-	if (!err) {
-		rpmb_bLogicalBlockSize = 1 << unit_buf[10];
-		qLogicalBlockCount = get_unaligned_be64(&unit_buf[11]);
-		pr_info
-		    ("##RPMB_lun##-unit_len:%d size:%d qLogicalBlockCount:%d\n",
-		     unit_len, rpmb_bLogicalBlockSize, qLogicalBlockCount);
-	} else {
-		kfree(unit_buf);
-		kfree(geometry_buf);
-		return err;
-	}
-	err = ufshcd_query_descriptor_retry(hba_addr,
-					UPIU_QUERY_OPCODE_READ_DESC,
-					QUERY_DESC_IDN_GEOMETRY, 0, 0,
-					geometry_buf, &geometry_len);
-	if (!err) {
-		bMinAddrBlockSize = geometry_buf[18];
-		bMaxInBufferSize = geometry_buf[21];
-		bMaxOutBufferSize = geometry_buf[22];
-	} else {
-		kfree(geometry_buf);
-		return err;
-	}
-	lb_len = 1 << bLogicalBlockSize;
-	if ((lb_len > (bMinAddrBlockSize * 512))
-	    && (lb_len < (bMaxInBufferSize * 512))
-	    && (lb_len < (bMaxOutBufferSize * 512)))
-		err = TEST_STATUS_OK;
-
-	return err;
-}
-
-static int check_and_test_bkops(struct ufs_test *test)
-{
-	int ret;
-	bool flag;
-	u32 attr;
-	u32 status;
-	struct ufs_hba *hba = test->hba;
-
-	ret = ufshcd_query_attr(hba_addr, UPIU_QUERY_OPCODE_READ_ATTR,
-				QUERY_ATTR_IDN_EE_STATUS, 0, 0, &status);
-
-	status &= hba->ee_ctrl_mask;
-
-	if (status & MASK_EE_URGENT_BKOPS)
-		pr_info
-		    ("Bkops Urgent Exception Event is opened.");
-
-	ret = ufshcd_query_flag(hba_addr, UPIU_QUERY_OPCODE_READ_FLAG,
-				QUERY_FLAG_IDN_BKOPS_EN, &flag);
-	if (ret)
-		return 0;
-	if (0 == flag)
-		pr_info("Bkops is not enable, We will enable it later");
-	if (1 == flag)
-		pr_info("Bkops is enable, We will close it later");
-
-	ret = ufshcd_query_flag(hba_addr, UPIU_QUERY_OPCODE_SET_FLAG,
-				QUERY_FLAG_IDN_BKOPS_EN, &flag);
-	if (ret)
-		return 0;
-	/*check the bkops_status */
-	ret = ufshcd_query_flag(hba_addr, UPIU_QUERY_OPCODE_READ_FLAG,
-				QUERY_FLAG_IDN_BKOPS_EN, &flag);
-	if (ret)
-		return 0;
-
-	ret = ufshcd_query_attr(hba_addr, UPIU_QUERY_OPCODE_READ_ATTR,
-				QUERY_ATTR_IDN_BKOPS_STATUS, 0, 0, &attr);
-	switch (attr) {
-	case 0:
-		pr_info("Bkops Status : Not required");
-		break;
-	case 1:
-		pr_info("Bkops Status : Required, not critical");
-		break;
-	case 2:
-		pr_info("Bkops Status : Required, performance impact");
-		break;
-	case 3:
-		pr_info("Bkops Status : Critical");
-		break;
-	default:
-		break;
-	}
-	/*clear the Bkops flag which we just wrote in */
-	ret = ufshcd_query_flag(hba_addr, UPIU_QUERY_OPCODE_CLEAR_FLAG,
-				QUERY_FLAG_IDN_BKOPS_EN, NULL);
-	if (ret)
-		return 0;
-
-	return 0;
-}
-
-static int ufs_test_ssu_powerdown(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	char buf[SCSI_SENSE_BUF_LEN];
-	char cdb[] = {
-		START_STOP, 0, 0, 0, (UFS_POWERDOWN_PWR_MODE << 4), 0,};
-	unsigned int status;
-	struct ufs_hba *hba = test->hba;
-
-	err = ufshcd_query_attr(hba_addr, UPIU_QUERY_OPCODE_READ_ATTR,
-				QUERY_ATTR_IDN_POWER_MODE, 0, 0, &status);
-	pr_err("SSU-curent_state is:%02x lun:%d\n", status, test->g_lun);
-
-	init_completion(&ufs_test_completion);
-
-	ufs_test_init_none_dma_scsi_cmd(cmd, hba, cdb, buf);
-	if (!cmd)
-		pr_err("init_basic_scsi_cmd failed");
-
-	err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		err = ufshcd_query_attr(hba_addr, UPIU_QUERY_OPCODE_READ_ATTR,
-					QUERY_ATTR_IDN_POWER_MODE, 0, 0,
-					&status);
-		pr_err("SSU Success-after_state is:%02x\n", status);
-	} else {
-		pr_info("%s wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-	ufs_scsi_start_stop_unit(test);
-    return err;
-}
-
-static int ufs_test_contextID_info(struct ufs_test *test)
-{
-	int ret;
-	u32 status;
-	u8 *desc_buf;
-	u8 *unit_buf;
-	int buf_len;
-	int i;
-	u32 val;
-	int block = test->g_start_addr;
-	struct ufs_hba *hba = test->hba;
-
-	for (i = 0; i < 6; i++) {
-		ret = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_READ_ATTR,
-					QUERY_ATTR_IDN_CNTX_CONF, i, 0,
-					&status);
-		pr_info("Context_Attr_status:%x", status);
-	}
-
-	buf_len = QUERY_DESC_GEOMETRY_MAZ_SIZE;
-	desc_buf =
-	    kmalloc(sizeof(u8 *) * QUERY_DESC_GEOMETRY_MAZ_SIZE, GFP_KERNEL);
-	if (!desc_buf)
-		return -ENOMEM;
-
-	ret = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_READ_DESC,
-					    QUERY_DESC_IDN_GEOMETRY, 0, 0,
-					    desc_buf, &buf_len);
-
-	pr_info("This device can support the max Context_ID number id: %d",
-		desc_buf[26]);
-
-	buf_len = QUERY_DESC_UNIT_MAX_SIZE;
-	unit_buf = kmalloc(sizeof(u8 *) * QUERY_DESC_UNIT_MAX_SIZE, GFP_KERNEL);
-	if (!unit_buf) {
-		kfree(desc_buf);
-		return -ENOMEM;
-	}
-	ret = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_READ_DESC,
-					    QUERY_DESC_IDN_UNIT, 0, 0, unit_buf,
-					    &buf_len);
-
-	unit_buf[32] = 0x1;
-	ret = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_WRITE_DESC,
-					    QUERY_DESC_IDN_UNIT, 0, 0, unit_buf,
-					    &buf_len);
-
-	pr_info(" enable wConfig Context_Attr_status");
-	val = 0x3;
-	val &= 0xFFFF;
-	ret = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_WRITE_ATTR,
-				QUERY_ATTR_IDN_CNTX_CONF, 0, 1, &val);
-
-	ret = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_READ_ATTR,
-				QUERY_ATTR_IDN_CNTX_CONF, 0, 1, &status);
-	pr_info("After enable wConfig Context_Attr_status:%x", status);
-
-	ufs_test_simple_transfer(hba, block, 1, WRITE, CONTEXT_ID, test->g_lun);
-	pr_info("ufs_test-Read_after_Write");
-	msleep(1000);
-	ufs_test_simple_transfer(hba, block, 1, READ, CONTEXT_ID, test->g_lun);
-
-	unit_buf[32] = 0;
-	ret = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_WRITE_DESC,
-					    QUERY_DESC_IDN_UNIT, 0, 0, unit_buf,
-					    &buf_len);
-	kfree(desc_buf);
-	kfree(unit_buf);
-	return 0;
-}
-
-static int ufs_test_system_data_tag(struct ufs_test *test)
-{
-	int ret;
-	u8 *desc_buf;
-	int buf_len;
-	struct ufs_hba *hba = test->hba;
-
-	buf_len = QUERY_DESC_GEOMETRY_MAZ_SIZE;
-	desc_buf =
-	    kmalloc(sizeof(u8 *) * QUERY_DESC_GEOMETRY_MAZ_SIZE, GFP_KERNEL);
-	if (!desc_buf)
-		return -ENOMEM;
-
-	ret = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_READ_DESC,
-					    QUERY_DESC_IDN_GEOMETRY, 0, 0,
-					    desc_buf, &buf_len);
-	if (ret)
-		goto out;
-
-	pr_info("bSysDataTagUnitSize:%d,bSysDataTagResSize:%d,", desc_buf[27],
-		desc_buf[28]);
-	pr_info("System data tag Unit_size is:%d,max system data eare is:%d",
-		(desc_buf[18] * 512), desc_buf[28]);
-
-	ret =
-	    ufs_test_simple_transfer(hba, test->g_start_addr, 1, WRITE, SYSDTAG,
-				     test->g_lun);
-
-out:
-	return 0;
-}
-
-static int ufs_test_erase_or_discard(struct ufs_test *test)
-{
-	struct scsi_cmnd st_cmd, *cmd = &st_cmd;
-	int err = 0;
-	unsigned char cdb[10] = { 0 };
-	char sense_buf[UFSHCD_REQ_SENSE_SIZE] = { 0 };
-	int i;
-	struct scatterlist st_sglist, *sglist = &st_sglist;
-	unsigned int nseg = 1;
-	unsigned int len = 24;
-	char buf[24] = { 0 };
-	int block = test->g_start_addr;
-	struct ufs_hba *hba = test->hba;
-	struct scsi_device *sdev;
-
-	cdb[0] = UNMAP;
-	cdb[8] = len;
-
-	put_unaligned_be16(len - 2, &buf[0]);
-	put_unaligned_be16(16, &buf[2]);
-	put_unaligned_be64(block, &buf[8]);
-	put_unaligned_be32(1, &buf[16]);
-
-	sg_init_one(sglist, buf, len);
-
-
-	ufs_test_init_dma_scsi_cmd(cmd, hba, cdb, sense_buf, DMA_TO_DEVICE,
-				   sglist, nseg, len);
-	if (!cmd)
-		pr_info("init_basic_scsi_cmd failed\n");
-	__shost_for_each_device(sdev, hba->host) {
-		if (test->g_lun == sdev->lun)
-			cmd->device = sdev;
-	}
-	init_completion(&ufs_test_completion);
-	for (i = 0; i < 1000; i++) {
-		msleep(3);
-		err = ufs_test_do_scsi_cmd(hba, cmd, test->g_lun);
-		if (!err)
-			break;
-	}
-
-	if (0 !=
-	    wait_for_completion_io_timeout(&ufs_test_completion,
-					   msecs_to_jiffies(1000))) {
-		if (cmd->result == 0) {
-			pr_info("%s ##PASS##!", __func__);
-			err = TEST_STATUS_OK;
-		} else {
-			pr_info("%s Fail, cmd_result:0x%x\n", __func__,
-			       cmd->result);
-			err = TEST_STATUS_CMD_ERR;
-		}
-	} else {
-		pr_info("%s wait_for_completion_io_timeout time out\n",
-		       __func__);
-		err = -ETIME;
-	}
-
-	return err;
-
-}
-
-static int ufs_test_health_report(struct ufs_test *test)
-{
-	int err = 0;
-	int buff_len = QUERY_DESC_HEALTH_MAX_SIZE;
-	u8 *desc_buf = NULL;
-
-	desc_buf = kzalloc(buff_len, GFP_KERNEL);
-	if (!desc_buf)
-		return -ENOMEM;
-
-	err =
-	    ufshcd_query_descriptor_retry(test->hba,
-					  UPIU_QUERY_OPCODE_READ_DESC, 0x09, 0,
-					  0, desc_buf, &buff_len);
-
-	if (!err) {
-		err = TEST_STATUS_OK;
-	    dump_sense_buffer(desc_buf, buff_len);
-    } else
-		err = TEST_STATUS_CMD_ERR;
-
-	return err;
-}
-
-static int ufs_test_simple_read(struct ufs_test *test)
-{
-	int ret;
-
-	ret =
-	    ufs_test_simple_transfer(test->hba, test->g_start_addr, 1, READ,
-				     CMDNONE, test->g_lun);
-
-	return ret;
-}
-
-static int ufs_test_sequence_read(struct ufs_test *test)
-{
-	int ret = 0;
-	struct timespec ts1, ts2, ts;
-	int blk_cnt = (test->g_length + BLOCK_COUNT - 1) / BLOCK_COUNT;
-	int i;
-
-	pr_err("%s : start addr:%ld, length:%ld blk_cnt:%d", __func__,
-	       test->g_start_addr, test->g_length, blk_cnt);
-
-	getnstimeofday(&ts1);
-
-	for (i = 0; i < (blk_cnt / PRDT_SG_NUM); i++) {
-		ret =
-		    ufs_test_simple_transfer(test->hba,
-					     (test->g_start_addr +
-					      i * PRDT_SG_NUM), PRDT_SG_NUM,
-					     READ, CMDNONE, test->g_lun);
-	}
-	if (blk_cnt % 128)
-		ret =
-		    ufs_test_simple_transfer(test->hba,
-					     (test->g_start_addr +
-					      (PRDT_SG_NUM *
-					       (blk_cnt / PRDT_SG_NUM))),
-					     (blk_cnt % PRDT_SG_NUM), READ,
-					     CMDNONE, test->g_lun);
-
-	getnstimeofday(&ts2);
-
-	ts = timespec_sub(ts2, ts1);
-
-	ufs_test_print_rate(test->g_length, &ts1, &ts2);
-
-	return ret;
-}
-
-static int ufs_test_random_read(struct ufs_test *test)
-{
-	int i;
-	int ret = 0;
-	struct timespec ts1, ts2, ts;
-	int blk_cnt = (test->g_length + BLOCK_COUNT - 1) / BLOCK_COUNT;
-	int rnd_addr;
-
-	pr_err("%s start addr:%ld, length:%ld blk_cnt:%d", __func__,
-	       test->g_start_addr, test->g_length, blk_cnt);
-
-	getnstimeofday(&ts1);
-
-	for (i = 0; i < (blk_cnt / PRDT_SG_NUM); i++) {
-		rnd_addr =
-		    test->g_start_addr + ufs_test_random() % (test->max_addr -
-							      test->
-							      g_start_addr);
-		if (rnd_addr > PRDT_SG_NUM)
-			rnd_addr -= PRDT_SG_NUM;
-
-		ret =
-		    ufs_test_simple_transfer(test->hba, rnd_addr, PRDT_SG_NUM,
-					     READ, CMDNONE, test->g_lun);
-	}
-	rnd_addr =
-	    test->g_start_addr + ufs_test_random() % (test->max_addr -
-						      test->g_start_addr);
-	if (rnd_addr > PRDT_SG_NUM)
-		rnd_addr -= PRDT_SG_NUM;
-	if (blk_cnt % PRDT_SG_NUM)
-		ret =
-		    ufs_test_simple_transfer(test->hba, rnd_addr,
-					     (blk_cnt % PRDT_SG_NUM), READ,
-					     CMDNONE, test->g_lun);
-
-	getnstimeofday(&ts2);
-
-	ts = timespec_sub(ts2, ts1);
-	ufs_test_print_rate(test->g_length, &ts1, &ts2);
-
-	return ret;
-}
-
-static int ufs_test_simple_write(struct ufs_test *test)
-{
-	int ret;
-
-	pr_err("%s start addr:%ld, length:%ld ", __func__, test->g_start_addr,
-	       test->g_length);
-
-	ret =
-	    ufs_test_simple_transfer(test->hba, test->g_start_addr, 1, WRITE,
-				     CMDNONE, test->g_lun);
-
-	return ret;
-}
-
-static int ufs_test_verify_write(struct ufs_test *test)
-{
-	int ret;
-
-	pr_err("%s start addr:%ld, length:%ld ", __func__, test->g_start_addr,
-	       test->g_length);
-	ret =
-	    ufs_test_simple_transfer(test->hba, test->g_start_addr, 1, WRITE,
-				     CMDNONE, test->g_lun);
-	if (ret) {
-		pr_err("%s-Write-Fail", __func__);
-		goto out;
-	}
-	ret =
-	    ufs_test_simple_transfer(test->hba, test->g_start_addr, 1, READ,
-				     CMDNONE, test->g_lun);
-	if (ret)
-		pr_err("%s-READ-Fail", __func__);
-out:
-	return ret;
-}
-
-static int ufs_test_sequence_write(struct ufs_test *test)
-{
-	int ret = 0;
-	struct timespec ts1, ts2, ts;
-	int blk_cnt = (test->g_length + BLOCK_COUNT - 1) / BLOCK_COUNT;
-	int i;
-
-	pr_err("%s : start addr:%ld, length:%ld blk_cnt:%d", __func__,
-	       test->g_start_addr, test->g_length, blk_cnt);
-
-	getnstimeofday(&ts1);
-	for (i = 0; i < (blk_cnt / PRDT_SG_NUM); i++) {
-		ret =
-		    ufs_test_simple_transfer(test->hba,
-					     (test->g_start_addr +
-					      i * PRDT_SG_NUM), PRDT_SG_NUM,
-					     WRITE, CMDNONE, test->g_lun);
-	}
-	if (blk_cnt % 128)
-		ret =
-		    ufs_test_simple_transfer(test->hba,
-					     (test->g_start_addr +
-					      (PRDT_SG_NUM *
-					       (blk_cnt / PRDT_SG_NUM))),
-					     (blk_cnt % PRDT_SG_NUM), WRITE,
-					     CMDNONE, test->g_lun);
-	getnstimeofday(&ts2);
-
-	ts = timespec_sub(ts2, ts1);
-	ufs_test_print_rate(test->g_length, &ts1, &ts2);
-
-	return ret;
-}
-
-static int ufs_test_random_write(struct ufs_test *test)
-{
-	int i;
-	int ret = 0;
-	struct timespec ts1, ts2, ts;
-	int blk_cnt = (test->g_length + BLOCK_COUNT - 1) / BLOCK_COUNT;
-	int rnd_addr;
-
-	pr_err("%s start addr:%ld, length:%ld blk_cnt:%d", __func__,
-	       test->g_start_addr, test->g_length, blk_cnt);
-
-	getnstimeofday(&ts1);
-
-	for (i = 0; i < (blk_cnt / PRDT_SG_NUM); i++) {
-		rnd_addr =
-		    test->g_start_addr + ufs_test_random() % (test->max_addr -
-							      test->
-							      g_start_addr);
-		if (rnd_addr > PRDT_SG_NUM)
-			rnd_addr -= PRDT_SG_NUM;
-
-		ret =
-		    ufs_test_simple_transfer(test->hba, rnd_addr, PRDT_SG_NUM,
-					     WRITE, CMDNONE, test->g_lun);
-	}
-	rnd_addr =
-	    test->g_start_addr + ufs_test_random() % (test->max_addr -
-						      test->g_start_addr);
-	if (rnd_addr > PRDT_SG_NUM)
-		rnd_addr -= PRDT_SG_NUM;
-	if (blk_cnt % PRDT_SG_NUM)
-		ret =
-		    ufs_test_simple_transfer(test->hba, rnd_addr,
-					     (blk_cnt % PRDT_SG_NUM), WRITE,
-					     CMDNONE, test->g_lun);
-
-	getnstimeofday(&ts2);
-
-	ts = timespec_sub(ts2, ts1);
-	ufs_test_print_rate(test->g_length, &ts1, &ts2);
-
-	return ret;
-}
-
-static const struct ufs_test_case ufs_scsi_cases[] = {
-	/*basic_scsi_cmd: 0~7 */
-	{
-	 .name = "test_unit_ready_00",
-	 .run = ufs_scsi_test_unit_ready,
-	 },
-	{
-	 .name = "start_stop_unit_01",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_scsi_start_stop_unit,
-	 },
-	{
-	 .name = "inqury_02",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_scsi_send_inqury,
-	 },
-	{
-	 .name = "requset_sense_03",
-	 .run = ufs_scsi_read_capacity,
-	 },
-	{
-	 .name = "report_lun_04",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_scsi_report_lun,
-	 },
-	{
-	 .name = "mode_select_05",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_scsi_mode_select,
-	 },
-	{
-	 .name = "mode_sense_06",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_scsi_mode_sense,
-	 },
-	{
-	 .name = "sync_cache_07",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_scsi_sync_cache,
-	 },
-	{
-	 .name = "verify_08",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_scsi_verify,
-	 },
-	{
-	 .name = "request_sense_09",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_scsi_request_sense,
-	 },
-	/*scsi_protocol_test:08~14 */
-	{
-	 .name = "protocol_inqury_test_10",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_protocol_inquiry,
-	 },
-	{
-	 .name = "protocol_mode_sense_test_11",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_protocol_mode_sense,
-	 },
-	{
-	 .name = "protocol_report_lun_test_12",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_protocol_report_lun,
-	 },
-	{
-	 .name = "protocol_sync_cache_test_13",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_protocol_sync_cache,
-	 },
-	{
-	 .name = "protocol_start_stop_unit_test_14",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_protocol_start_stop_unit,
-	},
-	{
-	 .name = "protocol_verify_test_15",
-	 .run = ufs_test_protocol_verify,
-	 },
-	/*basic_func_test:16~20 */
-	{
-	 .name = "basic_lun_test_16",
-	 .run = dump_and_check_lun_info,
-	 },
-	{
-	 .name = "basic_bkops_func_test_17",
-	 .run = check_and_test_bkops,
-	 },
-	{
-	 .name = "basic_ssu_func_test_18",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_ssu_powerdown,
-	 },
-	{
-	 .name = "basic_context_id_test_19",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_contextID_info,
-	 },
-	{
-	 .name = "basic_system_data_tag_test_20",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_system_data_tag,
-	 },
-	{
-	 .name = "basic_erase_or_discard_test_21",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_erase_or_discard,
-	 },
-	{
-	 .name = "basic_get_device_health_report_22",
-	 .run = ufs_test_health_report,
-	 },
-	/*basic_rw_test:22~28, just read_write 128K for one slot*/
-	{
-	 .name = "test_read_23",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_simple_read,
-	 },
-	{
-	 .name = "test_write_24",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_simple_write,
-	 },
-	{
-	 .name = "test_verify_write_25",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_verify_write,
-	 },
-	{
-	 .name = "test_seq_read_26",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_sequence_read,
-	 },
-	{
-	 .name = "test_random_read_27",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_random_read,
-	 },
-	{
-	 .name = "test_seq_write_28",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_sequence_write,
-	 },
-	{
-	 .name = "test_random_write_29",
-	 .prepare = ufs_test_prepare,
-	 .run = ufs_test_random_write,
-	 },
-};
-
-static void ufs_test_run(int testcase, struct ufs_test *test)
-{
-	int ret;
-	int i;
-	int start, end;
-
-	if ((testcase >= 0) && (testcase < ARRAY_SIZE(ufs_scsi_cases))) {
-		start = testcase;
-		end = testcase + 1;
-	} else if (testcase == -1) {
-		start = 0;
-		end = ARRAY_SIZE(ufs_scsi_cases);
-		pr_info("Starting all tests ....\n");
-	} else {
-		pr_info("Invalid param\n");
-		return;
-	}
-
-	for (i = start; i < end; i++) {
-		struct ufs_test_general_result *gr;
-
-		pr_info("Starting testcase :%d-%s...\n", i,
-			ufs_scsi_cases[i].name);
-		if (ufs_scsi_cases[i].prepare) {
-			ret = ufs_scsi_cases[i].prepare(test);
-			if (ret) {
-				pr_info("%s Prepare stage failed! ret:(%d)\n",
-					ufs_scsi_cases[i].name, ret);
-				continue;
-			}
-		}
-
-		gr = kzalloc(sizeof(struct ufs_test_general_result),
-			     GFP_KERNEL);
-		if (gr) {
-			INIT_LIST_HEAD(&gr->tr_lst);
-
-			/* Assign data what we know already */
-			gr->testcase = i;
-
-			/* Append container to global one */
-			list_add_tail(&gr->link, &ufs_test_result);
-		}
-
-		ret = ufs_scsi_cases[i].run(test);
-		/* Save the result */
-		if (gr)
-			gr->result = ret;
-
-		if (ufs_scsi_cases[i].cleanup) {
-			ret = ufs_scsi_cases[i].cleanup(test);
-			if (ret) {
-				pr_info("Warning: Cleanup stage failed! (%d)\n",
-						ret);
-			}
-		}
-	}
-
-	pr_info(" Tests completed.\n");
-}
-
-static void ufs_test_free_result(struct ufs_test_ud *utd)
-{
-	struct ufs_test_general_result *gr, *grs;
-
-	mutex_lock(&ufs_test_lock);
-
-	list_for_each_entry_safe(gr, grs, &ufs_test_result, link) {
-		struct ufs_test_transfer_result *tr, *trs;
-
-		list_for_each_entry_safe(tr, trs, &gr->tr_lst, link) {
-			list_del(&tr->link);
-			kfree(tr);
-		}
-
-		list_del(&gr->link);
-		kfree(gr);
-	}
-
-	mutex_unlock(&ufs_test_lock);
-}
-
-static int ufs_test_show(struct seq_file *file, void *data)
-{
-	struct ufs_test_general_result *gr;
-
-	mutex_lock(&ufs_test_lock);
-
-	list_for_each_entry(gr, &ufs_test_result, link) {
-		struct ufs_test_transfer_result *tr;
-
-		seq_printf(file, "Test %d: %d\n", gr->testcase, gr->result);
-
-		list_for_each_entry(tr, &gr->tr_lst, link) {
-			seq_printf(file, "%u %d %lu.%09lu %u %u.%02u\n",
-				   tr->count, tr->sectors,
-				   (unsigned long)tr->ts.tv_sec,
-				   (unsigned long)tr->ts.tv_nsec,
-				   tr->rate, tr->iops / 100, tr->iops % 100);
-		}
-	}
-
-	mutex_unlock(&ufs_test_lock);
-
-	return 0;
-}
-
-static int ufs_test_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, ufs_test_show, inode->i_private);
-}
-
-static ssize_t ufs_scsi_write(struct file *file, const char __user *buf,
-			      size_t count, loff_t *ppos)
-{
-	char lbuf[256];
-	char tmp_buf[12];
-	char *pStr;
-	int idx;
-	int ret = 0;
-	long testcase;
-	struct ufs_test test = { 0 };
-	u32 par[8] = { 0 };
-
-	if (count >= sizeof(lbuf))
-		return -EINVAL;
-
-	if (copy_from_user(lbuf, buf, count))
-		return -EFAULT;
-
-	pr_err("scsi_write:%d\n", (int)count);
-
-	lbuf[count] = '\0';
-	pStr = lbuf;
-
-	ret = __find_substr(pStr, tmp_buf, &pStr);
-	if (ret)
-		return -EINVAL;
-	if (kstrtol(tmp_buf, 10, &testcase))
-		return -EINVAL;
-
-	pr_err("testcase-id:%ld\n", testcase);
-
-	idx = 0;
-	while (0 == ret) {
-		ret = __find_substr(pStr, tmp_buf, &pStr);
-		if (ret)
-			break;
-
-		if (kstrtou32(tmp_buf, 10, &par[idx]))
-			return -EINVAL;
-
-		idx++;
-		if (idx == 8)
-			break;
-	}
-
-	test.hba = hba_addr;
-	test.g_lun = par[0];
-	test.g_start_addr = par[1];
-	test.g_length = par[2];
-	test.g_trunk_size = par[3];
-	test.g_data_mode = par[4];
-	test.g_cmd = par[5];
-	test.g_para = par[6];
-	test.g_resp = par[7];
-
-	ufs_test_free_result(NULL);
-	mutex_lock(&ufs_test_lock);
-	ufs_test_run(testcase, &test);
-	mutex_unlock(&ufs_test_lock);
-
-	return count;
-}
-
-const struct file_operations ufs_scsi_fops = {
-	.open = ufs_test_open,
-	.read = seq_read,
-	.write = ufs_scsi_write,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-struct query_flag_param {
-	char *name;
-	enum flag_idn idn;
-};
-
-struct query_attr_param {
-	char *name;
-	enum attr_idn idn;
-	u8 index;
-	u8 selector;
-};
-
-struct query_desc_param {
-	char *name;
-	enum desc_idn idn;
-	u8 index;
-	u8 selector;
-	int buf_len;
-	u8 result[3];
-};
-
-struct query_desc_param query_desc_params[] = {
-	{"device", QUERY_DESC_IDN_DEVICE, 0, 0, QUERY_DESC_DEVICE_MAX_SIZE,
-	 {0x40, 0x0, 0x0} },
-	{"config", QUERY_DESC_IDN_CONFIGURAION, 0, 0,
-	 QUERY_DESC_CONFIGURAION_MAX_SIZE, {0x90, 0x1, 0x0} },
-	{"unit", QUERY_DESC_IDN_UNIT, 0, 0, QUERY_DESC_UNIT_MAX_SIZE,
-	 {0x23, 0x2, 0x0} },
-	{"inter", QUERY_DESC_IDN_INTERCONNECT, 0, 0, QUERY_DESC_UNIT_MAX_SIZE,
-	 {0x6, 0x4, 0x1} },
-	{"sting", QUERY_DESC_IDN_STRING, 0, 0, QUERY_DESC_STRING_MAX_SIZE,
-	 {0x8, 0x5, 0x0} },
-	{"gometry", QUERY_DESC_IDN_GEOMETRY, 0, 0, QUERY_DESC_GEOMETRY_MAZ_SIZE,
-	 {0x44, 0x7, 0x0} },
-	{"power", QUERY_DESC_IDN_POWER, 0, 0, QUERY_DESC_POWER_MAX_SIZE,
-	 {0x62, 0x8, 0x81} },
-	{"invalid", 0xFF, 0, 0, 0xFE, {0xa, 0xFF, 0x0} },
-	{"wconfig", QUERY_DESC_IDN_CONFIGURAION, 0, 0,
-	 QUERY_DESC_CONFIGURAION_MAX_SIZE},
-	{"winvali", QUERY_DESC_IDN_CONFIGURAION, 0, 0,
-	 QUERY_DESC_CONFIGURAION_MAX_SIZE},
-	{"rewrite", QUERY_DESC_IDN_CONFIGURAION, 0, 0,
-	 QUERY_DESC_CONFIGURAION_MAX_SIZE},
-};
-
-struct query_flag_param query_flag_params[] = {
-	{"fdevInit", QUERY_FLAG_IDN_FDEVICEINIT},
-	{"PermWPE", QUERY_FLAG_IDN_PERMANENT_WPE},
-	{"PwrOnWPE", QUERY_FLAG_IDN_PWR_ON_WPE},
-	{"BkopsOn", QUERY_FLAG_IDN_BKOPS_EN},
-	{"PuregeEn", QUERY_FLAG_IDN_PURGE_ENABLE},
-	{"fphyres", QUERY_FLAG_IDN_FPHYRESOURCEREMOVAL},
-	{"BusyRtc", QUERY_FLAG_IDN_BUSY_RTC},
-	{"invalid", 0xFF},
-};
-
-struct query_attr_param query_attr_params[] = {
-	{"BootLuEn", QUERY_ATTR_IDN_BOOT_LU_EN},
-	{"PwrMode", QUERY_ATTR_IDN_POWER_MODE},
-	{"ActiveIcc", QUERY_ATTR_IDN_ACTIVE_ICC_LVL},
-	{"DataEn", QUERY_ATTR_IDN_OOO_DATA_EN},
-	{"BkopsStat", QUERY_ATTR_IDN_BKOPS_STATUS},
-	{"PurgeStat", QUERY_ATTR_IDN_PURGE_STATUS},
-	{"DataIn", QUERY_ATTR_IDN_MAX_DATA_IN},
-	{"DataOut", QUERY_ATTR_IDN_MAX_DATA_OUT},
-	{"RefClk", QUERY_ATTR_IDN_REF_CLK_FREQ},
-	{"ConDesc", QUERY_ATTR_IDN_CONF_DESC_LOCK},
-	{"MaxRtt", QUERY_ATTR_IDN_MAX_NUM_OF_RTT},
-	{"EECon", QUERY_ATTR_IDN_EE_CONTROL},
-	{"EEStat", QUERY_ATTR_IDN_EE_STATUS},
-	{"SecPass", QUERY_ATTR_IDN_SECONDS_PASSED},
-	{"CntxCon", QUERY_ATTR_IDN_CNTX_CONF},
-	{"PrgBlkN", QUERY_ATTR_IDN_CORR_PRG_BLK_NUM},
-};
-
-int query_desc_subtype;
-void query_parse_subtype(long testcase, char *subtype)
-{
-	int i;
-	int len;
-
-	if (testcase == 0 || testcase == 1)
-		len = ARRAY_SIZE(query_desc_params);
-	if (testcase == 2)
-		len = ARRAY_SIZE(query_flag_params);
-	if (testcase == 3)
-		len = ARRAY_SIZE(query_attr_params);
-
-	pr_info("ufs_test-testcase:%ld len:%d\n", testcase, len);
-	for (i = 0; i < len; i++) {
-		if (testcase == 0 || testcase == 1) {
-			if (0 ==
-			    strncmp(subtype, query_desc_params[i].name,
-				    strlen(query_desc_params[i].name))) {
-				query_desc_subtype = i;
-				return;
-			}
-		}
-		if (testcase == 2) {
-			if (0 ==
-			    strncmp(subtype, query_flag_params[i].name,
-				    strlen(query_flag_params[i].name))) {
-				query_desc_subtype = i;
-				return;
-			}
-		}
-		if (testcase == 3) {
-			if (0 ==
-			    strncmp(subtype, query_attr_params[i].name,
-				    strlen(query_attr_params[i].name))) {
-				query_desc_subtype = i;
-				return;
-			}
-		}
-	}
-}
-
-static int query_read_desc(void)
-{
-
-	u8 *desc_buf;
-	int buf_len;
-	int err = 0;
-	struct query_desc_param *param = &query_desc_params[query_desc_subtype];
-
-	buf_len = param->buf_len;
-	desc_buf = kmalloc(sizeof(u8 *) * param->buf_len, GFP_KERNEL);
-	if (!desc_buf)
-		return -ENOMEM;
-
-	err =
-	    ufshcd_query_descriptor_retry(hba_addr, UPIU_QUERY_OPCODE_READ_DESC,
-					  param->idn, param->index,
-					  param->selector, desc_buf, &buf_len);
-	if (!err) {
-	    pr_info("name:%s idn:0x%x buf_len:%d ", param->name,
-	       param->idn, buf_len);
-	    dump_sense_buffer(desc_buf, buf_len);
-	} else {
-		kfree(desc_buf);
-		return err;
-	}
-
-	err = memcmp(param->result, desc_buf, 3);
-	if (!err)
-		pr_info("query-read %s success", param->name);
-	else
-		pr_info("query-read %s failed", param->name);
-
-	kfree(desc_buf);
-
-	return 0;
-}
-
-static int query_write_desc(void)
-{
-	u8 *desc_buf;
-	int ret = 0;
-	struct query_desc_param *param = &query_desc_params[query_desc_subtype];
-	int buf_len;
-
-	pr_info("ufs_test_%s\n", __func__);
-
-	desc_buf = kmalloc(sizeof(u8 *) * param->buf_len, GFP_KERNEL);
-
-	ret =
-	    ufshcd_query_descriptor_retry(hba_addr, UPIU_QUERY_OPCODE_READ_DESC,
-					  param->idn, param->index,
-					  param->selector, desc_buf, &buf_len);
-
-	ret =
-	    ufshcd_query_descriptor_retry(hba_addr,
-					  UPIU_QUERY_OPCODE_WRITE_DESC,
-					  param->idn, param->index,
-					  param->selector, desc_buf,
-					  &param->buf_len);
-
-	kfree(desc_buf);
-
-	return 0;
-}
-
-static int query_flag(void)
-{
-	int ret = 0;
-	bool flag;
-	struct query_flag_param *param = &query_flag_params[query_desc_subtype];
-
-	ret = ufshcd_query_flag(hba_addr, UPIU_QUERY_OPCODE_READ_FLAG,
-				param->idn, &flag);
-	if (!ret) {
-	    pr_info("name:%s idn:0x%x flag:%08x ", param->name,
-	       param->idn, flag);
-	}
-
-	ret = ufshcd_query_flag(hba_addr, UPIU_QUERY_OPCODE_READ_FLAG,
-				QUERY_FLAG_IDN_BKOPS_EN, &flag);
-	ret = ufshcd_query_flag(hba_addr, UPIU_QUERY_OPCODE_SET_FLAG,
-				QUERY_FLAG_IDN_BKOPS_EN, NULL);
-	ret = ufshcd_query_flag(hba_addr, UPIU_QUERY_OPCODE_CLEAR_FLAG,
-				QUERY_FLAG_IDN_BKOPS_EN, NULL);
-
-	if (ret == 0)
-		pr_err("query_flag SUCCESS\n");
-	return 0;
-}
-
-static int query_attr(void)
-{
-	u32 attr;
-	int ret = 0;
-	struct query_attr_param *param = &query_attr_params[query_desc_subtype];
-	u32 val;
-	int err;
-
-	ret = ufshcd_query_attr(hba_addr, UPIU_QUERY_OPCODE_READ_ATTR,
-				param->idn, param->index, param->selector,
-				&attr);
-	if (!ret)
-		pr_info("name:%s-idn:0x%x-attr_value:%d",
-				param->name, param->idn, attr);
-	val = hba_addr->ee_ctrl_mask & ~MASK_EE_URGENT_BKOPS;
-	val &= 0xFFFF;
-	err = ufshcd_query_attr(hba_addr, UPIU_QUERY_OPCODE_WRITE_ATTR,
-				QUERY_ATTR_IDN_EE_CONTROL, 0, 0, &val);
-	if (!err)
-		hba_addr->ee_ctrl_mask &= ~MASK_EE_URGENT_BKOPS;
-	val = hba_addr->ee_ctrl_mask | MASK_EE_URGENT_BKOPS;
-	val &= 0xFFFF;
-	err = ufshcd_query_attr(hba_addr, UPIU_QUERY_OPCODE_WRITE_ATTR,
-				QUERY_ATTR_IDN_EE_CONTROL, 0, 0, &val);
-	if (!err)
-		hba_addr->ee_ctrl_mask |= MASK_EE_URGENT_BKOPS;
-
-	return 0;
-}
-
-static const struct ufs_test_query_case ufs_query_cases[] = {
-	/*protocol_uic_test:31~34 */
-	{
-	 .name = "query_read_desc",
-	 .run = query_read_desc,
-	 },
-	{
-	 .name = "query_write_desc",
-	 .run = query_write_desc,
-	 },
-	{
-	 .name = "query_flag",
-	 .run = query_flag,
-	 },
-	{
-	 .name = "query_attr",
-	 .run = query_attr,
-	 },
-};
-
-static ssize_t ufs_query_write(struct file *file, const char __user *buf,
-			       size_t count, loff_t *ppos)
-{
-	int err;
-	long testcase;
-	char lbuf[128];
-	char tmp[64];
-	char *pSpace;
-	int digit_len;
-
-	if (copy_from_user(lbuf, buf, count > 127 ? 127 : count))
-		return -EFAULT;
-
-	lbuf[(count > 127 ? 127 : count)] = '\0';
-	pSpace = strstr(lbuf, " ");
-	if (!pSpace)
-		return -EINVAL;
-
-	digit_len = pSpace - lbuf;
-	if ((digit_len <= 0) || (digit_len >= 64)) {
-		pr_info("[ufs_test_query_write]: %d, %p, %p\n", digit_len,
-		       pSpace, lbuf);
-		return -EINVAL;
-	}
-
-	memcpy(tmp, lbuf, digit_len);
-	tmp[digit_len] = 0;
-	err = kstrtol(tmp, 10, &testcase);
-	if (err) {
-		pr_info("[ufs_test_query_write]: kstrtol failed, err: %d\n",
-		       err);
-		return err;
-	}
-
-	while (' ' == (*pSpace))
-		pSpace++;
-	query_parse_subtype(testcase, pSpace);
-	if (query_desc_subtype < ARRAY_SIZE(query_desc_params))
-		pr_info("[ufs_test_query_write] %d, %s\n", query_desc_subtype,
-		       query_desc_params[query_desc_subtype].name);
-	else {
-		pr_info
-		    ("invalid query_desc_subtype %d, %s\n",
-		     query_desc_subtype, pSpace);
-		return -EINVAL;
-	}
-
-	pr_info("%s:the ufs_test will run testcase:%ld\n", __func__, testcase);
-
-	mutex_lock(&ufs_test_lock);
-	ufs_query_cases[testcase].run();
-	mutex_unlock(&ufs_test_lock);
-
-	msleep(1000);
-
-	pr_info("%s: Completed all the ufs test iterations.", __func__);
-
-	return count;
-}
-
-const struct file_operations ufs_query_fops = {
-	.open = ufs_test_open,
-	.read = seq_read,
-	.write = ufs_query_write,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static int mtf_testlist_show(struct seq_file *sf, void *data)
-{
-	int i;
-
-	mutex_lock(&ufs_test_lock);
-
-	for (i = 0; i < ARRAY_SIZE(ufs_scsi_cases); i++)
-		seq_printf(sf, "%d:\t%s\n", i, ufs_scsi_cases[i].name);
-
-	for (i = 0; i < ARRAY_SIZE(ufs_query_cases); i++)
-		seq_printf(sf, "%d:\t%s\n", i, ufs_query_cases[i].name);
-
-	mutex_unlock(&ufs_test_lock);
-
-	return 0;
-}
-
-static int mtf_testlist_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, mtf_testlist_show, inode->i_private);
-}
-
-static const struct file_operations ufs_test_fops_testlist = {
-	.open = mtf_testlist_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static void ufs_test_free_dbgfs_file(void)
-{
-	struct ufs_test_debugfs_file *df, *dfs;
-
-	mutex_lock(&ufs_test_lock);
-
-	list_for_each_entry_safe(df, dfs, &ufs_test_file_test, link) {
-		debugfs_remove(df->file);
-		list_del(&df->link);
-		kfree(df);
-	}
-
-	mutex_unlock(&ufs_test_lock);
-}
-
-static int ufs_test_register_dbgfs_file(struct ufs_test_ud *utd,
-					const char *name, umode_t mode,
-					const struct file_operations *fops)
-{
-	struct dentry *file = NULL;
-	struct ufs_test_debugfs_file *df;
-
-	if (utd->debugfs_root)
-		file = debugfs_create_file(name, mode, utd->debugfs_root,
-					   utd, fops);
-
-	if (IS_ERR_OR_NULL(file)) {
-		pr_err("Can't create %s. Perhaps debugfs is disabled.\n", name);
-		return -ENODEV;
-	}
-
-	df = kmalloc(sizeof(struct ufs_test_debugfs_file), GFP_KERNEL);
-	if (!df) {
-		debugfs_remove(file);
-		pr_err("Can't allocate memory for internal usage.\n");
-		return -ENOMEM;
-	}
-
-	df->hba = utd->hba;
-	df->file = file;
-
-	list_add(&df->link, &ufs_test_file_test);
-	return 0;
-}
-
-static int ufs_test_debugfs_init(struct ufs_test_ud *utd)
-{
-	int ret;
-
-	mutex_lock(&ufs_test_lock);
-
-	utd->debugfs_root = debugfs_create_dir("ufs_test", NULL);
-
-	ret = ufs_test_register_dbgfs_file(utd, "scsi_test", S_IWUSR | S_IRUGO,
-					   &ufs_scsi_fops);
-	if (ret)
-		goto err;
-
-	ret = ufs_test_register_dbgfs_file(utd, "query_test", S_IWUSR | S_IRUGO,
-					   &ufs_query_fops);
-	if (ret)
-		goto err;
-
-	ret = ufs_test_register_dbgfs_file(utd, "testlist", S_IWUSR | S_IRUGO,
-					   &ufs_test_fops_testlist);
-	if (ret)
-		goto err;
-err:
-	mutex_unlock(&ufs_test_lock);
-
-	return ret;
-}
-
-static struct ufs_test_ud utd_test;
-
-static int __init ufs_test_init(void)
-{
-	struct ufs_test_ud *utd = &utd_test;
-	int ret;
-
-	utd->hba = hba_addr;
-
-	ret = ufs_test_debugfs_init(utd);
-
-	return ret;
-}
-
-static void __exit ufs_test_exit(void)
-{
-	struct ufs_test_ud *utd = &utd_test;
-
-	ufs_test_free_dbgfs_file();
-
-	if (utd->debugfs_root != NULL)
-		debugfs_remove(utd->debugfs_root);
-}
-
-module_init(ufs_test_init);
-module_exit(ufs_test_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("UFS host controller Pltform bus based glue driver");
-MODULE_VERSION(UFSHCD_DRIVER_VERSION);
diff --git a/drivers/scsi/ufs/ufs_vendor_mode.c b/drivers/scsi/ufs/ufs_vendor_mode.c
deleted file mode 100644
index e1d26a9..0000000
--- a/drivers/scsi/ufs/ufs_vendor_mode.c
+++ /dev/null
@@ -1,166 +0,0 @@
-#ifdef CONFIG_HUAWEI_UFS_VENDOR_MODE
-/*enter vendor mode*/
-#include "ufs_vendor_mode.h"
-#include "ufshcd.h"
-
-static int wait_for_ufs_all_complete(struct ufs_hba *hba, int timeout_ms)
-{
-	msleep(1);
-	while (timeout_ms-- > 0) {
-		if (!hba->outstanding_reqs){
-			return 0;
-		}
-		udelay(1000);
-	}
-	pr_err("%s: outstanding req : 0x%lx\n", __func__, hba->outstanding_reqs);
-	return -ETIMEDOUT;
-}
-
-int ufs_ioctl_vendor_package(struct ufs_hba *hba,
-							struct ufs_ioctl_vendor_state_t *ufs_vendor_ioctl_state_p,
-							void __user *buffer)
-{
-	char data_flag;
-	int err = 0;
-
-	dev_info(hba->dev, "%s: ioctl vendor cmd buffering\n", __func__);
-
-	if(ufs_vendor_ioctl_state_p->cmd_count > UFS_IOCTL_VENDOR_PACKAGE_COUNT_MAX)
-	{
-		dev_err(hba->dev, "%s: ioctl vendor cmd over count, %d\n", __func__, ufs_vendor_ioctl_state_p->cmd_count);
-		err = -EINVAL;
-		goto out;
-	}
-	/*init vendor_cmd memory*/
-	if(!ufs_vendor_ioctl_state_p->vendor_cmd)
-	{
-		ufs_vendor_ioctl_state_p->vendor_cmd =
-			kzalloc( (size_t)(sizeof(struct ufs_vendor_cmd)*UFS_IOCTL_VENDOR_PACKAGE_COUNT_MAX), GFP_KERNEL);
-		if(!ufs_vendor_ioctl_state_p->vendor_cmd)
-		{
-			dev_err(hba->dev, "%s: vendor cmd mem alloc error\n", __func__);
-			err = -ENOMEM;
-			goto out;
-		}
-		ufs_vendor_ioctl_state_p->cmd_count = 0;
-	}
-	/*get user cmd*/
-	err = copy_from_user( &(ufs_vendor_ioctl_state_p->vendor_cmd[ufs_vendor_ioctl_state_p->cmd_count].vendor_cdb),
-			buffer, UFS_IOCTL_VENDOR_CDB_LEN);
-	if(err)
-	{
-		dev_err(hba->dev, "%s: copy cdb error\n", __func__);
-		goto out;
-	}
-
-	err = copy_from_user(&data_flag, buffer+UFS_IOCTL_VENDOR_CDB_LEN, 1);
-	if(err)
-	{
-		dev_err(hba->dev, "%s: copy data flag\n", __func__);
-		goto out;
-	}
-	if(data_flag)
-	{
-		ufs_vendor_ioctl_state_p->vendor_cmd[ufs_vendor_ioctl_state_p->cmd_count].buf =
-			kzalloc((size_t)(PAGE_SIZE), GFP_KERNEL);
-		if(ufs_vendor_ioctl_state_p->vendor_cmd[ufs_vendor_ioctl_state_p->cmd_count].buf == NULL)
-		{
-			err = -ENOMEM;
-			goto out;
-		}
-		ufs_vendor_ioctl_state_p->vendor_cmd[ufs_vendor_ioctl_state_p->cmd_count].data_flag = 1;
-	}
-	ufs_vendor_ioctl_state_p->cmd_count++;
-
-out:
-	return err;
-
-}
-
-int ufs_ioctl_vendor_package_tick(struct ufs_hba *hba,
-								struct scsi_device *dev,
-								struct ufs_ioctl_vendor_state_t *ufs_vendor_ioctl_state_p,
-								void __user *buffer)
-{
-	int err = 0;
-	int index = 0;
-	struct ufs_vendor_cmd* vendor_cmd;
-	char* buf;
-
-	dev_info(hba->dev, "%s: send all vendor cmd\n", __func__);
-	/*check if vendor_cmd has already init*/
-	if(ufs_vendor_ioctl_state_p->vendor_cmd == NULL)
-	{
-		dev_err(hba->dev, "%s: vendor package cmd not init\n", __func__);
-		err = -EINVAL;
-		goto out;
-	}
-
-	scsi_block_requests(hba->host);
-	err = wait_for_ufs_all_complete(hba, 5000);
-	dev_info(hba->dev, "%s: block the queue, ret == %d\n", __func__, err);
-	for(index = 0; index < ufs_vendor_ioctl_state_p->cmd_count; index++)
-	{
-		vendor_cmd = &(ufs_vendor_ioctl_state_p->vendor_cmd[index]);
-		if ((vendor_cmd->vendor_cdb[0] == FORMAT_UNIT)
-			|| (vendor_cmd->vendor_cdb[0] == READ_6)
-			|| (vendor_cmd->vendor_cdb[0] == READ_10)
-			|| (vendor_cmd->vendor_cdb[0] == READ_16)
-			|| (vendor_cmd->vendor_cdb[0] == UNMAP)
-			|| (vendor_cmd->vendor_cdb[0] == WRITE_6)
-			|| (vendor_cmd->vendor_cdb[0] == WRITE_10)
-			|| (vendor_cmd->vendor_cdb[0] == WRITE_16))
-		{
-			dev_err(hba->dev, "%s: not allow ioctl this cmd:0x%x\n", __func__, vendor_cmd->vendor_cdb[0]);
-			goto error_out;
-		}
-
-		buf = NULL;
-		if(vendor_cmd->data_flag)
-		{
-			if(vendor_cmd->buf == NULL)
-			{
-				pr_err("data bufffer is null\n");
-				err = -EINVAL;
-				goto error_out;
-			}
-			buf = vendor_cmd->buf;
-		}
-		err = ufshcd_send_vendor_scsi_cmd(hba, dev, vendor_cmd->vendor_cdb, (void*)buf);
-		if(err)
-		{
-			dev_err(hba->dev, "%s: send cmd[0x%x] error %d\n", __func__, vendor_cmd->vendor_cdb[0],err);
-			goto out;
-		}
-		if(buf)
-		{
-			err = copy_to_user( buffer+(unsigned int)(index*UFS_VENDOR_DATA_SIZE_MAX), buf, UFS_VENDOR_DATA_SIZE_MAX);
-			if(err){
-				dev_err(hba->dev, "%s: copy to user error %d\n", __func__, err);
-				goto error_out;
-			}
-		}
-	}
-
-error_out:
-	scsi_unblock_requests(hba->host);
-	if(ufs_vendor_ioctl_state_p->vendor_cmd)
-	{
-		for(index = 0; index < ufs_vendor_ioctl_state_p->cmd_count; index++)
-		{
-			if(ufs_vendor_ioctl_state_p->vendor_cmd[index].data_flag
-				&&ufs_vendor_ioctl_state_p->vendor_cmd[index].buf)
-			{
-				kfree(ufs_vendor_ioctl_state_p->vendor_cmd[index].buf);
-				ufs_vendor_ioctl_state_p->vendor_cmd[index].buf = NULL;
-			}
-		}
-		kfree(ufs_vendor_ioctl_state_p->vendor_cmd);
-		ufs_vendor_ioctl_state_p->vendor_cmd = NULL;
-	}
-	ufs_vendor_ioctl_state_p->cmd_count = 0;
-
-out:
-	return err;
-}
-#endif
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
deleted file mode 100755
index d664236..0000000
--- a/drivers/spi/spidev.c
+++ /dev/null
@@ -1,1277 +0,0 @@
-/*
- * Simple synchronous userspace interface to SPI devices
- *
- * Copyright (C) 2006 SWAPP
- *	Andrea Paterniani <a.paterniani@swapp-eng.it>
- * Copyright (C) 2007 David Brownell (simplification, cleanup)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/ioctl.h>
-#include <linux/fs.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/list.h>
-#include <linux/errno.h>
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <linux/compat.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-
-#include <linux/spi/spi.h>
-#include <linux/spi/spidev.h>
-
-#include <linux/uaccess.h>
-
-
-/*
- * This supports access to SPI devices using normal userspace I/O calls.
- * Note that while traditional UNIX/POSIX I/O semantics are half duplex,
- * and often mask message boundaries, full SPI support requires full duplex
- * transfers.  There are several kinds of internal message boundaries to
- * handle chipselect management and other protocol options.
- *
- * SPI has a character major number assigned.  We allocate minor numbers
- * dynamically using a bitmask.  You must use hotplug tools, such as udev
- * (or mdev with busybox) to create and destroy the /dev/spidevB.C device
- * nodes, since there is no fixed association of minor numbers with any
- * particular SPI bus or device.
- */
-#define SPIDEV_MAJOR			153	/* assigned */
-#define N_SPI_MINORS			32	/* ... up to 256 */
-
-static DECLARE_BITMAP(minors, N_SPI_MINORS);
-
-
-/* Bit masks for spi_device.mode management.  Note that incorrect
- * settings for some settings can cause *lots* of trouble for other
- * devices on a shared bus:
- *
- *  - CS_HIGH ... this device will be active when it shouldn't be
- *  - 3WIRE ... when active, it won't behave as it should
- *  - NO_CS ... there will be no explicit message boundaries; this
- *	is completely incompatible with the shared bus model
- *  - READY ... transfers may proceed when they shouldn't.
- *
- * REVISIT should changing those flags be privileged?
- */
-#define SPI_MODE_MASK		(SPI_CPHA | SPI_CPOL | SPI_CS_HIGH \
-				| SPI_LSB_FIRST | SPI_3WIRE | SPI_LOOP \
-				| SPI_NO_CS | SPI_READY | SPI_TX_DUAL \
-				| SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)
-
-struct spidev_data {
-	dev_t			devt;
-	spinlock_t		spi_lock;
-	struct spi_device	*spi;
-	struct list_head	device_entry;
-
-	/* TX/RX buffers are NULL unless this device is open (users > 0) */
-	struct mutex		buf_lock;
-	unsigned		users;
-	u8			*tx_buffer;
-	u8			*rx_buffer;
-	u32			speed_hz;
-};
-
-static LIST_HEAD(device_list);
-static DEFINE_MUTEX(device_list_lock);/*lint !e651 !e708 !e570 !e64 !e785 */
-
-static unsigned bufsiz = 256*1024;
-module_param(bufsiz, uint, S_IRUGO);
-/*lint -e753 -esym(753,*) */
-MODULE_PARM_DESC(bufsiz, "data bytes in biggest supported SPI message");
-/*lint -e753 +esym(753,*) */
-/*-------------------------------------------------------------------------*/
-
-static ssize_t
-spidev_sync(struct spidev_data *spidev, struct spi_message *message)
-{
-	DECLARE_COMPLETION_ONSTACK(done);
-	int status;
-	struct spi_device *spi;
-
-	spin_lock_irq(&spidev->spi_lock);
-	spi = spidev->spi;
-	spin_unlock_irq(&spidev->spi_lock);
-
-	if (spi == NULL)
-		status = -ESHUTDOWN;
-	else
-		status = spi_sync(spi, message);
-
-	if (status == 0)
-			status = (int)message->actual_length;
-
-	return status;
-}
-
-static inline ssize_t
-spidev_sync_write(struct spidev_data *spidev, size_t len)
-{
-	struct spi_transfer	t = {
-			.tx_buf		= spidev->tx_buffer,
-			.len		= (unsigned)len,
-			.speed_hz	= spidev->speed_hz,
-		};/*lint !e785 */
-	struct spi_message	m;
-
-	spi_message_init(&m);
-	spi_message_add_tail(&t, &m);
-	return spidev_sync(spidev, &m);
-}
-
-static inline ssize_t
-spidev_sync_read(struct spidev_data *spidev, size_t len)
-{
-	struct spi_transfer	t = {
-			.rx_buf		= spidev->rx_buffer,
-			.len		= (unsigned)len,
-			.speed_hz	= spidev->speed_hz,
-		};/*lint !e785 */
-	struct spi_message	m;
-
-	spi_message_init(&m);
-	spi_message_add_tail(&t, &m);
-	return spidev_sync(spidev, &m);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* Read-only message with current device setup */
-static ssize_t
-spidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
-{
-	struct spidev_data	*spidev;
-	ssize_t			status = 0;
-
-	/* chipselect only toggles at start or end of operation */
-	if (count > bufsiz)
-		return -EMSGSIZE;
-
-	spidev = filp->private_data;
-
-	mutex_lock(&spidev->buf_lock);
-	status = spidev_sync_read(spidev, count);/*lint !e838 */
-	if (status > 0) {
-		unsigned long	missing;
-
-		missing = copy_to_user(buf, spidev->rx_buffer, (unsigned long)status);
-		if (missing == (unsigned long)status)
-			status = -EFAULT;
-		else
-			status = (unsigned long)status - missing;/*lint !e713 */
-	}
-	mutex_unlock(&spidev->buf_lock);
-
-	return status;
-}/*lint !e715 */
-
-/* Write-only message with current device setup */
-static ssize_t
-spidev_write(struct file *filp, const char __user *buf,
-		size_t count, loff_t *f_pos)
-{
-	struct spidev_data	*spidev;
-	ssize_t			status = 0;
-	unsigned long		missing;
-
-	/* chipselect only toggles at start or end of operation */
-	if (count > bufsiz)
-		return -EMSGSIZE;
-
-	spidev = filp->private_data;
-
-	mutex_lock(&spidev->buf_lock);
-	missing = copy_from_user(spidev->tx_buffer, buf, count);
-	if (missing == 0)
-		status = spidev_sync_write(spidev, count);
-	else
-		status = -EFAULT;
-	mutex_unlock(&spidev->buf_lock);
-
-	return status;
-}/*lint !e715 */
-
-static int spidev_message(struct spidev_data *spidev,
-		struct spi_ioc_transfer *u_xfers, unsigned n_xfers)
-{
-	struct spi_message	msg;
-	struct spi_transfer	*k_xfers;
-	struct spi_transfer	*k_tmp;
-	struct spi_ioc_transfer *u_tmp;
-	unsigned		n, total, tx_total, rx_total;
-	u8			*tx_buf, *rx_buf;
-	int			status = -EFAULT;
-
-	spi_message_init(&msg);
-	k_xfers = kcalloc((size_t)n_xfers, sizeof(*k_tmp), GFP_KERNEL);
-	if (k_xfers == NULL)
-		return -ENOMEM;
-
-	/* Construct spi_message, copying any tx data to bounce buffer.
-	 * We walk the array of user-provided transfers, using each one
-	 * to initialize a kernel version of the same transfer.
-	 */
-	tx_buf = spidev->tx_buffer;
-	rx_buf = spidev->rx_buffer;
-	total = 0;
-	tx_total = 0;
-	rx_total = 0;
-	dev_dbg(&spidev->spi->dev,
-		"spidev_message: n_xfers: %d\n", n_xfers);/*lint !e774 */
-	for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
-			n;
-			n--, k_tmp++, u_tmp++) {
-		k_tmp->len = u_tmp->len;
-
-		total += k_tmp->len;
-		/* Since the function returns the total length of transfers
-		 * on success, restrict the total to positive int values to
-		 * avoid the return value looking like an error.  Also check
-		 * each transfer length to avoid arithmetic overflow.
-		 */
-		if (total > INT_MAX || k_tmp->len > INT_MAX) {
-			status = -EMSGSIZE;
-			dev_dbg(&spidev->spi->dev,
-				"spidev_message: total is more: %d\n", total);/*lint !e774 */
-			goto done;
-		}
-		dev_dbg(&spidev->spi->dev,
-			"spidev_message: rx_buf: %08x, tx_buf: %08x\n",
-			(u32)u_tmp->rx_buf, (u32)u_tmp->tx_buf);/*lint !e774 */
-
-		if (u_tmp->rx_buf) {
-			/* this transfer needs space in RX bounce buffer */
-			rx_total += k_tmp->len;
-			if (rx_total > bufsiz) {
-				status = -EMSGSIZE;
-				goto done;
-			}
-			k_tmp->rx_buf = rx_buf;
-			if (!access_ok(VERIFY_WRITE, (u8 __user *)
-						(uintptr_t) u_tmp->rx_buf,
-						u_tmp->len)) {/*lint !e530 !e529 */
-				dev_dbg(&spidev->spi->dev,
-					"spidev_message: access_ok error\n");/*lint !e774 */
-				goto done;
-			}
-			rx_buf += k_tmp->len;
-		}
-		if (u_tmp->tx_buf) {
-			/* this transfer needs space in TX bounce buffer */
-			tx_total += k_tmp->len;
-			if (tx_total > bufsiz) {
-				status = -EMSGSIZE;
-				goto done;
-			}
-			k_tmp->tx_buf = tx_buf;
-			if (copy_from_user(tx_buf, (const u8 __user *)
-						(uintptr_t) u_tmp->tx_buf,
-					(unsigned long)u_tmp->len)) {
-				dev_dbg(&spidev->spi->dev,
-					"spidev_message: copy_from_user error\n");/*lint !e774 */
-				goto done;
-			}
-			tx_buf += k_tmp->len;
-		}
-
-		k_tmp->cs_change = !!u_tmp->cs_change;
-		k_tmp->tx_nbits = u_tmp->tx_nbits;
-		k_tmp->rx_nbits = u_tmp->rx_nbits;
-		k_tmp->bits_per_word = u_tmp->bits_per_word;
-		k_tmp->delay_usecs = u_tmp->delay_usecs;
-		k_tmp->speed_hz = u_tmp->speed_hz;
-		if (!k_tmp->speed_hz)
-			k_tmp->speed_hz = spidev->speed_hz;
-#ifdef VERBOSE
-		dev_dbg(&spidev->spi->dev,
-			"  xfer len %zd %s%s%s%dbits %u usec %uHz n:%d\n",
-			u_tmp->len,
-			u_tmp->rx_buf ? "rx " : "",
-			u_tmp->tx_buf ? "tx " : "",
-			u_tmp->cs_change ? "cs " : "",
-			u_tmp->bits_per_word ? : spidev->spi->bits_per_word,
-			u_tmp->delay_usecs,
-			u_tmp->speed_hz ? : spidev->spi->max_speed_hz,
-			n);
-#endif
-		spi_message_add_tail(k_tmp, &msg);
-	}
-
-	status = (int)spidev_sync(spidev, &msg);
-	if (status < 0) {
-		dev_dbg(&spidev->spi->dev, "spidev_sync error with status: %d\n", status);/*lint !e774 */
-		goto done;
-	}
-
-	/* copy any rx data out of bounce buffer */
-	rx_buf = spidev->rx_buffer;
-	for (n = n_xfers, u_tmp = u_xfers; n; n--, u_tmp++) {
-		if (u_tmp->rx_buf) {
-			if (__copy_to_user((u8 __user *)
-					(uintptr_t) u_tmp->rx_buf, rx_buf,
-					(unsigned long)u_tmp->len)) {
-				dev_dbg(&spidev->spi->dev, "__copy_to_user error\n");/*lint !e774 */
-				status = -EFAULT;
-				goto done;
-			}
-			rx_buf += u_tmp->len;
-		}
-	}
-	status = (int)total;
-
-done:
-	kfree(k_xfers);
-	return status;
-}
-
-static struct spi_ioc_transfer *
-spidev_get_ioc_message(unsigned int cmd, struct spi_ioc_transfer __user *u_ioc,
-		unsigned *n_ioc)
-{
-	struct spi_ioc_transfer	*ioc;
-	u32	tmp;
-
-	/* Check type, command number and direction */
-	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC
-			|| _IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))/*lint !e84 */
-			|| _IOC_DIR(cmd) != _IOC_WRITE)/*lint !e845 */
-		return ERR_PTR((long)-ENOTTY);
-
-	tmp = _IOC_SIZE(cmd);
-	if ((tmp % sizeof(struct spi_ioc_transfer)) != 0)
-		return ERR_PTR((long)-EINVAL);
-	*n_ioc = tmp / sizeof(struct spi_ioc_transfer);
-	if (*n_ioc == 0)
-		return NULL;
-
-	/* copy into scratch area */
-	ioc = kmalloc((size_t)tmp, GFP_KERNEL);
-	if (!ioc)
-		return ERR_PTR((long)-ENOMEM);
-	if (__copy_from_user(ioc, u_ioc, tmp)) {/*lint !e747 */
-		kfree(ioc);
-		return ERR_PTR((long)-EFAULT);
-	}
-	return ioc;
-}
-
-static long
-spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	int			err = 0;
-	int			retval = 0;
-	struct spidev_data	*spidev;
-	struct spi_device	*spi;
-	u32			tmp;
-	unsigned		n_ioc;
-	struct spi_ioc_transfer	*ioc;
-
-	/* Check type and command number */
-	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)
-		return -ENOTTY;
-
-	/* Check access direction once here; don't repeat below.
-	 * IOC_DIR is from the user perspective, while access_ok is
-	 * from the kernel perspective; so they look reversed.
-	 */
-	if (_IOC_DIR(cmd) & _IOC_READ)
-		err = !access_ok(VERIFY_WRITE,
-				(void __user *)arg, _IOC_SIZE(cmd));/*lint !e530 !e529 */
-	if (err == 0 && _IOC_DIR(cmd) & _IOC_WRITE)
-		err = !access_ok(VERIFY_READ,
-				(void __user *)arg, _IOC_SIZE(cmd));/*lint !e530 !e529 */
-	if (err)
-		return -EFAULT;
-
-	/* guard against device removal before, or while,
-	 * we issue this ioctl.
-	 */
-	spidev = filp->private_data;
-	spin_lock_irq(&spidev->spi_lock);
-	spi = spi_dev_get(spidev->spi);
-	spin_unlock_irq(&spidev->spi_lock);
-
-	if (spi == NULL)
-		return -ESHUTDOWN;
-
-	/* use the buffer lock here for triple duty:
-	 *  - prevent I/O (from us) so calling spi_setup() is safe;
-	 *  - prevent concurrent SPI_IOC_WR_* from morphing
-	 *    data fields while SPI_IOC_RD_* reads them;
-	 *  - SPI_IOC_MESSAGE needs the buffer locked "normally".
-	 */
-	mutex_lock(&spidev->buf_lock);
-
-	switch (cmd) {
-	/* read requests */
-	case SPI_IOC_RD_MODE:/*lint !e30 !e142 */
-		retval = __put_user(spi->mode & SPI_MODE_MASK,
-					(__u8 __user *)arg);/*lint !e1058 !e1514 !e866 !e1564  !e774 !e529 !e734 */
-		break;
-	case SPI_IOC_RD_MODE32:/*lint !e30 !e142 */
-		retval = __put_user(spi->mode & SPI_MODE_MASK,
-					(__u32 __user *)arg);/*lint !e1058 !e1514 !e866 !e1564  !e774 !e529 */
-		break;
-	case SPI_IOC_RD_LSB_FIRST:/*lint !e30 !e142 */
-		retval = __put_user((spi->mode & SPI_LSB_FIRST) ?  1 : 0,
-					(__u8 __user *)arg);/*lint !e1058 !e1514 !e866 !e1564  !e774 !e529 */
-		break;
-	case SPI_IOC_RD_BITS_PER_WORD:/*lint !e30 !e142 */
-		retval = __put_user(spi->bits_per_word, (__u8 __user *)arg);/*lint !e1058 !e1514 !e866 !e1564  !e774 !e529 */
-		break;
-	case SPI_IOC_RD_MAX_SPEED_HZ:/*lint !e30 !e142 */
-		retval = __put_user(spidev->speed_hz, (__u32 __user *)arg);/*lint !e1058 !e1514 !e866 !e1564  !e774 !e529 */
-		break;
-
-	/* write requests */
-	case SPI_IOC_WR_MODE:/*lint !e30 !e142 */
-	case SPI_IOC_WR_MODE32:/*lint !e30 !e142 */
-		if (cmd == SPI_IOC_WR_MODE)
-			retval = __get_user(tmp, (u8 __user *)arg);/*lint !e866 !e1564 !e774 !e50 !e530 */
-		else
-			retval = __get_user(tmp, (u32 __user *)arg);/*lint !e866 !e1564 !e774 !e50 !e530 */
-		if (retval == 0) {/*lint !e774 */
-			u32	save = spi->mode;
-
-			if (tmp & ~SPI_MODE_MASK) {
-				retval = -EINVAL;
-				break;
-			}
-
-			tmp |= spi->mode & ~SPI_MODE_MASK;
-			spi->mode = (u16)tmp;/*lint !e734 */
-			retval = spi_setup(spi);
-			if (retval < 0)/*lint !e774 */
-				spi->mode = save;/*lint !e734 */
-			else
-				dev_dbg(&spi->dev, "spi mode %x\n", tmp);/*lint !e774 */
-		}
-		break;
-	case SPI_IOC_WR_LSB_FIRST:/*lint !e30 !e142 */
-		retval = __get_user(tmp, (__u8 __user *)arg);/*lint !e866 !e1564 !e774 !e50 !e530 */
-		if (retval == 0) {/*lint !e774 */
-			u32	save = spi->mode;
-
-			if (tmp)
-				spi->mode |= SPI_LSB_FIRST;
-			else
-				spi->mode &= ~SPI_LSB_FIRST;
-			retval = spi_setup(spi);
-			if (retval < 0)
-				spi->mode = save;/*lint !e734 */
-			else
-				dev_dbg(&spi->dev, "%csb first\n",
-						tmp ? 'l' : 'm');/*lint !e774 */
-		}
-		break;
-	case SPI_IOC_WR_BITS_PER_WORD:/*lint !e30 !e142 */
-		retval = __get_user(tmp, (__u8 __user *)arg);/*lint !e866 !e1564 !e774 !e50 !e530 */
-		if (retval == 0) {/*lint !e774 */
-			u8	save = spi->bits_per_word;
-
-			spi->bits_per_word = tmp;/*lint !e734 */
-			retval = spi_setup(spi);
-			if (retval < 0)
-				spi->bits_per_word = save;
-			else
-				dev_dbg(&spi->dev, "%d bits per word\n", tmp);/*lint !e774 */
-		}
-		break;
-	case SPI_IOC_WR_MAX_SPEED_HZ:/*lint !e30 !e142 */
-		retval = __get_user(tmp, (__u32 __user *)arg);/*lint !e866 !e1564 !e774 !e50 !e530 */
-		if (retval == 0) {/*lint !e774 */
-			u32	save = spi->max_speed_hz;
-
-			spi->max_speed_hz = tmp;
-			retval = spi_setup(spi);
-			if (retval >= 0)
-				spidev->speed_hz = tmp;
-			else
-				dev_dbg(&spi->dev, "%d Hz (max)\n", tmp);/*lint !e774 */
-			spi->max_speed_hz = save;
-		}
-		break;
-
-	default:
-		/* segmented and/or full-duplex I/O request */
-		/* Check message and copy into scratch area */
-		ioc = spidev_get_ioc_message(cmd,
-				(struct spi_ioc_transfer __user *)arg, &n_ioc);
-		if (IS_ERR(ioc)) {
-			retval = PTR_ERR(ioc);/*lint !e712 */
-			break;
-		}
-		if (!ioc)
-			break;	/* n_ioc is also 0 */
-
-		/* translate to spi_message, execute */
-		retval = spidev_message(spidev, ioc, n_ioc);
-		kfree(ioc);
-		break;
-	}
-
-	mutex_unlock(&spidev->buf_lock);
-	spi_dev_put(spi);
-	return retval;
-}
-
-#ifdef CONFIG_COMPAT
-static long
-spidev_compat_ioc_message(struct file *filp, unsigned int cmd,
-		unsigned long arg)
-{
-	struct spi_ioc_transfer __user	*u_ioc;
-	int				retval = 0;
-	struct spidev_data		*spidev;
-	struct spi_device		*spi;
-	unsigned			n_ioc, n;
-	struct spi_ioc_transfer		*ioc;
-
-	u_ioc = (struct spi_ioc_transfer __user *) compat_ptr(arg);/*lint !e712 !e747 */
-	if (!access_ok(VERIFY_READ, u_ioc, _IOC_SIZE(cmd)))/*lint !e530 !e529 */
-		return -EFAULT;
-
-	/* guard against device removal before, or while,
-	 * we issue this ioctl.
-	 */
-	spidev = filp->private_data;
-	spin_lock_irq(&spidev->spi_lock);
-	spi = spi_dev_get(spidev->spi);
-	spin_unlock_irq(&spidev->spi_lock);
-
-	if (spi == NULL)
-		return -ESHUTDOWN;
-
-	/* SPI_IOC_MESSAGE needs the buffer locked "normally" */
-	mutex_lock(&spidev->buf_lock);
-
-	/* Check message and copy into scratch area */
-	ioc = spidev_get_ioc_message(cmd, u_ioc, &n_ioc);
-	if (IS_ERR(ioc)) {
-		retval = PTR_ERR(ioc);/*lint !e712 */
-		goto done;
-	}
-	if (!ioc)
-		goto done;	/* n_ioc is also 0 */
-
-	/* Convert buffer pointers */
-	for (n = 0; n < n_ioc; n++) {
-		ioc[n].rx_buf = (uintptr_t) compat_ptr(ioc[n].rx_buf);/*lint !e712 !e747 */
-		ioc[n].tx_buf = (uintptr_t) compat_ptr(ioc[n].tx_buf);/*lint !e712 !e747 */
-	}
-
-	/* translate to spi_message, execute */
-	retval = spidev_message(spidev, ioc, n_ioc);
-	kfree(ioc);
-
-done:
-	mutex_unlock(&spidev->buf_lock);
-	spi_dev_put(spi);
-	dev_dbg(&spi->dev, "spidev_ioctl: retval:%d\n", retval);/*lint !e774 */
-
-	return retval;
-}
-
-static long
-spidev_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	if (_IOC_TYPE(cmd) == SPI_IOC_MAGIC
-			&& _IOC_NR(cmd) == _IOC_NR(SPI_IOC_MESSAGE(0))/*lint !e84 */
-			&& _IOC_DIR(cmd) == _IOC_WRITE)/*lint !e845 */
-		return spidev_compat_ioc_message(filp, cmd, arg);
-
-	return spidev_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));/*lint !e712 !e747 */
-}
-#else
-#define spidev_compat_ioctl NULL
-#endif /* CONFIG_COMPAT */
-
-static int spidev_open(struct inode *inode, struct file *filp)
-{
-	struct spidev_data	*spidev;
-	int			status = -ENXIO;
-
-	mutex_lock(&device_list_lock);
-
-	list_for_each_entry(spidev, &device_list, device_entry) {/*lint !e64 !e826 */
-		if (spidev->devt == inode->i_rdev) {
-			status = 0;
-			break;
-		}
-	}
-
-	if (status) {
-		pr_debug("spidev: nothing for minor %d\n", iminor(inode));
-		goto err_find_dev;
-	}
-
-	if (!spidev->tx_buffer) {
-		spidev->tx_buffer = kmalloc(bufsiz, GFP_KERNEL);/*lint !e747 */
-		if (!spidev->tx_buffer) {
-				dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");/*lint !e774 */
-				status = -ENOMEM;
-			goto err_find_dev;
-			}
-		}
-
-	if (!spidev->rx_buffer) {
-		spidev->rx_buffer = kmalloc(bufsiz, GFP_KERNEL);/*lint !e747 */
-		if (!spidev->rx_buffer) {
-			dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");/*lint !e774 */
-			status = -ENOMEM;
-			goto err_alloc_rx_buf;
-		}
-	}
-
-	spidev->users++;
-	filp->private_data = spidev;
-	nonseekable_open(inode, filp);
-
-	mutex_unlock(&device_list_lock);
-	return 0;
-
-err_alloc_rx_buf:
-	kfree(spidev->tx_buffer);
-	spidev->tx_buffer = NULL;
-err_find_dev:
-	mutex_unlock(&device_list_lock);
-	return status;
-}
-
-static int spidev_release(struct inode *inode, struct file *filp)
-{
-	struct spidev_data	*spidev;
-
-	mutex_lock(&device_list_lock);
-	spidev = filp->private_data;
-	filp->private_data = NULL;
-
-	/* last close? */
-	spidev->users--;
-	if (!spidev->users) {
-		int		dofree;
-
-		kfree(spidev->tx_buffer);
-		spidev->tx_buffer = NULL;
-
-		kfree(spidev->rx_buffer);
-		spidev->rx_buffer = NULL;
-
-		spin_lock_irq(&spidev->spi_lock);
-		if (spidev->spi)
-			spidev->speed_hz = spidev->spi->max_speed_hz;
-
-		/* ... after we unbound from the underlying device? */
-		dofree = (spidev->spi == NULL);
-		spin_unlock_irq(&spidev->spi_lock);
-
-		if (dofree)
-			kfree(spidev);
-	}
-	mutex_unlock(&device_list_lock);
-
-	return 0;
-}/*lint !e715 */
-
-static const struct file_operations spidev_fops = {
-	.owner =	THIS_MODULE,/*lint !e64 */
-	/* REVISIT switch to aio primitives, so that userspace
-	 * gets more complete API coverage.  It'll simplify things
-	 * too, except for the locking.
-	 */
-	.write =	spidev_write,
-	.read =		spidev_read,
-	.unlocked_ioctl = spidev_ioctl,
-	.compat_ioctl = spidev_compat_ioctl,
-	.open =		spidev_open,
-	.release =	spidev_release,
-	.llseek =	no_llseek,
-};/*lint !e785 */
-
-/*-------------------------------------------------------------------------*/
-
-/* The main reason to have this class is to make mdev/udev create the
- * /dev/spidevB.C character device nodes exposing our userspace API.
- * It also simplifies memory management.
- */
-
-static struct class *spidev_class;
-
-#ifdef CONFIG_OF
-/*lint -e528 -esym(528,*) */
-static const struct of_device_id spidev_dt_ids[] = {
-/*lint -e528 +esym(528,*) */
-#ifndef CONFIG_HISI_SPI
-	{ .compatible = "rohm,dh2228fv" },
-	{ .compatible = "lineartechnology,ltc2488" },
-#else
-	{ .compatible = "arm,pl022" },/*lint !e785 */
-#endif
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev_dt_ids);
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-static int spidev_probe(struct spi_device *spi)
-{
-	struct spidev_data	*spidev;
-	int			status;
-	unsigned long		minor;
-
-	/*
-	 * spidev should never be referenced in DT without a specific
-	 * compatible string, it is a Linux implementation thing
-	 * rather than a description of the hardware.
-	 */
-#ifndef CONFIG_HISI_SPI
-	if (spi->dev.of_node && !of_match_device(spidev_dt_ids, &spi->dev)) {
-		dev_err(&spi->dev, "buggy DT: spidev listed directly in DT\n");
-		WARN_ON(spi->dev.of_node &&
-			!of_match_device(spidev_dt_ids, &spi->dev));
-	}
-#endif
-
-	/* Allocate driver data */
-	spidev = kzalloc(sizeof(*spidev), GFP_KERNEL);
-	if (!spidev)
-		return -ENOMEM;
-
-	/* Initialize the driver data */
-	spidev->spi = spi;
-	spin_lock_init(&spidev->spi_lock);
-	mutex_init(&spidev->buf_lock);
-
-	INIT_LIST_HEAD(&spidev->device_entry);
-
-	/* If we can allocate a minor number, hook up this device.
-	 * Reusing minors is fine so long as udev or mdev is working.
-	 */
-	mutex_lock(&device_list_lock);
-	minor = find_first_zero_bit(minors, N_SPI_MINORS);/*lint !e747 */
-	if (minor < N_SPI_MINORS) {
-		struct device *dev;
-
-		spidev->devt = MKDEV(SPIDEV_MAJOR, minor);/*lint !e712 !e72 */
-		dev = device_create(spidev_class, &spi->dev, spidev->devt,
-				    spidev, "spidev%d.%d",
-				    spi->master->bus_num, spi->chip_select);
-		status = PTR_ERR_OR_ZERO(dev);
-	} else {
-		dev_dbg(&spi->dev, "no minor number available!\n");/*lint !e774 */
-		status = -ENODEV;
-	}
-	if (status == 0) {
-		set_bit(minor, minors);/*lint !e712 !e747 */
-		list_add(&spidev->device_entry, &device_list);
-	}
-	mutex_unlock(&device_list_lock);
-
-	spidev->speed_hz = spi->max_speed_hz;
-
-	if (status == 0)
-		spi_set_drvdata(spi, spidev);
-	else
-		kfree(spidev);
-
-	return status;
-}
-
-static int spidev_remove(struct spi_device *spi)
-{
-	struct spidev_data	*spidev = spi_get_drvdata(spi);
-
-	/* make sure ops on existing fds can abort cleanly */
-	spin_lock_irq(&spidev->spi_lock);
-	spidev->spi = NULL;
-	spin_unlock_irq(&spidev->spi_lock);
-
-	/* prevent new opens */
-	mutex_lock(&device_list_lock);
-	list_del(&spidev->device_entry);
-	device_destroy(spidev_class, spidev->devt);
-	clear_bit(MINOR(spidev->devt), minors);
-	if (spidev->users == 0)
-		kfree(spidev);
-	mutex_unlock(&device_list_lock);
-
-	return 0;
-}
-
-#ifdef CONFIG_HISI_SPI
-static const struct of_device_id spidev1_dt_ids[] = {
-	{ .compatible = "spi_dev1"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-
-MODULE_DEVICE_TABLE(of, spidev1_dt_ids);
-
-static struct spi_driver spidev_spi_driver1 = {
-	.driver = {
-		.name =		"spi_dev1",
-		.owner =	THIS_MODULE,/*lint !e84  !e64*/
-		.of_match_table = of_match_ptr(spidev1_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev2_dt_ids[] = {
-	{ .compatible = "spi_dev2"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-
-MODULE_DEVICE_TABLE(of, spidev2_dt_ids);
-
-static struct spi_driver spidev_spi_driver2 = {
-	.driver = {
-		.name =		"spi_dev2",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev2_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev3_dt_ids[] = {
-	{ .compatible = "spi_dev3"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-
-MODULE_DEVICE_TABLE(of, spidev3_dt_ids);
-
-static struct spi_driver spidev_spi_driver3 = {
-	.driver = {
-		.name =		"spi_dev3",
-		.owner =	THIS_MODULE,/*lint !e785 !e64 */
-		.of_match_table = of_match_ptr(spidev3_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev10_dt_ids[] = {
-	{ .compatible = "spi_dev10"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-
-MODULE_DEVICE_TABLE(of, spidev10_dt_ids);
-
-static struct spi_driver spidev_spi_driver10 = {
-	.driver = {
-		.name =		"spi_dev10",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev10_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev21_dt_ids[] = {
-	{ .compatible = "spi_dev21"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-
-MODULE_DEVICE_TABLE(of, spidev21_dt_ids);
-
-static struct spi_driver spidev_spi_driver21 = {
-	.driver = {
-		.name =		"spi_dev21",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev21_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev30_dt_ids[] = {
-	{ .compatible = "spi_dev30"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev30_dt_ids);
-static struct spi_driver spidev_spi_driver30 = {
-	.driver = {
-		.name =		"spi_dev30",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev30_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev31_dt_ids[] = {
-	{ .compatible = "spi_dev31"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev31_dt_ids);
-static struct spi_driver spidev_spi_driver31 = {
-	.driver = {
-		.name =		"spi_dev31",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev31_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev32_dt_ids[] = {
-	{ .compatible = "spi_dev32"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev32_dt_ids);
-static struct spi_driver spidev_spi_driver32 = {
-	.driver = {
-		.name =		"spi_dev32",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev32_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev33_dt_ids[] = {
-	{ .compatible = "spi_dev33"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev33_dt_ids);
-static struct spi_driver spidev_spi_driver33 = {
-	.driver = {
-		.name =		"spi_dev33",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev33_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev40_dt_ids[] = {
-	{ .compatible = "spi_dev40"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev40_dt_ids);
-static struct spi_driver spidev_spi_driver40 = {
-	.driver = {
-		.name =		"spi_dev40",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev40_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev41_dt_ids[] = {
-	{ .compatible = "spi_dev41"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev41_dt_ids);
-static struct spi_driver spidev_spi_driver41 = {
-	.driver = {
-		.name =		"spi_dev41",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev41_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev42_dt_ids[] = {
-	{ .compatible = "spi_dev42"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev42_dt_ids);
-static struct spi_driver spidev_spi_driver42 = {
-	.driver = {
-		.name =		"spi_dev42",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev42_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-
-static const struct of_device_id spidev43_dt_ids[] = {
-	{ .compatible = "spi_dev43"},/*lint !e785 */
-	{},/*lint !e785 */
-};
-MODULE_DEVICE_TABLE(of, spidev43_dt_ids);
-static struct spi_driver spidev_spi_driver43 = {
-	.driver = {
-		.name =		"spi_dev43",
-		.owner =	THIS_MODULE,/*lint !e64 */
-		.of_match_table = of_match_ptr(spidev43_dt_ids),
-	},/*lint !e785 */
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-#else
-static struct spi_driver spidev_spi_driver = {
-	.driver = {
-		.name =		"spidev",
-		.owner =	THIS_MODULE,
-		.of_match_table = of_match_ptr(spidev_dt_ids),
-	},
-	.probe =	spidev_probe,
-	.remove =	spidev_remove,
-
-	/* NOTE:  suspend/resume methods are not necessary here.
-	 * We don't do anything except pass the requests to/from
-	 * the underlying controller.  The refrigerator handles
-	 * most issues; the controller driver handles the rest.
-	 */
-};
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-static int __init spidev_init(void)
-{
-	int status;
-
-	/* Claim our 256 reserved device numbers.  Then register a class
-	 * that will key udev/mdev to add/remove /dev nodes.  Last, register
-	 * the driver which manages those device numbers.
-	 */
-	BUILD_BUG_ON(N_SPI_MINORS > 256);/*lint !e514 */
-	status = register_chrdev(SPIDEV_MAJOR, "spi", &spidev_fops);
-	if (status < 0)
-		return status;
-
-	spidev_class = class_create(THIS_MODULE, "spidev");/*lint !e64 */
-	if (IS_ERR(spidev_class)) {
-#ifndef CONFIG_HISI_SPI
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);
-#endif
-		return PTR_ERR(spidev_class);/*lint !e712 */
-	}
-
-#ifdef CONFIG_HISI_SPI
-	status = spi_register_driver(&spidev_spi_driver1);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver1.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver2);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver2.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver3);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver3.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver10);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver10.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver21);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver21.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver30);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver30.driver.name);
-	}
-
-
-	status = spi_register_driver(&spidev_spi_driver31);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver31.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver32);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver32.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver33);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver33.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver40);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver40.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver41);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver41.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver42);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver42.driver.name);
-	}
-
-	status = spi_register_driver(&spidev_spi_driver43);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver43.driver.name);
-	}
-#else
-	status = spi_register_driver(&spidev_spi_driver);
-	if (status < 0) {
-		class_destroy(spidev_class);
-		unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);
-	}
-#endif
-
-	return status;
-}
-/*lint -e528 -esym(528,*) */
-module_init(spidev_init);/*lint !e528 */
-/*lint -e528 +esym(528,*) */
-static void __exit spidev_exit(void)
-{
-#ifdef CONFIG_HISI_SPI
-	spi_unregister_driver(&spidev_spi_driver1);
-	spi_unregister_driver(&spidev_spi_driver2);
-	spi_unregister_driver(&spidev_spi_driver3);
-	spi_unregister_driver(&spidev_spi_driver10);
-	spi_unregister_driver(&spidev_spi_driver21);
-	spi_unregister_driver(&spidev_spi_driver30);
-	spi_unregister_driver(&spidev_spi_driver31);
-	spi_unregister_driver(&spidev_spi_driver32);
-	spi_unregister_driver(&spidev_spi_driver33);
-	spi_unregister_driver(&spidev_spi_driver40);
-	spi_unregister_driver(&spidev_spi_driver41);
-	spi_unregister_driver(&spidev_spi_driver42);
-	spi_unregister_driver(&spidev_spi_driver43);
-
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver1.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver2.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver3.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver10.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver21.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver30.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver31.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver32.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver33.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver40.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver41.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver42.driver.name);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver43.driver.name);
-#else
-	spi_unregister_driver(&spidev_spi_driver);
-	class_destroy(spidev_class);
-	unregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);
-#endif
-}
-/*lint -e528 -esym(528,*) */
-module_exit(spidev_exit);
-/*lint -e528 +esym(528,*) */
-
-/*lint -e753 -esym(753,*) */
-MODULE_AUTHOR("Andrea Paterniani, <a.paterniani@swapp!eng.it>");
-MODULE_DESCRIPTION("User mode SPI device interface");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("spi:spidev");
-/*lint -e753 +esym(753,*) */
diff --git a/drivers/usb/dwc3/dwc3-kirin660.c b/drivers/usb/dwc3/dwc3-kirin660.c
deleted file mode 120000
index de18443..0000000
--- a/drivers/usb/dwc3/dwc3-kirin660.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/usb/dwc3/dwc3-kirin660.c
\ No newline at end of file
diff --git a/drivers/usb/dwc3/dwc3-kirin980.c b/drivers/usb/dwc3/dwc3-kirin980.c
deleted file mode 120000
index 77ae397..0000000
--- a/drivers/usb/dwc3/dwc3-kirin980.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../../../vendor/hisi/ap/kernel/drivers/usb/dwc3/dwc3-kirin980.c
\ No newline at end of file
diff --git a/include/linux/blk-mq.h b/include/linux/blk-mq.h
index c97bfbd..a3994a7 100644
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@ -73,19 +73,15 @@
 	int			numa_node;
 	unsigned int		timeout;
 	unsigned int		flags;		/* BLK_MQ_F_* */
-#ifdef CONFIG_HISI_BLK_MQ
 	unsigned int 		high_prio_tags;
 	unsigned int 		hisi_mq_flags;
-#endif
 	void			*driver_data;
 
 	struct blk_mq_tags	**tags;
 
 	struct mutex		tag_list_lock;
 	struct list_head	tag_list;
-#ifdef CONFIG_HISI_BLK_CORE
 	struct blk_lld_func lld_func;
-#endif
 };
 
 struct blk_mq_queue_data {
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 32eaff6..40f8081 100755
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -1559,6 +1559,7 @@
 		q->hisi_blk_mq_quirk_flags = 0;
 }
 #else
+static inline void hisi_blk_mq_tagset_set_flag(struct blk_mq_tag_set* set, int flag_bit){}
 static inline void hisi_blk_mq_set_queue_quirk(struct request_queue *q,
 						int quirks){}
 static inline bool hisi_blk_mq_test_queue_quirk(struct request_queue *q,
diff --git a/include/linux/jump_label.h b/include/linux/jump_label.h
old mode 100644
new mode 100755
index 8351721..6890446
--- a/include/linux/jump_label.h
+++ b/include/linux/jump_label.h
@@ -157,7 +157,6 @@
 extern void static_key_slow_inc(struct static_key *key);
 extern void static_key_slow_dec(struct static_key *key);
 extern void jump_label_apply_nops(struct module *mod);
-extern int jump_label_register(struct module *mod);
 
 #define STATIC_KEY_INIT_TRUE					\
 	{ .enabled = ATOMIC_INIT(1),				\
@@ -215,11 +214,6 @@
 static inline int jump_label_apply_nops(struct module *mod)
 {
 	return 0;
-}
-
-static inline int jump_label_register(struct module *mod)
-{
-       return 0;
 }
 
 #define STATIC_KEY_INIT_TRUE	{ .enabled = ATOMIC_INIT(1) }
diff --git a/include/linux/livepatch.h b/include/linux/livepatch.h
old mode 100644
new mode 100755
index 8db44f3..5990497
--- a/include/linux/livepatch.h
+++ b/include/linux/livepatch.h
@@ -47,7 +47,6 @@
 	/* external */
 	const char *old_name;
 	void *new_func;
-	unsigned long new_size;
 	/*
 	 * The old_addr field is optional and can be used to resolve
 	 * duplicate symbol names in the vmlinux object.  If this
@@ -57,16 +56,11 @@
 	 * way to resolve the ambiguity.
 	 */
 	unsigned long old_addr;
-	unsigned long old_size;
-	const char *ref_name;
-	long ref_offset;
-	int force;
 
 	/* internal */
 	struct kobject kobj;
 	enum klp_state state;
 	struct list_head stack_node;
-	struct list_head list_node;
 };
 
 /**
@@ -86,12 +80,6 @@
 	const char *name;
 	int addend;
 	int external;
-	const char *ref_name;
-	long ref_offset;
-};
-
-struct klp_hook {
-	void (*hook)(void);
 };
 
 /**
@@ -109,11 +97,9 @@
 	const char *name;
 	struct klp_reloc *relocs;
 	struct klp_func *funcs;
-	struct klp_hook *hooks_load;
-	struct klp_hook *hooks_unload;
 
 	/* internal */
-	struct kobject *kobj;
+	struct kobject kobj;
 	struct module *mod;
 	enum klp_state state;
 };
@@ -145,8 +131,8 @@
 
 int klp_register_patch(struct klp_patch *);
 int klp_unregister_patch(struct klp_patch *);
-int enable_patch(struct klp_patch *);
-int disable_patch(struct klp_patch *);
+int klp_enable_patch(struct klp_patch *);
+int klp_disable_patch(struct klp_patch *);
 
 #endif /* CONFIG_LIVEPATCH */
 
diff --git a/init/Kconfig b/init/Kconfig
old mode 100644
new mode 100755
index 7a214a1..f6b4d8c
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1288,13 +1288,6 @@
 	help
 	  Hisilicon EAS scheduler.
 
-config HISI_RT_OPT
-	bool "hisilicon rt-threads optimization"
-	depends on HISI_EAS_SCHED
-	default n
-	help
-	  Limit rt-threads to slow cpus for power saving.
-
 config SCHED_AUTOGROUP
 	bool "Automatic process group scheduling"
 	select CGROUPS
diff --git a/kernel/jump_label.c b/kernel/jump_label.c
old mode 100644
new mode 100755
index 3cd09df..453ec42
--- a/kernel/jump_label.c
+++ b/kernel/jump_label.c
@@ -464,11 +464,6 @@
 	.priority = 1, /* higher than tracepoints */
 };
 
-int jump_label_register(struct module *mod)
-{
-	return jump_label_module_notify(&jump_label_module_nb, MODULE_STATE_COMING, mod);
-}
-
 static __init int jump_label_init_module(void)
 {
 	return register_module_notifier(&jump_label_module_nb);
diff --git a/kernel/livepatch/Kconfig b/kernel/livepatch/Kconfig
old mode 100644
new mode 100755
index f4f3d64..0450225
--- a/kernel/livepatch/Kconfig
+++ b/kernel/livepatch/Kconfig
@@ -3,14 +3,11 @@
 	help
 	  Arch supports kernel live patching
 
-if HAVE_LIVEPATCH
-menu "Enable Livepatch"
-
 config LIVEPATCH
 	bool "Kernel Live Patching"
+	depends on DYNAMIC_FTRACE_WITH_REGS
 	depends on MODULES
 	depends on SYSFS
-	depends on PROC_FS
 	depends on KALLSYMS_ALL
 	depends on HAVE_LIVEPATCH
 	help
@@ -19,13 +16,3 @@
 	  module uses the interface provided by this option to register
 	  a patch, causing calls to patched functions to be redirected
 	  to new function code contained in the patch module.
-
-config LIVEPATCH_STACK
-	bool "Enforcing the patch stacking principle"
-	depends on LIVEPATCH
-	default y
-	help
-	  Say N here if you want to remove the patch stacking principle.
-
-endmenu
-endif
diff --git a/kernel/livepatch/core.c b/kernel/livepatch/core.c
old mode 100644
new mode 100755
index cfa7cb0..db545cb
--- a/kernel/livepatch/core.c
+++ b/kernel/livepatch/core.c
@@ -24,22 +24,28 @@
 #include <linux/kernel.h>
 #include <linux/mutex.h>
 #include <linux/slab.h>
+#include <linux/ftrace.h>
 #include <linux/list.h>
 #include <linux/kallsyms.h>
 #include <linux/livepatch.h>
-#include <asm/stacktrace.h>
-#include <linux/stop_machine.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <asm/memory.h>
-#include <huawei_platform/log/imonitor.h>
-#include <asm/livepatch-hhee.h>
 
-unsigned long hkip_token;
-
-struct patch_data {
-	struct klp_patch	*patch;
-	atomic_t		cpu_count;
+/**
+ * struct klp_ops - structure for tracking registered ftrace ops structs
+ *
+ * A single ftrace_ops is shared between all enabled replacement functions
+ * (klp_func structs) which have the same old_addr.  This allows the switch
+ * between function versions to happen instantaneously by updating the klp_ops
+ * struct's func_stack list.  The winner is the klp_func at the top of the
+ * func_stack (front of the list).
+ *
+ * @node:	node for the global klp_ops list
+ * @func_stack:	list head for the stack of klp_func's (active func is on top)
+ * @fops:	registered ftrace ops struct
+ */
+struct klp_ops {
+	struct list_head node;
+	struct list_head func_stack;
+	struct ftrace_ops fops;
 };
 
 /*
@@ -51,9 +57,24 @@
 static DEFINE_MUTEX(klp_mutex);
 
 static LIST_HEAD(klp_patches);
+static LIST_HEAD(klp_ops);
 
-static void klp_free_patch(struct klp_patch *patch);
 static struct kobject *klp_root_kobj;
+
+static struct klp_ops *klp_find_ops(unsigned long old_addr)
+{
+	struct klp_ops *ops;
+	struct klp_func *func;
+
+	list_for_each_entry(ops, &klp_ops, node) {
+		func = list_first_entry(&ops->func_stack, struct klp_func,
+					stack_node);
+		if (func->old_addr == old_addr)
+			return ops;
+	}
+
+	return NULL;
+}
 
 static bool klp_is_module(struct klp_object *obj)
 {
@@ -66,12 +87,12 @@
 }
 
 /* sets obj->mod if object is not vmlinux and module is found */
-static int klp_find_object_module(struct klp_object *obj)
+static void klp_find_object_module(struct klp_object *obj)
 {
 	struct module *mod;
 
 	if (!klp_is_module(obj))
-		return 0;
+		return;
 
 	mutex_lock(&module_mutex);
 	/*
@@ -80,18 +101,17 @@
 	 * a going module handler instead.
 	 */
 	mod = find_module(obj->name);
-
-	if (mod) {
+	/*
+	 * Do not mess work of the module coming and going notifiers.
+	 * Note that the patch might still be needed before the going handler
+	 * is called. Module functions can be called even in the GOING state
+	 * until mod->exit() finishes. This is especially important for
+	 * patches that modify semantic of the functions.
+	 */
+	if (mod && mod->klp_alive)
 		obj->mod = mod;
-		try_module_get(mod);
-	} else {
-		pr_err("module '%s' not loaded\n", obj->name);
-		mutex_unlock(&module_mutex);
-		return -EINVAL;
-	}
 
 	mutex_unlock(&module_mutex);
-	return 0;
 }
 
 /* klp_mutex must be held by caller */
@@ -108,7 +128,7 @@
 
 static bool klp_initialized(void)
 {
-	return klp_root_kobj;
+	return !!klp_root_kobj;
 }
 
 struct klp_find_arg {
@@ -163,13 +183,15 @@
 	kallsyms_on_each_symbol(klp_find_callback, &args);
 	mutex_unlock(&module_mutex);
 
-	if (args.count == 1) {
+	if (args.count == 0)
+		pr_err("symbol '%s' not found in symbol table\n", name);
+	else if (args.count > 1)
+		pr_err("unresolvable ambiguity (%lu matches) on symbol '%s' in object '%s'\n",
+		       args.count, name, objname);
+	else {
 		*addr = args.addr;
 		return 0;
 	}
-
-	if (args.count == 0)
-		pr_err("symbol '%s' not found in symbol table\n", name);
 
 	*addr = 0;
 	return -EINVAL;
@@ -221,22 +243,13 @@
 
 #if defined(CONFIG_RANDOMIZE_BASE)
 	/* If KASLR has been enabled, adjust old_addr accordingly */
-	if (func->old_addr)
-		func->old_addr += (kimage_vaddr - KIMAGE_VADDR);
+	if (kaslr_enabled() && func->old_addr)
+		func->old_addr += kaslr_offset();
 #endif
 
-	if (!func->old_addr || klp_is_module(obj)) {
+	if (!func->old_addr || klp_is_module(obj))
 		ret = klp_find_object_symbol(obj->name, func->old_name,
 					     &func->old_addr);
-		if (ret && func->ref_name) {
-			unsigned long ref_addr;
-			ret = klp_find_object_symbol(obj->name, func->ref_name,
-					&ref_addr);
-			if (!ret)
-				func->old_addr = (unsigned long)((long)ref_addr +
-						func->ref_offset);
-		}
-	}
 	else
 		ret = klp_verify_vmlinux_symbol(func->old_name,
 						func->old_addr);
@@ -284,7 +297,8 @@
 
 #if defined(CONFIG_RANDOMIZE_BASE)
 			/* If KASLR has been enabled, adjust old value accordingly */
-			reloc->val += (kimage_vaddr - KIMAGE_VADDR);
+			if (kaslr_enabled())
+				reloc->val += kaslr_offset();
 #endif
 			ret = klp_verify_vmlinux_symbol(reloc->name,
 							reloc->val);
@@ -294,23 +308,12 @@
 			/* module, reloc->val needs to be discovered */
 			if (reloc->external)
 				ret = klp_find_external_symbol(pmod,
-						reloc->name,
-						&reloc->val);
-			else {
+							       reloc->name,
+							       &reloc->val);
+			else
 				ret = klp_find_object_symbol(obj->mod->name,
-						reloc->name,
-						&reloc->val);
-				if (ret && reloc->ref_name) {
-					unsigned long ref_addr;
-					ret = klp_find_object_symbol(obj->mod->name,
-							reloc->ref_name,
-							&ref_addr);
-					if (!ret)
-						reloc->val = (unsigned long)((long)ref_addr +
-								reloc->ref_offset);
-				}
-			}
-
+							     reloc->name,
+							     &reloc->val);
 			if (ret)
 				return ret;
 		}
@@ -326,51 +329,57 @@
 	return 0;
 }
 
-void __weak arch_klp_disable_func(struct klp_func *func)
+static void notrace klp_ftrace_handler(unsigned long ip,
+				       unsigned long parent_ip,
+				       struct ftrace_ops *fops,
+				       struct pt_regs *regs)
 {
+	struct klp_ops *ops;
+	struct klp_func *func;
+
+	ops = container_of(fops, struct klp_ops, fops);
+
+	rcu_read_lock();
+	func = list_first_or_null_rcu(&ops->func_stack, struct klp_func,
+				      stack_node);
+	if (WARN_ON_ONCE(!func))
+		goto unlock;
+
+	klp_arch_set_pc(regs, (unsigned long)func->new_func);
+unlock:
+	rcu_read_unlock();
 }
 
 static void klp_disable_func(struct klp_func *func)
 {
-	WARN_ON(func->state != KLP_ENABLED);
-	WARN_ON(!func->old_addr);
+	struct klp_ops *ops;
 
-	arch_klp_disable_func(func);
+	if (WARN_ON(func->state != KLP_ENABLED))
+		return;
+	if (WARN_ON(!func->old_addr))
+		return;
+
+	ops = klp_find_ops(func->old_addr);
+	if (WARN_ON(!ops))
+		return;
+
+	if (list_is_singular(&ops->func_stack)) {
+		WARN_ON(unregister_ftrace_function(&ops->fops));
+		WARN_ON(ftrace_set_filter_ip(&ops->fops, func->old_addr, 1, 0));
+
+		list_del_rcu(&func->stack_node);
+		list_del(&ops->node);
+		kfree(ops);
+	} else {
+		list_del_rcu(&func->stack_node);
+	}
+
 	func->state = KLP_DISABLED;
-}
-#define KLP_PATCH_STATE_IMONITOR_ID     (940000002)
-#define UPLOADTYPE_INIT_FAIL    (1)
-#define UPLOADTYPE_ENABLE_FAIL  (2)
-#define UPLOADTYPE_DISBALE_FAIL (3)
-
-static int do_upload_log(long type,const char * desc)
-{
-	struct imonitor_eventobj *obj=NULL;
-	int ret = 0;
-
-	obj = imonitor_create_eventobj(KLP_PATCH_STATE_IMONITOR_ID);
-	if (obj) {
-		ret += imonitor_set_param(obj, E940000002_ERRTYPE_INT,type);
-		ret += imonitor_set_param(obj, E940000002_ERRDESC_VARCHAR,(long)desc);
-		if(ret){
-			imonitor_destroy_eventobj(obj);
-			return ret;
-		}
-		ret = imonitor_send_event(obj);
-		imonitor_destroy_eventobj(obj);
-	}
-	else {
-		ret = -1;
-	}
-	return ret;
-}
-int __weak arch_klp_enable_func(struct klp_func *func)
-{
-	return 0;
 }
 
 static int klp_enable_func(struct klp_func *func)
 {
+	struct klp_ops *ops;
 	int ret;
 
 	if (WARN_ON(!func->old_addr))
@@ -379,41 +388,62 @@
 	if (WARN_ON(func->state != KLP_DISABLED))
 		return -EINVAL;
 
-	ret = arch_klp_enable_func(func);
+	ops = klp_find_ops(func->old_addr);
+	if (!ops) {
+		ops = kzalloc(sizeof(*ops), GFP_KERNEL);
+		if (!ops)
+			return -ENOMEM;
+
+		ops->fops.func = klp_ftrace_handler;
+		ops->fops.flags = FTRACE_OPS_FL_SAVE_REGS |
+				  FTRACE_OPS_FL_DYNAMIC |
+				  FTRACE_OPS_FL_IPMODIFY;
+
+		list_add(&ops->node, &klp_ops);
+
+		INIT_LIST_HEAD(&ops->func_stack);
+		list_add_rcu(&func->stack_node, &ops->func_stack);
+
+		ret = ftrace_set_filter_ip(&ops->fops, func->old_addr, 0, 0);
+		if (ret) {
+			pr_err("failed to set ftrace filter for function '%s' (%d)\n",
+			       func->old_name, ret);
+			goto err;
+		}
+
+		ret = register_ftrace_function(&ops->fops);
+		if (ret) {
+			pr_err("failed to register ftrace handler for function '%s' (%d)\n",
+			       func->old_name, ret);
+			ftrace_set_filter_ip(&ops->fops, func->old_addr, 1, 0);
+			goto err;
+		}
+
+
+	} else {
+		list_add_rcu(&func->stack_node, &ops->func_stack);
+	}
+
 	func->state = KLP_ENABLED;
 
 	return 0;
-}
 
-static inline int klp_unload_hook(struct klp_object *obj)
-{
-	struct klp_hook *hook;
-
-	for (hook = obj->hooks_unload; hook->hook; hook++)
-		(*hook->hook)();
-
-	return 0;
+err:
+	list_del_rcu(&func->stack_node);
+	list_del(&ops->node);
+	kfree(ops);
+	return ret;
 }
 
 static void klp_disable_object(struct klp_object *obj)
 {
 	struct klp_func *func;
 
-	for (func = obj->funcs; func->old_name; func++)
+	klp_for_each_func(obj, func)
 		if (func->state == KLP_ENABLED)
 			klp_disable_func(func);
 
 	obj->state = KLP_DISABLED;
-}
-
-static inline int klp_load_hook(struct klp_object *obj)
-{
-	struct klp_hook *hook;
-
-	for (hook = obj->hooks_load; hook->hook; hook++)
-		(*hook->hook)();
-
-	return 0;
 }
 
 static int klp_enable_object(struct klp_object *obj)
@@ -427,7 +457,7 @@
 	if (WARN_ON(!klp_is_object_loaded(obj)))
 		return -EINVAL;
 
-	for (func = obj->funcs; func->old_name; func++) {
+	klp_for_each_func(obj, func) {
 		ret = klp_enable_func(func);
 		if (ret) {
 			klp_disable_object(obj);
@@ -439,162 +469,122 @@
 	return 0;
 }
 
-void __weak arch_klp_code_modify_prepare(void)
-{
-
-}
-
-void __weak arch_klp_code_modify_post_process(void)
-{
-
-}
-
-/*
- * This function is called from stop_machine() context.
- */
-int disable_patch(struct klp_patch *patch)
+static int __klp_disable_patch(struct klp_patch *patch)
 {
 	struct klp_object *obj;
 
+	/* enforce stacking: only the last enabled patch can be disabled */
+	if (!list_is_last(&patch->list, &klp_patches) &&
+	    list_next_entry(patch, list)->state == KLP_ENABLED)
+		return -EBUSY;
+
 	pr_notice("disabling patch '%s'\n", patch->mod->name);
 
-	for (obj = patch->objs; obj->funcs; obj++) {
+	klp_for_each_object(patch, obj) {
 		if (obj->state == KLP_ENABLED)
 			klp_disable_object(obj);
 	}
 
 	patch->state = KLP_DISABLED;
-	module_put(patch->mod);
+
 	return 0;
 }
 
-int klp_try_disable_patch(void *data)
-{
-	struct klp_patch *patch = data;
-	int ret = 0;
-
-	ret = klp_check_calltrace(patch, 0);
-	if (ret)
-		return ret;
-
-	ret = disable_patch(patch);
-	return ret;
-}
-
-static int __klp_disable_patch(struct klp_patch *patch)
+/**
+ * klp_disable_patch() - disables a registered patch
+ * @patch:	The registered, enabled patch to be disabled
+ *
+ * Unregisters the patched functions from ftrace.
+ *
+ * Return: 0 on success, otherwise error
+ */
+int klp_disable_patch(struct klp_patch *patch)
 {
 	int ret;
 
-#ifdef CONFIG_LIVEPATCH_STACK
-	/* enforce stacking: only the last enabled patch can be disabled */
-	if (!list_is_last(&patch->list, &klp_patches) &&
-	    list_next_entry(patch, list)->state == KLP_ENABLED)
-		return -EBUSY;
-#endif
+	mutex_lock(&klp_mutex);
 
-	arch_klp_code_modify_prepare();
-	ret = stop_machine(klp_try_disable_patch, patch, NULL);
-	arch_klp_code_modify_post_process();
+	if (!klp_is_patch_registered(patch)) {
+		ret = -EINVAL;
+		goto err;
+	}
 
+	if (patch->state == KLP_DISABLED) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = __klp_disable_patch(patch);
+
+err:
+	mutex_unlock(&klp_mutex);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(klp_disable_patch);
 
-/*
- * This function is called from stop_machine() context.
- */
-int enable_patch(struct klp_patch *patch)
+static int __klp_enable_patch(struct klp_patch *patch)
 {
 	struct klp_object *obj;
 	int ret;
+
+	if (WARN_ON(patch->state != KLP_DISABLED))
+		return -EINVAL;
+
+	/* enforce stacking: only the first disabled patch can be enabled */
+	if (patch->list.prev != &klp_patches &&
+	    list_prev_entry(patch, list)->state == KLP_DISABLED)
+		return -EBUSY;
 
 	pr_notice_once("tainting kernel with TAINT_LIVEPATCH\n");
 	add_taint(TAINT_LIVEPATCH, LOCKDEP_STILL_OK);
 
 	pr_notice("enabling patch '%s'\n", patch->mod->name);
 
-	for (obj = patch->objs; obj->funcs; obj++) {
+	klp_for_each_object(patch, obj) {
+		if (!klp_is_object_loaded(obj))
+			continue;
+
 		ret = klp_enable_object(obj);
 		if (ret)
-			goto disable;
+			goto unregister;
 	}
 
 	patch->state = KLP_ENABLED;
-	try_module_get(patch->mod);
+
 	return 0;
 
-disable:
-	disable_patch(patch);
-	pr_err("livepatch: enable_patch failed,ret = %d.\n",ret);
+unregister:
+	WARN_ON(__klp_disable_patch(patch));
 	return ret;
 }
 
-int klp_try_enable_patch(void *data)
-{
-	int ret = 0;
-	int flag = 0;
-	struct patch_data *pd = data;
-
-	if (atomic_inc_return(&pd->cpu_count) == 1) {
-		struct klp_patch *patch = pd->patch;
-
-		ret = klp_check_calltrace(patch, 1);
-		if (ret) {
-			flag = 1;
-			atomic_inc(&pd->cpu_count);
-			return ret;
-		}
-		ret = enable_patch(patch);
-		if (ret) {
-			flag = 1;
-			atomic_inc(&pd->cpu_count);
-			return ret;
-		}
-		atomic_inc(&pd->cpu_count);
-	} else {
-		while (atomic_read(&pd->cpu_count) <= num_online_cpus())
-			cpu_relax();
-
-		if (!flag)
-			isb();
-	}
-
-	return ret;
-}
-
-static int __klp_enable_patch(struct klp_patch *patch)
+/**
+ * klp_enable_patch() - enables a registered patch
+ * @patch:	The registered, disabled patch to be enabled
+ *
+ * Performs the needed symbol lookups and code relocations,
+ * then registers the patched functions with ftrace.
+ *
+ * Return: 0 on success, otherwise error
+ */
+int klp_enable_patch(struct klp_patch *patch)
 {
 	int ret;
-	struct patch_data patch_data = {
-		.patch = patch,
-		.cpu_count = ATOMIC_INIT(0),
-	};
 
-	if (WARN_ON(patch->state != KLP_DISABLED))
-		return -EINVAL;
+	mutex_lock(&klp_mutex);
 
-#ifdef CONFIG_LIVEPATCH_STACK
-	/* enforce stacking: only the first disabled patch can be enabled */
-	if (patch->list.prev != &klp_patches &&
-			(list_prev_entry(patch, list)->state == KLP_DISABLED)) {
-		pr_err("only the first disabled patch can be enabled\n");
-		return -EBUSY;
+	if (!klp_is_patch_registered(patch)) {
+		ret = -EINVAL;
+		goto err;
 	}
-#endif
 
-	arch_klp_code_modify_prepare();
-	ret = stop_machine(klp_try_enable_patch, &patch_data, cpu_online_mask);
-	arch_klp_code_modify_post_process();
-	if (ret)
-		return ret;
+	ret = __klp_enable_patch(patch);
 
-#ifndef CONFIG_LIVEPATCH_STACK
-	/* move the enabled patch to the list tail */
-	list_del(&patch->list);
-	list_add_tail(&patch->list, &klp_patches);
-#endif
-
-	return 0;
+err:
+	mutex_unlock(&klp_mutex);
+	return ret;
 }
+EXPORT_SYMBOL_GPL(klp_enable_patch);
 
 /*
  * Sysfs Interface
@@ -603,14 +593,7 @@
  * /sys/kernel/livepatch/<patch>
  * /sys/kernel/livepatch/<patch>/enabled
  * /sys/kernel/livepatch/<patch>/<object>
- * /sys/kernel/livepatch/<patch>/<object>/<func> or
- * /sys/kernel/livepatch/<patch>/<object>/<func-number>
- */
-
-/*
- * Procfs Interface
- *
- * /proc/livepatch/state
+ * /sys/kernel/livepatch/<patch>/<object>/<func>
  */
 
 static ssize_t enabled_store(struct kobject *kobj, struct kobj_attribute *attr,
@@ -653,12 +636,6 @@
 
 err:
 	mutex_unlock(&klp_mutex);
-	if(val == KLP_ENABLED) {
-		(void)do_upload_log(UPLOADTYPE_ENABLE_FAIL,"enable patch failed.");
-	}
-	else{
-		(void)do_upload_log(UPLOADTYPE_DISBALE_FAIL,"disable patch failed.");
-	}
 	return ret;
 }
 
@@ -691,6 +668,15 @@
 	.default_attrs = klp_patch_attrs,
 };
 
+static void klp_kobj_release_object(struct kobject *kobj)
+{
+}
+
+static struct kobj_type klp_ktype_object = {
+	.release = klp_kobj_release_object,
+	.sysfs_ops = &kobj_sysfs_ops,
+};
+
 static void klp_kobj_release_func(struct kobject *kobj)
 {
 }
@@ -700,9 +686,6 @@
 	.sysfs_ops = &kobj_sysfs_ops,
 };
 
-void __weak arch_klp_free_func(struct klp_object *obj, struct klp_func *func)
-{
-}
 /*
  * Free all functions' kobjects in the array up to some limit. When limit is
  * NULL, all kobjects are freed.
@@ -712,10 +695,19 @@
 {
 	struct klp_func *func;
 
-	for (func = obj->funcs; func->old_name && func != limit; func++) {
-		arch_klp_free_func(obj, func);
+	for (func = obj->funcs; func->old_name && func != limit; func++)
 		kobject_put(&func->kobj);
-	}
+}
+
+/* Clean up when a patched object is unloaded */
+static void klp_free_object_loaded(struct klp_object *obj)
+{
+	struct klp_func *func;
+
+	obj->mod = NULL;
+
+	klp_for_each_func(obj, func)
+		func->old_addr = 0;
 }
 
 /*
@@ -728,11 +720,8 @@
 	struct klp_object *obj;
 
 	for (obj = patch->objs; obj->funcs && obj != limit; obj++) {
-		if (klp_is_module(obj))
-			module_put(obj->mod);
-
 		klp_free_funcs_limited(obj, NULL);
-		kobject_put(obj->kobj);
+		kobject_put(&obj->kobj);
 	}
 }
 
@@ -744,43 +733,13 @@
 	kobject_put(&patch->kobj);
 }
 
-static int klp_count_sysfs_funcs(struct klp_object *obj, const char *name)
-{
-	struct klp_func *func;
-	int n = 0;
-	/* count the times a function name occurs and is initialized */
-	for (func = obj->funcs; func->old_name; func++) {
-		if ((!strcmp(func->old_name, name) &&
-			func->kobj.state_initialized))
-				n++;
-	}
-
-	return n;
-}
-
-int __weak arch_klp_init_func(struct klp_object *obj, struct klp_func *func)
-{
-	return 0;
-}
-
 static int klp_init_func(struct klp_object *obj, struct klp_func *func)
 {
-	int ret;
-	unsigned int count;
-
-	ret = arch_klp_init_func(obj, func);
-	if (ret)
-		return ret;
-
+	INIT_LIST_HEAD(&func->stack_node);
 	func->state = KLP_DISABLED;
 
-	count = klp_count_sysfs_funcs(obj, func->old_name);
-	if (count)
-		return kobject_init_and_add(&func->kobj, &klp_ktype_func,
-				obj->kobj, "%s-%d", func->old_name, count);
-	else
-		return kobject_init_and_add(&func->kobj, &klp_ktype_func,
-				obj->kobj, "%s", func->old_name);
+	return kobject_init_and_add(&func->kobj, &klp_ktype_func,
+				    &obj->kobj, "%s", func->old_name);
 }
 
 /* parts of the initialization that is done only when the object is loaded */
@@ -796,7 +755,7 @@
 			return ret;
 	}
 
-	for (func = obj->funcs; func->old_name; func++) {
+	klp_for_each_func(obj, func) {
 		ret = klp_find_verify_func_addr(obj, func);
 		if (ret)
 			return ret;
@@ -817,23 +776,22 @@
 	obj->state = KLP_DISABLED;
 	obj->mod = NULL;
 
-	ret = klp_find_object_module(obj);
+	klp_find_object_module(obj);
+
+	name = klp_is_module(obj) ? obj->name : "vmlinux";
+	ret = kobject_init_and_add(&obj->kobj, &klp_ktype_object,
+				   &patch->kobj, "%s", name);
 	if (ret)
 		return ret;
 
-	name = klp_is_module(obj) ? obj->name : "vmlinux";
-	obj->kobj = kobject_create_and_add(name, &patch->kobj);
-	if (!obj->kobj)
-		return -ENOMEM;
+	klp_for_each_func(obj, func) {
+		ret = klp_init_func(obj, func);
+		if (ret)
+			goto free;
+	}
 
 	if (klp_is_object_loaded(obj)) {
 		ret = klp_init_object_loaded(patch, obj);
-		if (ret)
-			goto out;
-	}
-
-	for (func = obj->funcs; func->old_name; func++) {
-		ret = klp_init_func(obj, func);
 		if (ret)
 			goto free;
 	}
@@ -842,9 +800,7 @@
 
 free:
 	klp_free_funcs_limited(obj, func);
-out:
-	kobject_put(obj->kobj);
-	pr_err("livepatch: klp initialize object of patch failed,ret = %d.\n",ret);
+	kobject_put(&obj->kobj);
 	return ret;
 }
 
@@ -865,16 +821,11 @@
 	if (ret)
 		goto unlock;
 
-	for (obj = patch->objs; obj->funcs; obj++) {
+	klp_for_each_object(patch, obj) {
 		ret = klp_init_object(patch, obj);
 		if (ret)
 			goto free;
 	}
-
-	jump_label_register(patch->mod);
-
-	for (obj = patch->objs; obj->funcs; obj++)
-		klp_load_hook(obj);
 
 	list_add_tail(&patch->list, &klp_patches);
 
@@ -887,8 +838,6 @@
 	kobject_put(&patch->kobj);
 unlock:
 	mutex_unlock(&klp_mutex);
-	(void)do_upload_log(UPLOADTYPE_INIT_FAIL,"init patch failed.");
-	pr_err("livepatch: klp initialize patch failed,ret = %d.\n",ret);
 	return ret;
 }
 
@@ -903,7 +852,6 @@
 int klp_unregister_patch(struct klp_patch *patch)
 {
 	int ret = 0;
-	struct klp_object *obj;
 
 	mutex_lock(&klp_mutex);
 
@@ -919,12 +867,8 @@
 
 	klp_free_patch(patch);
 
-	for (obj = patch->objs; obj->funcs; obj++)
-		klp_unload_hook(obj);
-
 out:
 	mutex_unlock(&klp_mutex);
-	(void)do_upload_log(UPLOADTYPE_INIT_FAIL,"unregister patch failed.");
 	return ret;
 }
 EXPORT_SYMBOL_GPL(klp_unregister_patch);
@@ -948,80 +892,146 @@
 	if (!patch || !patch->mod)
 		return -EINVAL;
 
+	/*
+	 * A reference is taken on the patch module to prevent it from being
+	 * unloaded.  Right now, we don't allow patch modules to unload since
+	 * there is currently no method to determine if a thread is still
+	 * running in the patched code contained in the patch module once
+	 * the ftrace registration is successful.
+	 */
+	if (!try_module_get(patch->mod))
+		return -ENODEV;
+
 	ret = klp_init_patch(patch);
+	if (ret)
+		module_put(patch->mod);
 
 	return ret;
 }
 EXPORT_SYMBOL_GPL(klp_register_patch);
 
-static int state_show(struct seq_file *m, void *v)
+static int klp_module_notify_coming(struct klp_patch *patch,
+				     struct klp_object *obj)
 {
-	struct klp_patch *patch;
-	char *state;
-	int index = 0;
-	seq_printf(m, "%-5s\t%-26s\t%-8s\n", "Index", "Patch", "State");
-	seq_printf(m, "-----------------------------------------------\n");
-	mutex_lock(&klp_mutex);
-	list_for_each_entry(patch, &klp_patches, list) {
-		if (patch->state == KLP_ENABLED)
-			state = "enabled";
-		else if (patch->state == KLP_DISABLED)
-			state = "disabled";
-		else
-			state = "UNDEF";
+	struct module *pmod = patch->mod;
+	struct module *mod = obj->mod;
+	int ret;
 
-		seq_printf(m, "%-5d\t%-26s\t%-8s\n", ++index, patch->mod->name, state);
+	ret = klp_init_object_loaded(patch, obj);
+	if (ret) {
+		pr_warn("failed to initialize patch '%s' for module '%s' (%d)\n",
+			pmod->name, mod->name, ret);
+		return ret;
 	}
+
+	if (patch->state == KLP_DISABLED)
+		return 0;
+
+	pr_notice("applying patch '%s' to loading module '%s'\n",
+		  pmod->name, mod->name);
+
+	ret = klp_enable_object(obj);
+	if (ret)
+		pr_warn("failed to apply patch '%s' to module '%s' (%d)\n",
+			pmod->name, mod->name, ret);
+	return ret;
+}
+
+static void klp_module_notify_going(struct klp_patch *patch,
+				    struct klp_object *obj)
+{
+	struct module *pmod = patch->mod;
+	struct module *mod = obj->mod;
+
+	if (patch->state == KLP_DISABLED)
+		goto disabled;
+
+	pr_notice("reverting patch '%s' on unloading module '%s'\n",
+		  pmod->name, mod->name);
+
+	klp_disable_object(obj);
+
+disabled:
+	klp_free_object_loaded(obj);
+}
+
+static int klp_module_notify(struct notifier_block *nb, unsigned long action,
+			     void *data)
+{
+	int ret;
+	struct module *mod = data;
+	struct klp_patch *patch;
+	struct klp_object *obj;
+
+	if (action != MODULE_STATE_COMING && action != MODULE_STATE_GOING)
+		return 0;
+
+	mutex_lock(&klp_mutex);
+
+	/*
+	 * Each module has to know that the notifier has been called.
+	 * We never know what module will get patched by a new patch.
+	 */
+	if (action == MODULE_STATE_COMING)
+		mod->klp_alive = true;
+	else /* MODULE_STATE_GOING */
+		mod->klp_alive = false;
+
+	list_for_each_entry(patch, &klp_patches, list) {
+		klp_for_each_object(patch, obj) {
+			if (!klp_is_module(obj) || strcmp(obj->name, mod->name))
+				continue;
+
+			if (action == MODULE_STATE_COMING) {
+				obj->mod = mod;
+				ret = klp_module_notify_coming(patch, obj);
+				if (ret) {
+					obj->mod = NULL;
+					pr_warn("patch '%s' is in an inconsistent state!\n",
+						patch->mod->name);
+				}
+			} else /* MODULE_STATE_GOING */
+				klp_module_notify_going(patch, obj);
+
+			break;
+		}
+	}
+
 	mutex_unlock(&klp_mutex);
-	seq_printf(m, "-----------------------------------------------\n");
 
 	return 0;
 }
 
-static int klp_state_open(struct inode *inode, struct file *filp)
-{
-	return single_open(filp, state_show, NULL);
-}
-
-static const struct file_operations proc_klpstate_operations = {
-	.open		= klp_state_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+static struct notifier_block klp_module_nb = {
+	.notifier_call = klp_module_notify,
+	.priority = INT_MIN+1, /* called late but before ftrace notifier */
 };
 
 static int __init klp_init(void)
 {
 	int ret;
-	struct proc_dir_entry *root_klp_dir, *res;
 
-	if (is_hkip_enabled())
-		hkip_token = get_hkip_token();
 	ret = klp_check_compiler_support();
 	if (ret) {
 		pr_info("Your compiler is too old; turning off.\n");
 		return -EINVAL;
 	}
 
-	root_klp_dir = proc_mkdir("livepatch", NULL);
-	if (!root_klp_dir)
-		goto error_out;
-
-	res = proc_create("livepatch/state", 0, NULL, &proc_klpstate_operations);
-	if (!res)
-		goto error_remove;
+	ret = register_module_notifier(&klp_module_nb);
+	if (ret)
+		return ret;
 
 	klp_root_kobj = kobject_create_and_add("livepatch", kernel_kobj);
-	if (!klp_root_kobj)
-		goto error_remove;
+	if (!klp_root_kobj) {
+		ret = -ENOMEM;
+		goto unregister;
+	}
 
 	return 0;
 
-error_remove:
-	remove_proc_entry("livepatch", NULL);
-	(void)do_upload_log(UPLOADTYPE_INIT_FAIL,"kernel patch module initialize failed.");
-error_out:
-	return -ENOMEM;
+unregister:
+	unregister_module_notifier(&klp_module_nb);
+	return ret;
 }
 
 module_init(klp_init);
diff --git a/kernel/module.c b/kernel/module.c
index c46a342..49c31e2 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -71,10 +71,7 @@
 #ifndef ARCH_SHF_SMALL
 #define ARCH_SHF_SMALL 0
 #endif
-#ifdef CONFIG_HISI_HHEE
-#include <linux/hisi/hisi_hhee.h>
-static unsigned long clarify_token;
-#endif
+
 /*
  * Modules' sections will be aligned on page boundaries
  * to ensure complete separation of code and data, but
@@ -1905,9 +1902,6 @@
 	/* begin and end PFNs of the current subsection */
 	unsigned long begin_pfn;
 	unsigned long end_pfn;
-#ifdef CONFIG_HISI_HHEE
-	struct arm_smccc_res res;
-#endif
 
 	/*
 	 * Set RO for module text and RO-data:
@@ -1928,12 +1922,6 @@
 		if (end_pfn > begin_pfn)
 			set_memory_nx(begin_pfn << PAGE_SHIFT, end_pfn - begin_pfn);
 	}
-#ifdef CONFIG_HISI_HHEE
-	if(HHEE_ENABLE == hhee_check_enable())
-		arm_smccc_hvc( HHEE_LKM_UPDATE, (unsigned long)base, text_size,
-			clarify_token, 0, 0, 0, 0, &res);
-#endif
-
 }
 
 static void unset_module_core_ro_nx(struct module *mod)
@@ -4009,21 +3997,6 @@
 	return 0;
 }
 module_init(proc_modules_init);
-#endif
-
-#ifdef CONFIG_HISI_HHEE
-static int __init module_token_init(void)
-{
-
-	struct arm_smccc_res res;
-	if(HHEE_ENABLE == hhee_check_enable()){
-		arm_smccc_hvc(HHEE_HVC_TOKEN, 0, 0,
-			0, 0, 0, 0, 0, &res);
-		clarify_token = res.a1;
-	}
-	return 0;
-}
-module_init(module_token_init);
 #endif
 
 /* Given an address, look for it in the module exception tables. */
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
old mode 100644
new mode 100755
index b5256ad..ff0fd0e
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -3915,17 +3915,10 @@
 	set_load_weight(p);
 }
 
-#ifdef CONFIG_HISI_RT_OPT
-void hisi_get_slow_cpus(struct cpumask *cpumask);
-#endif
-
 /* Actually do priority change: must hold pi & rq lock. */
 static void __setscheduler(struct rq *rq, struct task_struct *p,
 			   const struct sched_attr *attr, bool keep_boost)
 {
-#ifdef CONFIG_HISI_RT_OPT
-	struct cpumask slow_cpus;
-#endif
 	__setscheduler_params(p, attr);
 
 	/*
@@ -3941,16 +3934,6 @@
 		p->sched_class = &dl_sched_class;
 	else if (rt_prio(p->prio)) {
 		p->sched_class = &rt_sched_class;
-#ifdef CONFIG_HISI_RT_OPT
-		hisi_get_slow_cpus(&slow_cpus);
-
-		if (!cpumask_empty(&slow_cpus) &&
-		    cpumask_equal(&p->cpus_allowed, cpu_all_mask) &&
-		    cpumask_intersects(&slow_cpus, &p->cpus_allowed)) {
-			p->nr_cpus_allowed = cpumask_weight(&slow_cpus);
-			do_set_cpus_allowed(p, &slow_cpus);
-		}
-#endif
 	}
 	else
 		p->sched_class = &fair_sched_class;
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
old mode 100644
new mode 100755
index 7747ebf..8181363
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -5775,24 +5775,9 @@
 {
 	unsigned long capacity = capacity_of(cpu);
 	unsigned long max_capacity = cpu_rq(cpu)->rd->max_cpu_capacity.val;
-#ifdef CONFIG_HISI_EAS_SCHED
-	unsigned long max_allowed_cap = 0;
-	int allowed_cpu;
-#endif
 
 	if (capacity == max_capacity)
 		return true;
-
-#ifdef CONFIG_HISI_EAS_SCHED
-	for_each_cpu(allowed_cpu, tsk_cpus_allowed(p)) {
-		if (capacity_orig_of(allowed_cpu) > max_allowed_cap)
-			max_allowed_cap = capacity_orig_of(allowed_cpu);
-	}
-
-	/* allowed cpus is limited */
-	if (max_allowed_cap <= capacity_orig_of(cpu))
-		return true;
-#endif
 
 	return __task_fits(p, cpu, 0);
 }
@@ -6550,12 +6535,6 @@
 		 * point.
 		 */
 		do {
-#ifdef CONFIG_HISI_EAS_SCHED
-			cpumask_t allowed_cpus;
-			cpumask_and(&allowed_cpus, tsk_cpus_allowed(p), sched_group_cpus(sg));
-			if (cpumask_empty(&allowed_cpus))
-				continue;
-#endif
 			/* Assuming all cpus are the same in group */
 			int max_cap_cpu = group_first_cpu(sg);
 
@@ -6664,23 +6643,8 @@
 		if (cpu_overutilized(task_cpu(p)))
 			return target_cpu;
 
-#ifdef CONFIG_HISI_EAS_SCHED
-		nrg_diff = energy_diff(&eenv);
-		if (nrg_diff == 0) {
-			if (capacity_orig_of(task_cpu(p)) == capacity_orig_of(target_cpu)) {
-				if (cpu_util(target_cpu) > cpu_util(task_cpu(p)))
-					return task_cpu(p);
-			} else if (capacity_orig_of(task_cpu(p)) < capacity_orig_of(target_cpu)) {
-				if (!cpu_overutilized(task_cpu(p)))
-					return task_cpu(p);
-			}
-		} else if (nrg_diff > 0) {
-			return task_cpu(p);
-		}
-#else
 		if (energy_diff(&eenv) >= 0)
 			return task_cpu(p);
-#endif
 	}
 
 	return target_cpu;
@@ -7599,55 +7563,6 @@
 
 static const unsigned int sched_nr_migrate_break = 32;
 
-/* must hold runqueue lock for queue se is currently on */
-static struct task_struct *hisi_get_heaviest_task(
-				struct task_struct *p, int cpu)
-{
-	int num_tasks = 5;
-	struct sched_entity *se = &p->se;
-	unsigned long int max_util = task_util(p), max_preferred_util= 0, util;
-	struct task_struct *tsk, *max_preferred_tsk = NULL, *max_util_task = p;
-
-	/* The currently running task is not on the runqueue */
-	se = __pick_first_entity(cfs_rq_of(se));
-
-	while (num_tasks && se) {
-		if (!entity_is_task(se)) {
-			se = __pick_next_entity(se);
-			num_tasks--;
-			continue;
-		}
-
-		tsk = task_of(se);
-		util = boosted_task_util(tsk);
-#ifdef CONFIG_CGROUP_SCHEDTUNE
-		bool boosted = schedtune_task_boost(tsk) > 0;
-		bool prefer_idle = schedtune_prefer_idle(tsk) > 0;
-#else
-		bool boosted = 0;
-		bool prefer_idle = 0;
-#endif
-
-		if (cpumask_test_cpu(cpu, tsk_cpus_allowed(tsk))) {
-			if (boosted || prefer_idle) {
-				if (util > max_preferred_util) {
-					max_preferred_util = util;;
-					max_preferred_tsk = tsk;
-				}
-			} else {
-				if (util > max_util) {
-					max_util = util;
-					max_util_task = tsk;
-				}
-			}
-		}
-
-		se = __pick_next_entity(se);
-		num_tasks--;
-	}
-
-	return max_preferred_tsk ? max_preferred_tsk : max_util_task;
-}
 /*
  * detach_tasks() -- tries to detach up to imbalance weighted load from
  * busiest_rq, as part of a balancing operation within domain "sd".
@@ -7687,25 +7602,6 @@
 			env->flags |= LBF_NEED_BREAK;
 			break;
 		}
-
-#ifdef CONFIG_HISI_EAS_SCHED
-		if (energy_aware() &&
-		    (capacity_orig_of(env->dst_cpu) > capacity_orig_of(env->src_cpu))) {
-			p = hisi_get_heaviest_task(p, env->dst_cpu);
-
-#ifdef CONFIG_CGROUP_SCHEDTUNE
-			bool boosted = schedtune_task_boost(p) > 0;
-			bool prefer_idle = schedtune_prefer_idle(p) > 0;
-#else
-			bool boosted = 0;
-			bool prefer_idle = 0;
-#endif
-			if (!boosted && !prefer_idle &&
-				task_util(p) * 100 < capacity_orig_of(env->src_cpu) * up_migration_util_filter)
-				goto next;
-
-		}
-#endif
 
 		if (!can_migrate_task(p, env))
 			goto next;
@@ -8826,7 +8722,7 @@
 	 */
 	update_sd_lb_stats(env, &sds);
 
-	if (energy_aware() && ((env->sd->flags & SD_ASYM_CPUCAPACITY) ||  env->idle == CPU_NOT_IDLE)) {
+	if (energy_aware()) {
 		if (!is_sd_overutilized(env->sd))
 			goto out_balanced;
 	}
@@ -8886,22 +8782,10 @@
 		 * significant if the diff is greater than 1 otherwise we
 		 * might end up to just move the imbalance on another group
 		 */
-#ifdef CONFIG_HISI_EAS_SCHED
 		if ((busiest->group_type != group_overloaded) &&
 		    (local->idle_cpus <= (busiest->idle_cpus + 1)) &&
 		    !group_smaller_cpu_capacity(sds.busiest, sds.local))
 			goto out_balanced;
-#else
-		/* busiest->group_type is group_other, if the CPU is in the same frequency doamin
-		 * then the load balance will be aborted.
-		 *
-		 * CPU 4 have a lot of threads but the CPU util is low, the group_type will be assiged 
-		 * to group_other. NOHZ idle balance will be needed to spread tasks out.
-		 */
-		if ((local->idle_cpus <= (busiest->idle_cpus + 1)) &&
-			    busiest->sum_nr_running <= busiest->group_weight)
-			goto out_balanced;
-#endif
 	} else {
 		/*
 		 * In the CPU_NEWLY_IDLE, CPU_NOT_IDLE cases, use
@@ -9600,108 +9484,10 @@
 	unsigned long next_balance;     /* in jiffy units */
 } nohz ____cacheline_aligned;
 
-#ifdef CONFIG_HISI_EAS_SCHED
-/*
- * Reset balance_interval at all sched_domain levels of given cpu, so that it
- * honors kick.
- */
-static inline void reset_balance_interval(int cpu)
-{
-	struct sched_domain *sd;
-
-	if (cpu >= nr_cpu_ids)
-		return;
-
-	rcu_read_lock();
-	for_each_domain(cpu, sd)
-		sd->balance_interval = 0;
-	rcu_read_unlock();
-}
-
-#define NOHZ_KICK_ANY		0
-#define NOHZ_KICK_RESTRICT	1
-#define NOHZ_KICK_BOOST		2
-
-static inline int nohz_kick_type(int call_cpu, struct sched_domain *sd)
-{
-	int type = NOHZ_KICK_ANY;
-	int i;
-
-	if (hisi_test_fast_cpu(call_cpu))
-		return NOHZ_KICK_ANY;
-
-	if (energy_aware() && cpu_rq(call_cpu)->misfit_task) {
-		type = NOHZ_KICK_ANY;
-	} else if (!is_sd_overutilized(sd) && !cpu_overutilized(call_cpu)) {
-		type = NOHZ_KICK_RESTRICT;
-	} else {
-		for_each_cpu(i, sched_domain_span(sd)) {
-
-			if (cpu_util(i) * sd_capacity_margin < capacity_orig_of(i) * 1024) {
-				/* Change the kick type to limit to CPUs that
-				 * are of equal or lower capacity.
-				 */
-				type = NOHZ_KICK_RESTRICT;
-				break;
-			}
-		}
-	}
-
-	return type;
-}
-
-static inline int hisi_find_new_ilb(void)
-{
-	struct sched_domain *sd;
-	int call_cpu = smp_processor_id();
-	int type = NOHZ_KICK_ANY;
-	int ilb = nr_cpu_ids;
-	bool ilb_found = false;
-
-	rcu_read_lock();
-
-	sd = rcu_dereference_check_sched_domain(cpu_rq(call_cpu)->sd);
-	if (!sd) {
-		rcu_read_unlock();
-		return nr_cpu_ids;
-	}
-
-	type = nohz_kick_type(call_cpu, sd);
-
-	for_each_domain(call_cpu, sd) {
-		for_each_cpu_and(ilb, nohz.idle_cpus_mask, sched_domain_span(sd)) {
-			if (idle_cpu(ilb)) {
-				bool is_bigger_cpu =  capacity_orig_of(ilb) > capacity_orig_of(call_cpu);
-
-				if ((type == NOHZ_KICK_ANY) ||
-					(type == NOHZ_KICK_BOOST && is_bigger_cpu) ||
-					(type == NOHZ_KICK_RESTRICT && !is_bigger_cpu)) {
-					ilb_found = true;
-					break;
-				}
-
-			}
-		}
-
-		if (ilb_found)
-			break;
-	}
-
-	rcu_read_unlock();
-
-	reset_balance_interval(ilb);
-
-	return ilb;
-}
-#endif
 
 static inline int find_new_ilb(void)
 {
-#ifdef CONFIG_HISI_EAS_SCHED
-	int ilb = hisi_find_new_ilb();
-#else
 	int ilb = cpumask_first(nohz.idle_cpus_mask);
-#endif
 
 	if (ilb < nr_cpu_ids && idle_cpu(ilb))
 		return ilb;
@@ -9857,7 +9643,7 @@
 
 	rcu_read_lock();
 	for_each_domain(cpu, sd) {
-		if (energy_aware() && ((sd->flags & SD_ASYM_CPUCAPACITY) ||  idle == CPU_NOT_IDLE)) {
+		if (energy_aware()) {
 			if (!is_sd_overutilized(sd))
 				continue;
 		}
diff --git a/mm/pagecache_debug.c b/mm/pagecache_debug.c
deleted file mode 120000
index 9c409eb..0000000
--- a/mm/pagecache_debug.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/mm_hisi/pagecache_debug.c
\ No newline at end of file
diff --git a/mm/pagecache_manage.c b/mm/pagecache_manage.c
deleted file mode 120000
index 3652d8a..0000000
--- a/mm/pagecache_manage.c
+++ /dev/null
@@ -1 +0,0 @@
-../../../vendor/hisi/ap/kernel/mm_hisi/pagecache_manage.c
\ No newline at end of file
diff --git a/scripts/hw_hidesyms_blacklist.txt b/scripts/hw_hidesyms_blacklist.txt
index 90fe5a2..b58f4d1 100644
--- a/scripts/hw_hidesyms_blacklist.txt
+++ b/scripts/hw_hidesyms_blacklist.txt
@@ -8,7 +8,4 @@
 #
 
 # Start
-hkip_token
-clarify_token
-oases_hkip_token
 # End
